// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_proto_patient.proto

#ifndef PROTOBUF_rt_5ftps_5fproto_5fpatient_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fproto_5fpatient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tps {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5ftps_5fproto_5fpatient_2eproto();
void protobuf_AssignDesc_rt_5ftps_5fproto_5fpatient_2eproto();
void protobuf_ShutdownFile_rt_5ftps_5fproto_5fpatient_2eproto();

class RtTpsProtoPatient;

// ===================================================================

class RtTpsProtoPatient : public ::google::protobuf::Message {
 public:
  RtTpsProtoPatient();
  virtual ~RtTpsProtoPatient();
  
  RtTpsProtoPatient(const RtTpsProtoPatient& from);
  
  inline RtTpsProtoPatient& operator=(const RtTpsProtoPatient& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoPatient& default_instance();
  
  void Swap(RtTpsProtoPatient* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoPatient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoPatient& from);
  void MergeFrom(const RtTpsProtoPatient& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string patientUID = 1;
  inline bool has_patientuid() const;
  inline void clear_patientuid();
  static const int kPatientUIDFieldNumber = 1;
  inline const ::std::string& patientuid() const;
  inline void set_patientuid(const ::std::string& value);
  inline void set_patientuid(const char* value);
  inline void set_patientuid(const char* value, size_t size);
  inline ::std::string* mutable_patientuid();
  inline ::std::string* release_patientuid();
  
  // optional string patientNamePrefix = 2;
  inline bool has_patientnameprefix() const;
  inline void clear_patientnameprefix();
  static const int kPatientNamePrefixFieldNumber = 2;
  inline const ::std::string& patientnameprefix() const;
  inline void set_patientnameprefix(const ::std::string& value);
  inline void set_patientnameprefix(const char* value);
  inline void set_patientnameprefix(const char* value, size_t size);
  inline ::std::string* mutable_patientnameprefix();
  inline ::std::string* release_patientnameprefix();
  
  // optional string patientFirstName = 3;
  inline bool has_patientfirstname() const;
  inline void clear_patientfirstname();
  static const int kPatientFirstNameFieldNumber = 3;
  inline const ::std::string& patientfirstname() const;
  inline void set_patientfirstname(const ::std::string& value);
  inline void set_patientfirstname(const char* value);
  inline void set_patientfirstname(const char* value, size_t size);
  inline ::std::string* mutable_patientfirstname();
  inline ::std::string* release_patientfirstname();
  
  // optional string patientMiddleName = 4;
  inline bool has_patientmiddlename() const;
  inline void clear_patientmiddlename();
  static const int kPatientMiddleNameFieldNumber = 4;
  inline const ::std::string& patientmiddlename() const;
  inline void set_patientmiddlename(const ::std::string& value);
  inline void set_patientmiddlename(const char* value);
  inline void set_patientmiddlename(const char* value, size_t size);
  inline ::std::string* mutable_patientmiddlename();
  inline ::std::string* release_patientmiddlename();
  
  // optional string patientLastName = 5;
  inline bool has_patientlastname() const;
  inline void clear_patientlastname();
  static const int kPatientLastNameFieldNumber = 5;
  inline const ::std::string& patientlastname() const;
  inline void set_patientlastname(const ::std::string& value);
  inline void set_patientlastname(const char* value);
  inline void set_patientlastname(const char* value, size_t size);
  inline ::std::string* mutable_patientlastname();
  inline ::std::string* release_patientlastname();
  
  // optional string patientNameSuffix = 6;
  inline bool has_patientnamesuffix() const;
  inline void clear_patientnamesuffix();
  static const int kPatientNameSuffixFieldNumber = 6;
  inline const ::std::string& patientnamesuffix() const;
  inline void set_patientnamesuffix(const ::std::string& value);
  inline void set_patientnamesuffix(const char* value);
  inline void set_patientnamesuffix(const char* value, size_t size);
  inline ::std::string* mutable_patientnamesuffix();
  inline ::std::string* release_patientnamesuffix();
  
  // optional string patientID = 7;
  inline bool has_patientid() const;
  inline void clear_patientid();
  static const int kPatientIDFieldNumber = 7;
  inline const ::std::string& patientid() const;
  inline void set_patientid(const ::std::string& value);
  inline void set_patientid(const char* value);
  inline void set_patientid(const char* value, size_t size);
  inline ::std::string* mutable_patientid();
  inline ::std::string* release_patientid();
  
  // optional int32 patientsex = 8;
  inline bool has_patientsex() const;
  inline void clear_patientsex();
  static const int kPatientsexFieldNumber = 8;
  inline ::google::protobuf::int32 patientsex() const;
  inline void set_patientsex(::google::protobuf::int32 value);
  
  // optional string patientDateOfBirth = 9;
  inline bool has_patientdateofbirth() const;
  inline void clear_patientdateofbirth();
  static const int kPatientDateOfBirthFieldNumber = 9;
  inline const ::std::string& patientdateofbirth() const;
  inline void set_patientdateofbirth(const ::std::string& value);
  inline void set_patientdateofbirth(const char* value);
  inline void set_patientdateofbirth(const char* value, size_t size);
  inline ::std::string* mutable_patientdateofbirth();
  inline ::std::string* release_patientdateofbirth();
  
  // optional bool isinternal = 10;
  inline bool has_isinternal() const;
  inline void clear_isinternal();
  static const int kIsinternalFieldNumber = 10;
  inline bool isinternal() const;
  inline void set_isinternal(bool value);
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoPatient)
 private:
  inline void set_has_patientuid();
  inline void clear_has_patientuid();
  inline void set_has_patientnameprefix();
  inline void clear_has_patientnameprefix();
  inline void set_has_patientfirstname();
  inline void clear_has_patientfirstname();
  inline void set_has_patientmiddlename();
  inline void clear_has_patientmiddlename();
  inline void set_has_patientlastname();
  inline void clear_has_patientlastname();
  inline void set_has_patientnamesuffix();
  inline void clear_has_patientnamesuffix();
  inline void set_has_patientid();
  inline void clear_has_patientid();
  inline void set_has_patientsex();
  inline void clear_has_patientsex();
  inline void set_has_patientdateofbirth();
  inline void clear_has_patientdateofbirth();
  inline void set_has_isinternal();
  inline void clear_has_isinternal();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* patientuid_;
  ::std::string* patientnameprefix_;
  ::std::string* patientfirstname_;
  ::std::string* patientmiddlename_;
  ::std::string* patientlastname_;
  ::std::string* patientnamesuffix_;
  ::std::string* patientid_;
  ::std::string* patientdateofbirth_;
  ::google::protobuf::int32 patientsex_;
  bool isinternal_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fpatient_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fpatient_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fpatient_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoPatient* default_instance_;
};
// ===================================================================


// ===================================================================

// RtTpsProtoPatient

// required string patientUID = 1;
inline bool RtTpsProtoPatient::has_patientuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoPatient::clear_has_patientuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoPatient::clear_patientuid() {
  if (patientuid_ != &::google::protobuf::internal::kEmptyString) {
    patientuid_->clear();
  }
  clear_has_patientuid();
}
inline const ::std::string& RtTpsProtoPatient::patientuid() const {
  return *patientuid_;
}
inline void RtTpsProtoPatient::set_patientuid(const ::std::string& value) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(value);
}
inline void RtTpsProtoPatient::set_patientuid(const char* value) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(value);
}
inline void RtTpsProtoPatient::set_patientuid(const char* value, size_t size) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientuid() {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  return patientuid_;
}
inline ::std::string* RtTpsProtoPatient::release_patientuid() {
  clear_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientuid_;
    patientuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientNamePrefix = 2;
inline bool RtTpsProtoPatient::has_patientnameprefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientnameprefix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoPatient::clear_has_patientnameprefix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoPatient::clear_patientnameprefix() {
  if (patientnameprefix_ != &::google::protobuf::internal::kEmptyString) {
    patientnameprefix_->clear();
  }
  clear_has_patientnameprefix();
}
inline const ::std::string& RtTpsProtoPatient::patientnameprefix() const {
  return *patientnameprefix_;
}
inline void RtTpsProtoPatient::set_patientnameprefix(const ::std::string& value) {
  set_has_patientnameprefix();
  if (patientnameprefix_ == &::google::protobuf::internal::kEmptyString) {
    patientnameprefix_ = new ::std::string;
  }
  patientnameprefix_->assign(value);
}
inline void RtTpsProtoPatient::set_patientnameprefix(const char* value) {
  set_has_patientnameprefix();
  if (patientnameprefix_ == &::google::protobuf::internal::kEmptyString) {
    patientnameprefix_ = new ::std::string;
  }
  patientnameprefix_->assign(value);
}
inline void RtTpsProtoPatient::set_patientnameprefix(const char* value, size_t size) {
  set_has_patientnameprefix();
  if (patientnameprefix_ == &::google::protobuf::internal::kEmptyString) {
    patientnameprefix_ = new ::std::string;
  }
  patientnameprefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientnameprefix() {
  set_has_patientnameprefix();
  if (patientnameprefix_ == &::google::protobuf::internal::kEmptyString) {
    patientnameprefix_ = new ::std::string;
  }
  return patientnameprefix_;
}
inline ::std::string* RtTpsProtoPatient::release_patientnameprefix() {
  clear_has_patientnameprefix();
  if (patientnameprefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientnameprefix_;
    patientnameprefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientFirstName = 3;
inline bool RtTpsProtoPatient::has_patientfirstname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientfirstname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoPatient::clear_has_patientfirstname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoPatient::clear_patientfirstname() {
  if (patientfirstname_ != &::google::protobuf::internal::kEmptyString) {
    patientfirstname_->clear();
  }
  clear_has_patientfirstname();
}
inline const ::std::string& RtTpsProtoPatient::patientfirstname() const {
  return *patientfirstname_;
}
inline void RtTpsProtoPatient::set_patientfirstname(const ::std::string& value) {
  set_has_patientfirstname();
  if (patientfirstname_ == &::google::protobuf::internal::kEmptyString) {
    patientfirstname_ = new ::std::string;
  }
  patientfirstname_->assign(value);
}
inline void RtTpsProtoPatient::set_patientfirstname(const char* value) {
  set_has_patientfirstname();
  if (patientfirstname_ == &::google::protobuf::internal::kEmptyString) {
    patientfirstname_ = new ::std::string;
  }
  patientfirstname_->assign(value);
}
inline void RtTpsProtoPatient::set_patientfirstname(const char* value, size_t size) {
  set_has_patientfirstname();
  if (patientfirstname_ == &::google::protobuf::internal::kEmptyString) {
    patientfirstname_ = new ::std::string;
  }
  patientfirstname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientfirstname() {
  set_has_patientfirstname();
  if (patientfirstname_ == &::google::protobuf::internal::kEmptyString) {
    patientfirstname_ = new ::std::string;
  }
  return patientfirstname_;
}
inline ::std::string* RtTpsProtoPatient::release_patientfirstname() {
  clear_has_patientfirstname();
  if (patientfirstname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientfirstname_;
    patientfirstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientMiddleName = 4;
inline bool RtTpsProtoPatient::has_patientmiddlename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientmiddlename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoPatient::clear_has_patientmiddlename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoPatient::clear_patientmiddlename() {
  if (patientmiddlename_ != &::google::protobuf::internal::kEmptyString) {
    patientmiddlename_->clear();
  }
  clear_has_patientmiddlename();
}
inline const ::std::string& RtTpsProtoPatient::patientmiddlename() const {
  return *patientmiddlename_;
}
inline void RtTpsProtoPatient::set_patientmiddlename(const ::std::string& value) {
  set_has_patientmiddlename();
  if (patientmiddlename_ == &::google::protobuf::internal::kEmptyString) {
    patientmiddlename_ = new ::std::string;
  }
  patientmiddlename_->assign(value);
}
inline void RtTpsProtoPatient::set_patientmiddlename(const char* value) {
  set_has_patientmiddlename();
  if (patientmiddlename_ == &::google::protobuf::internal::kEmptyString) {
    patientmiddlename_ = new ::std::string;
  }
  patientmiddlename_->assign(value);
}
inline void RtTpsProtoPatient::set_patientmiddlename(const char* value, size_t size) {
  set_has_patientmiddlename();
  if (patientmiddlename_ == &::google::protobuf::internal::kEmptyString) {
    patientmiddlename_ = new ::std::string;
  }
  patientmiddlename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientmiddlename() {
  set_has_patientmiddlename();
  if (patientmiddlename_ == &::google::protobuf::internal::kEmptyString) {
    patientmiddlename_ = new ::std::string;
  }
  return patientmiddlename_;
}
inline ::std::string* RtTpsProtoPatient::release_patientmiddlename() {
  clear_has_patientmiddlename();
  if (patientmiddlename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientmiddlename_;
    patientmiddlename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientLastName = 5;
inline bool RtTpsProtoPatient::has_patientlastname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientlastname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtTpsProtoPatient::clear_has_patientlastname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtTpsProtoPatient::clear_patientlastname() {
  if (patientlastname_ != &::google::protobuf::internal::kEmptyString) {
    patientlastname_->clear();
  }
  clear_has_patientlastname();
}
inline const ::std::string& RtTpsProtoPatient::patientlastname() const {
  return *patientlastname_;
}
inline void RtTpsProtoPatient::set_patientlastname(const ::std::string& value) {
  set_has_patientlastname();
  if (patientlastname_ == &::google::protobuf::internal::kEmptyString) {
    patientlastname_ = new ::std::string;
  }
  patientlastname_->assign(value);
}
inline void RtTpsProtoPatient::set_patientlastname(const char* value) {
  set_has_patientlastname();
  if (patientlastname_ == &::google::protobuf::internal::kEmptyString) {
    patientlastname_ = new ::std::string;
  }
  patientlastname_->assign(value);
}
inline void RtTpsProtoPatient::set_patientlastname(const char* value, size_t size) {
  set_has_patientlastname();
  if (patientlastname_ == &::google::protobuf::internal::kEmptyString) {
    patientlastname_ = new ::std::string;
  }
  patientlastname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientlastname() {
  set_has_patientlastname();
  if (patientlastname_ == &::google::protobuf::internal::kEmptyString) {
    patientlastname_ = new ::std::string;
  }
  return patientlastname_;
}
inline ::std::string* RtTpsProtoPatient::release_patientlastname() {
  clear_has_patientlastname();
  if (patientlastname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientlastname_;
    patientlastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientNameSuffix = 6;
inline bool RtTpsProtoPatient::has_patientnamesuffix() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientnamesuffix() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtTpsProtoPatient::clear_has_patientnamesuffix() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtTpsProtoPatient::clear_patientnamesuffix() {
  if (patientnamesuffix_ != &::google::protobuf::internal::kEmptyString) {
    patientnamesuffix_->clear();
  }
  clear_has_patientnamesuffix();
}
inline const ::std::string& RtTpsProtoPatient::patientnamesuffix() const {
  return *patientnamesuffix_;
}
inline void RtTpsProtoPatient::set_patientnamesuffix(const ::std::string& value) {
  set_has_patientnamesuffix();
  if (patientnamesuffix_ == &::google::protobuf::internal::kEmptyString) {
    patientnamesuffix_ = new ::std::string;
  }
  patientnamesuffix_->assign(value);
}
inline void RtTpsProtoPatient::set_patientnamesuffix(const char* value) {
  set_has_patientnamesuffix();
  if (patientnamesuffix_ == &::google::protobuf::internal::kEmptyString) {
    patientnamesuffix_ = new ::std::string;
  }
  patientnamesuffix_->assign(value);
}
inline void RtTpsProtoPatient::set_patientnamesuffix(const char* value, size_t size) {
  set_has_patientnamesuffix();
  if (patientnamesuffix_ == &::google::protobuf::internal::kEmptyString) {
    patientnamesuffix_ = new ::std::string;
  }
  patientnamesuffix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientnamesuffix() {
  set_has_patientnamesuffix();
  if (patientnamesuffix_ == &::google::protobuf::internal::kEmptyString) {
    patientnamesuffix_ = new ::std::string;
  }
  return patientnamesuffix_;
}
inline ::std::string* RtTpsProtoPatient::release_patientnamesuffix() {
  clear_has_patientnamesuffix();
  if (patientnamesuffix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientnamesuffix_;
    patientnamesuffix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientID = 7;
inline bool RtTpsProtoPatient::has_patientid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtTpsProtoPatient::clear_has_patientid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtTpsProtoPatient::clear_patientid() {
  if (patientid_ != &::google::protobuf::internal::kEmptyString) {
    patientid_->clear();
  }
  clear_has_patientid();
}
inline const ::std::string& RtTpsProtoPatient::patientid() const {
  return *patientid_;
}
inline void RtTpsProtoPatient::set_patientid(const ::std::string& value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void RtTpsProtoPatient::set_patientid(const char* value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void RtTpsProtoPatient::set_patientid(const char* value, size_t size) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientid() {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  return patientid_;
}
inline ::std::string* RtTpsProtoPatient::release_patientid() {
  clear_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientid_;
    patientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 patientsex = 8;
inline bool RtTpsProtoPatient::has_patientsex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientsex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RtTpsProtoPatient::clear_has_patientsex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RtTpsProtoPatient::clear_patientsex() {
  patientsex_ = 0;
  clear_has_patientsex();
}
inline ::google::protobuf::int32 RtTpsProtoPatient::patientsex() const {
  return patientsex_;
}
inline void RtTpsProtoPatient::set_patientsex(::google::protobuf::int32 value) {
  set_has_patientsex();
  patientsex_ = value;
}

// optional string patientDateOfBirth = 9;
inline bool RtTpsProtoPatient::has_patientdateofbirth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RtTpsProtoPatient::set_has_patientdateofbirth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RtTpsProtoPatient::clear_has_patientdateofbirth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RtTpsProtoPatient::clear_patientdateofbirth() {
  if (patientdateofbirth_ != &::google::protobuf::internal::kEmptyString) {
    patientdateofbirth_->clear();
  }
  clear_has_patientdateofbirth();
}
inline const ::std::string& RtTpsProtoPatient::patientdateofbirth() const {
  return *patientdateofbirth_;
}
inline void RtTpsProtoPatient::set_patientdateofbirth(const ::std::string& value) {
  set_has_patientdateofbirth();
  if (patientdateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    patientdateofbirth_ = new ::std::string;
  }
  patientdateofbirth_->assign(value);
}
inline void RtTpsProtoPatient::set_patientdateofbirth(const char* value) {
  set_has_patientdateofbirth();
  if (patientdateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    patientdateofbirth_ = new ::std::string;
  }
  patientdateofbirth_->assign(value);
}
inline void RtTpsProtoPatient::set_patientdateofbirth(const char* value, size_t size) {
  set_has_patientdateofbirth();
  if (patientdateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    patientdateofbirth_ = new ::std::string;
  }
  patientdateofbirth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPatient::mutable_patientdateofbirth() {
  set_has_patientdateofbirth();
  if (patientdateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    patientdateofbirth_ = new ::std::string;
  }
  return patientdateofbirth_;
}
inline ::std::string* RtTpsProtoPatient::release_patientdateofbirth() {
  clear_has_patientdateofbirth();
  if (patientdateofbirth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientdateofbirth_;
    patientdateofbirth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isinternal = 10;
inline bool RtTpsProtoPatient::has_isinternal() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtTpsProtoPatient::set_has_isinternal() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtTpsProtoPatient::clear_has_isinternal() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtTpsProtoPatient::clear_isinternal() {
  isinternal_ = false;
  clear_has_isinternal();
}
inline bool RtTpsProtoPatient::isinternal() const {
  return isinternal_;
}
inline void RtTpsProtoPatient::set_isinternal(bool value) {
  set_has_isinternal();
  isinternal_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fproto_5fpatient_2eproto__INCLUDED
