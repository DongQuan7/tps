// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_proto_plan.proto

#ifndef PROTOBUF_rt_5ftps_5fproto_5fplan_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fproto_5fplan_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "rt_tps_proto_normalizationgroup.pb.h"
#include "rt_tps_proto_poi.pb.h"
#include "rt_tps_proto_doselinesetting.pb.h"
#include "rt_tps_proto_doseline.pb.h"
// @@protoc_insertion_point(includes)

namespace tps {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5ftps_5fproto_5fplan_2eproto();
void protobuf_AssignDesc_rt_5ftps_5fproto_5fplan_2eproto();
void protobuf_ShutdownFile_rt_5ftps_5fproto_5fplan_2eproto();

class RtTpsProtoPlan;
class RtTpsProtoRepeatedPlan;

// ===================================================================

class RtTpsProtoPlan : public ::google::protobuf::Message {
 public:
  RtTpsProtoPlan();
  virtual ~RtTpsProtoPlan();
  
  RtTpsProtoPlan(const RtTpsProtoPlan& from);
  
  inline RtTpsProtoPlan& operator=(const RtTpsProtoPlan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoPlan& default_instance();
  
  void Swap(RtTpsProtoPlan* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoPlan& from);
  void MergeFrom(const RtTpsProtoPlan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string planUID = 1;
  inline bool has_planuid() const;
  inline void clear_planuid();
  static const int kPlanUIDFieldNumber = 1;
  inline const ::std::string& planuid() const;
  inline void set_planuid(const ::std::string& value);
  inline void set_planuid(const char* value);
  inline void set_planuid(const char* value, size_t size);
  inline ::std::string* mutable_planuid();
  inline ::std::string* release_planuid();
  
  // optional string planName = 2;
  inline bool has_planname() const;
  inline void clear_planname();
  static const int kPlanNameFieldNumber = 2;
  inline const ::std::string& planname() const;
  inline void set_planname(const ::std::string& value);
  inline void set_planname(const char* value);
  inline void set_planname(const char* value, size_t size);
  inline ::std::string* mutable_planname();
  inline ::std::string* release_planname();
  
  // optional float bodyThickness = 3;
  inline bool has_bodythickness() const;
  inline void clear_bodythickness();
  static const int kBodyThicknessFieldNumber = 3;
  inline float bodythickness() const;
  inline void set_bodythickness(float value);
  
  // optional string phantomUID = 4;
  inline bool has_phantomuid() const;
  inline void clear_phantomuid();
  static const int kPhantomUIDFieldNumber = 4;
  inline const ::std::string& phantomuid() const;
  inline void set_phantomuid(const ::std::string& value);
  inline void set_phantomuid(const char* value);
  inline void set_phantomuid(const char* value, size_t size);
  inline ::std::string* mutable_phantomuid();
  inline ::std::string* release_phantomuid();
  
  // optional string planner = 5;
  inline bool has_planner() const;
  inline void clear_planner();
  static const int kPlannerFieldNumber = 5;
  inline const ::std::string& planner() const;
  inline void set_planner(const ::std::string& value);
  inline void set_planner(const char* value);
  inline void set_planner(const char* value, size_t size);
  inline ::std::string* mutable_planner();
  inline ::std::string* release_planner();
  
  // optional int32 planSourceType = 6;
  inline bool has_plansourcetype() const;
  inline void clear_plansourcetype();
  static const int kPlanSourceTypeFieldNumber = 6;
  inline ::google::protobuf::int32 plansourcetype() const;
  inline void set_plansourcetype(::google::protobuf::int32 value);
  
  // optional string rtImageUID = 7;
  inline bool has_rtimageuid() const;
  inline void clear_rtimageuid();
  static const int kRtImageUIDFieldNumber = 7;
  inline const ::std::string& rtimageuid() const;
  inline void set_rtimageuid(const ::std::string& value);
  inline void set_rtimageuid(const char* value);
  inline void set_rtimageuid(const char* value, size_t size);
  inline ::std::string* mutable_rtimageuid();
  inline ::std::string* release_rtimageuid();
  
  // optional float doseGridSpacingY = 8;
  inline bool has_dosegridspacingy() const;
  inline void clear_dosegridspacingy();
  static const int kDoseGridSpacingYFieldNumber = 8;
  inline float dosegridspacingy() const;
  inline void set_dosegridspacingy(float value);
  
  // optional float doseGridSpacingZ = 9;
  inline bool has_dosegridspacingz() const;
  inline void clear_dosegridspacingz();
  static const int kDoseGridSpacingZFieldNumber = 9;
  inline float dosegridspacingz() const;
  inline void set_dosegridspacingz(float value);
  
  // optional float doseGridStartX = 10;
  inline bool has_dosegridstartx() const;
  inline void clear_dosegridstartx();
  static const int kDoseGridStartXFieldNumber = 10;
  inline float dosegridstartx() const;
  inline void set_dosegridstartx(float value);
  
  // optional float doseGridStartY = 11;
  inline bool has_dosegridstarty() const;
  inline void clear_dosegridstarty();
  static const int kDoseGridStartYFieldNumber = 11;
  inline float dosegridstarty() const;
  inline void set_dosegridstarty(float value);
  
  // optional float doseGridStartZ = 12;
  inline bool has_dosegridstartz() const;
  inline void clear_dosegridstartz();
  static const int kDoseGridStartZFieldNumber = 12;
  inline float dosegridstartz() const;
  inline void set_dosegridstartz(float value);
  
  // optional string courseUID = 13;
  inline bool has_courseuid() const;
  inline void clear_courseuid();
  static const int kCourseUIDFieldNumber = 13;
  inline const ::std::string& courseuid() const;
  inline void set_courseuid(const ::std::string& value);
  inline void set_courseuid(const char* value);
  inline void set_courseuid(const char* value, size_t size);
  inline ::std::string* mutable_courseuid();
  inline ::std::string* release_courseuid();
  
  // optional string seriesUID = 14;
  inline bool has_seriesuid() const;
  inline void clear_seriesuid();
  static const int kSeriesUIDFieldNumber = 14;
  inline const ::std::string& seriesuid() const;
  inline void set_seriesuid(const ::std::string& value);
  inline void set_seriesuid(const char* value);
  inline void set_seriesuid(const char* value, size_t size);
  inline ::std::string* mutable_seriesuid();
  inline ::std::string* release_seriesuid();
  
  // repeated .tps.proto.RtTpsProtoNormalizationGroup normalizationGroupList = 15;
  inline int normalizationgrouplist_size() const;
  inline void clear_normalizationgrouplist();
  static const int kNormalizationGroupListFieldNumber = 15;
  inline const ::tps::proto::RtTpsProtoNormalizationGroup& normalizationgrouplist(int index) const;
  inline ::tps::proto::RtTpsProtoNormalizationGroup* mutable_normalizationgrouplist(int index);
  inline ::tps::proto::RtTpsProtoNormalizationGroup* add_normalizationgrouplist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoNormalizationGroup >&
      normalizationgrouplist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoNormalizationGroup >*
      mutable_normalizationgrouplist();
  
  // repeated .tps.proto.RtTpsProtoPoi poiList = 16;
  inline int poilist_size() const;
  inline void clear_poilist();
  static const int kPoiListFieldNumber = 16;
  inline const ::tps::proto::RtTpsProtoPoi& poilist(int index) const;
  inline ::tps::proto::RtTpsProtoPoi* mutable_poilist(int index);
  inline ::tps::proto::RtTpsProtoPoi* add_poilist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >&
      poilist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >*
      mutable_poilist();
  
  // optional int32 isApproved = 17;
  inline bool has_isapproved() const;
  inline void clear_isapproved();
  static const int kIsApprovedFieldNumber = 17;
  inline ::google::protobuf::int32 isapproved() const;
  inline void set_isapproved(::google::protobuf::int32 value);
  
  // optional float doseGridSpacingX = 18;
  inline bool has_dosegridspacingx() const;
  inline void clear_dosegridspacingx();
  static const int kDoseGridSpacingXFieldNumber = 18;
  inline float dosegridspacingx() const;
  inline void set_dosegridspacingx(float value);
  
  // optional float specifiedDose = 19;
  inline bool has_specifieddose() const;
  inline void clear_specifieddose();
  static const int kSpecifiedDoseFieldNumber = 19;
  inline float specifieddose() const;
  inline void set_specifieddose(float value);
  
  // optional int32 renderMode = 20;
  inline bool has_rendermode() const;
  inline void clear_rendermode();
  static const int kRenderModeFieldNumber = 20;
  inline ::google::protobuf::int32 rendermode() const;
  inline void set_rendermode(::google::protobuf::int32 value);
  
  // optional float transparency = 21;
  inline bool has_transparency() const;
  inline void clear_transparency();
  static const int kTransparencyFieldNumber = 21;
  inline float transparency() const;
  inline void set_transparency(float value);
  
  // optional float transparency3D = 22;
  inline bool has_transparency3d() const;
  inline void clear_transparency3d();
  static const int kTransparency3DFieldNumber = 22;
  inline float transparency3d() const;
  inline void set_transparency3d(float value);
  
  // optional bool enableSkinDoseView = 23;
  inline bool has_enableskindoseview() const;
  inline void clear_enableskindoseview();
  static const int kEnableSkinDoseViewFieldNumber = 23;
  inline bool enableskindoseview() const;
  inline void set_enableskindoseview(bool value);
  
  // optional float maxSkinDose = 24;
  inline bool has_maxskindose() const;
  inline void clear_maxskindose();
  static const int kMaxSkinDoseFieldNumber = 24;
  inline float maxskindose() const;
  inline void set_maxskindose(float value);
  
  // optional int32 displayMode = 25;
  inline bool has_displaymode() const;
  inline void clear_displaymode();
  static const int kDisplayModeFieldNumber = 25;
  inline ::google::protobuf::int32 displaymode() const;
  inline void set_displaymode(::google::protobuf::int32 value);
  
  // optional int32 hundredPercentDefinition = 26;
  inline bool has_hundredpercentdefinition() const;
  inline void clear_hundredpercentdefinition();
  static const int kHundredPercentDefinitionFieldNumber = 26;
  inline ::google::protobuf::int32 hundredpercentdefinition() const;
  inline void set_hundredpercentdefinition(::google::protobuf::int32 value);
  
  // optional float doseGridSizeZ = 27;
  inline bool has_dosegridsizez() const;
  inline void clear_dosegridsizez();
  static const int kDoseGridSizeZFieldNumber = 27;
  inline float dosegridsizez() const;
  inline void set_dosegridsizez(float value);
  
  // optional float maxDose = 28;
  inline bool has_maxdose() const;
  inline void clear_maxdose();
  static const int kMaxDoseFieldNumber = 28;
  inline float maxdose() const;
  inline void set_maxdose(float value);
  
  // optional bool isIgnoreUpdateMaxDose = 29;
  inline bool has_isignoreupdatemaxdose() const;
  inline void clear_isignoreupdatemaxdose();
  static const int kIsIgnoreUpdateMaxDoseFieldNumber = 29;
  inline bool isignoreupdatemaxdose() const;
  inline void set_isignoreupdatemaxdose(bool value);
  
  // repeated .tps.proto.RtTpsProtoDoseLine doseLineList = 30;
  inline int doselinelist_size() const;
  inline void clear_doselinelist();
  static const int kDoseLineListFieldNumber = 30;
  inline const ::tps::proto::RtTpsProtoDoseLine& doselinelist(int index) const;
  inline ::tps::proto::RtTpsProtoDoseLine* mutable_doselinelist(int index);
  inline ::tps::proto::RtTpsProtoDoseLine* add_doselinelist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoDoseLine >&
      doselinelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoDoseLine >*
      mutable_doselinelist();
  
  // optional float doseGridSizeX = 31;
  inline bool has_dosegridsizex() const;
  inline void clear_dosegridsizex();
  static const int kDoseGridSizeXFieldNumber = 31;
  inline float dosegridsizex() const;
  inline void set_dosegridsizex(float value);
  
  // optional float doseGridSizeY = 32;
  inline bool has_dosegridsizey() const;
  inline void clear_dosegridsizey();
  static const int kDoseGridSizeYFieldNumber = 32;
  inline float dosegridsizey() const;
  inline void set_dosegridsizey(float value);
  
  // optional bool isDoseValid = 33;
  inline bool has_isdosevalid() const;
  inline void clear_isdosevalid();
  static const int kIsDoseValidFieldNumber = 33;
  inline bool isdosevalid() const;
  inline void set_isdosevalid(bool value);
  
  // optional string patientPosition = 34;
  inline bool has_patientposition() const;
  inline void clear_patientposition();
  static const int kPatientPositionFieldNumber = 34;
  inline const ::std::string& patientposition() const;
  inline void set_patientposition(const ::std::string& value);
  inline void set_patientposition(const char* value);
  inline void set_patientposition(const char* value, size_t size);
  inline ::std::string* mutable_patientposition();
  inline ::std::string* release_patientposition();
  
  // optional string planDescription = 35;
  inline bool has_plandescription() const;
  inline void clear_plandescription();
  static const int kPlanDescriptionFieldNumber = 35;
  inline const ::std::string& plandescription() const;
  inline void set_plandescription(const ::std::string& value);
  inline void set_plandescription(const char* value);
  inline void set_plandescription(const char* value, size_t size);
  inline ::std::string* mutable_plandescription();
  inline ::std::string* release_plandescription();
  
  // optional string setupPoiUid = 36;
  inline bool has_setuppoiuid() const;
  inline void clear_setuppoiuid();
  static const int kSetupPoiUidFieldNumber = 36;
  inline const ::std::string& setuppoiuid() const;
  inline void set_setuppoiuid(const ::std::string& value);
  inline void set_setuppoiuid(const char* value);
  inline void set_setuppoiuid(const char* value, size_t size);
  inline ::std::string* mutable_setuppoiuid();
  inline ::std::string* release_setuppoiuid();
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoPlan)
 private:
  inline void set_has_planuid();
  inline void clear_has_planuid();
  inline void set_has_planname();
  inline void clear_has_planname();
  inline void set_has_bodythickness();
  inline void clear_has_bodythickness();
  inline void set_has_phantomuid();
  inline void clear_has_phantomuid();
  inline void set_has_planner();
  inline void clear_has_planner();
  inline void set_has_plansourcetype();
  inline void clear_has_plansourcetype();
  inline void set_has_rtimageuid();
  inline void clear_has_rtimageuid();
  inline void set_has_dosegridspacingy();
  inline void clear_has_dosegridspacingy();
  inline void set_has_dosegridspacingz();
  inline void clear_has_dosegridspacingz();
  inline void set_has_dosegridstartx();
  inline void clear_has_dosegridstartx();
  inline void set_has_dosegridstarty();
  inline void clear_has_dosegridstarty();
  inline void set_has_dosegridstartz();
  inline void clear_has_dosegridstartz();
  inline void set_has_courseuid();
  inline void clear_has_courseuid();
  inline void set_has_seriesuid();
  inline void clear_has_seriesuid();
  inline void set_has_isapproved();
  inline void clear_has_isapproved();
  inline void set_has_dosegridspacingx();
  inline void clear_has_dosegridspacingx();
  inline void set_has_specifieddose();
  inline void clear_has_specifieddose();
  inline void set_has_rendermode();
  inline void clear_has_rendermode();
  inline void set_has_transparency();
  inline void clear_has_transparency();
  inline void set_has_transparency3d();
  inline void clear_has_transparency3d();
  inline void set_has_enableskindoseview();
  inline void clear_has_enableskindoseview();
  inline void set_has_maxskindose();
  inline void clear_has_maxskindose();
  inline void set_has_displaymode();
  inline void clear_has_displaymode();
  inline void set_has_hundredpercentdefinition();
  inline void clear_has_hundredpercentdefinition();
  inline void set_has_dosegridsizez();
  inline void clear_has_dosegridsizez();
  inline void set_has_maxdose();
  inline void clear_has_maxdose();
  inline void set_has_isignoreupdatemaxdose();
  inline void clear_has_isignoreupdatemaxdose();
  inline void set_has_dosegridsizex();
  inline void clear_has_dosegridsizex();
  inline void set_has_dosegridsizey();
  inline void clear_has_dosegridsizey();
  inline void set_has_isdosevalid();
  inline void clear_has_isdosevalid();
  inline void set_has_patientposition();
  inline void clear_has_patientposition();
  inline void set_has_plandescription();
  inline void clear_has_plandescription();
  inline void set_has_setuppoiuid();
  inline void clear_has_setuppoiuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* planuid_;
  ::std::string* planname_;
  ::std::string* phantomuid_;
  float bodythickness_;
  ::google::protobuf::int32 plansourcetype_;
  ::std::string* planner_;
  ::std::string* rtimageuid_;
  float dosegridspacingy_;
  float dosegridspacingz_;
  float dosegridstartx_;
  float dosegridstarty_;
  ::std::string* courseuid_;
  ::std::string* seriesuid_;
  float dosegridstartz_;
  ::google::protobuf::int32 isapproved_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoNormalizationGroup > normalizationgrouplist_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi > poilist_;
  float dosegridspacingx_;
  float specifieddose_;
  ::google::protobuf::int32 rendermode_;
  float transparency_;
  float transparency3d_;
  float maxskindose_;
  ::google::protobuf::int32 displaymode_;
  ::google::protobuf::int32 hundredpercentdefinition_;
  float dosegridsizez_;
  float maxdose_;
  bool enableskindoseview_;
  bool isignoreupdatemaxdose_;
  bool isdosevalid_;
  float dosegridsizex_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoDoseLine > doselinelist_;
  ::std::string* patientposition_;
  ::std::string* plandescription_;
  ::std::string* setuppoiuid_;
  float dosegridsizey_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fplan_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fplan_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fplan_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoPlan* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoRepeatedPlan : public ::google::protobuf::Message {
 public:
  RtTpsProtoRepeatedPlan();
  virtual ~RtTpsProtoRepeatedPlan();
  
  RtTpsProtoRepeatedPlan(const RtTpsProtoRepeatedPlan& from);
  
  inline RtTpsProtoRepeatedPlan& operator=(const RtTpsProtoRepeatedPlan& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoRepeatedPlan& default_instance();
  
  void Swap(RtTpsProtoRepeatedPlan* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoRepeatedPlan* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoRepeatedPlan& from);
  void MergeFrom(const RtTpsProtoRepeatedPlan& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tps.proto.RtTpsProtoPlan planList = 1;
  inline int planlist_size() const;
  inline void clear_planlist();
  static const int kPlanListFieldNumber = 1;
  inline const ::tps::proto::RtTpsProtoPlan& planlist(int index) const;
  inline ::tps::proto::RtTpsProtoPlan* mutable_planlist(int index);
  inline ::tps::proto::RtTpsProtoPlan* add_planlist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPlan >&
      planlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPlan >*
      mutable_planlist();
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoRepeatedPlan)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPlan > planlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fplan_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fplan_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fplan_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoRepeatedPlan* default_instance_;
};
// ===================================================================


// ===================================================================

// RtTpsProtoPlan

// required string planUID = 1;
inline bool RtTpsProtoPlan::has_planuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoPlan::set_has_planuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoPlan::clear_has_planuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoPlan::clear_planuid() {
  if (planuid_ != &::google::protobuf::internal::kEmptyString) {
    planuid_->clear();
  }
  clear_has_planuid();
}
inline const ::std::string& RtTpsProtoPlan::planuid() const {
  return *planuid_;
}
inline void RtTpsProtoPlan::set_planuid(const ::std::string& value) {
  set_has_planuid();
  if (planuid_ == &::google::protobuf::internal::kEmptyString) {
    planuid_ = new ::std::string;
  }
  planuid_->assign(value);
}
inline void RtTpsProtoPlan::set_planuid(const char* value) {
  set_has_planuid();
  if (planuid_ == &::google::protobuf::internal::kEmptyString) {
    planuid_ = new ::std::string;
  }
  planuid_->assign(value);
}
inline void RtTpsProtoPlan::set_planuid(const char* value, size_t size) {
  set_has_planuid();
  if (planuid_ == &::google::protobuf::internal::kEmptyString) {
    planuid_ = new ::std::string;
  }
  planuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_planuid() {
  set_has_planuid();
  if (planuid_ == &::google::protobuf::internal::kEmptyString) {
    planuid_ = new ::std::string;
  }
  return planuid_;
}
inline ::std::string* RtTpsProtoPlan::release_planuid() {
  clear_has_planuid();
  if (planuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = planuid_;
    planuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string planName = 2;
inline bool RtTpsProtoPlan::has_planname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoPlan::set_has_planname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoPlan::clear_has_planname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoPlan::clear_planname() {
  if (planname_ != &::google::protobuf::internal::kEmptyString) {
    planname_->clear();
  }
  clear_has_planname();
}
inline const ::std::string& RtTpsProtoPlan::planname() const {
  return *planname_;
}
inline void RtTpsProtoPlan::set_planname(const ::std::string& value) {
  set_has_planname();
  if (planname_ == &::google::protobuf::internal::kEmptyString) {
    planname_ = new ::std::string;
  }
  planname_->assign(value);
}
inline void RtTpsProtoPlan::set_planname(const char* value) {
  set_has_planname();
  if (planname_ == &::google::protobuf::internal::kEmptyString) {
    planname_ = new ::std::string;
  }
  planname_->assign(value);
}
inline void RtTpsProtoPlan::set_planname(const char* value, size_t size) {
  set_has_planname();
  if (planname_ == &::google::protobuf::internal::kEmptyString) {
    planname_ = new ::std::string;
  }
  planname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_planname() {
  set_has_planname();
  if (planname_ == &::google::protobuf::internal::kEmptyString) {
    planname_ = new ::std::string;
  }
  return planname_;
}
inline ::std::string* RtTpsProtoPlan::release_planname() {
  clear_has_planname();
  if (planname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = planname_;
    planname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float bodyThickness = 3;
inline bool RtTpsProtoPlan::has_bodythickness() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoPlan::set_has_bodythickness() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoPlan::clear_has_bodythickness() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoPlan::clear_bodythickness() {
  bodythickness_ = 0;
  clear_has_bodythickness();
}
inline float RtTpsProtoPlan::bodythickness() const {
  return bodythickness_;
}
inline void RtTpsProtoPlan::set_bodythickness(float value) {
  set_has_bodythickness();
  bodythickness_ = value;
}

// optional string phantomUID = 4;
inline bool RtTpsProtoPlan::has_phantomuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoPlan::set_has_phantomuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoPlan::clear_has_phantomuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoPlan::clear_phantomuid() {
  if (phantomuid_ != &::google::protobuf::internal::kEmptyString) {
    phantomuid_->clear();
  }
  clear_has_phantomuid();
}
inline const ::std::string& RtTpsProtoPlan::phantomuid() const {
  return *phantomuid_;
}
inline void RtTpsProtoPlan::set_phantomuid(const ::std::string& value) {
  set_has_phantomuid();
  if (phantomuid_ == &::google::protobuf::internal::kEmptyString) {
    phantomuid_ = new ::std::string;
  }
  phantomuid_->assign(value);
}
inline void RtTpsProtoPlan::set_phantomuid(const char* value) {
  set_has_phantomuid();
  if (phantomuid_ == &::google::protobuf::internal::kEmptyString) {
    phantomuid_ = new ::std::string;
  }
  phantomuid_->assign(value);
}
inline void RtTpsProtoPlan::set_phantomuid(const char* value, size_t size) {
  set_has_phantomuid();
  if (phantomuid_ == &::google::protobuf::internal::kEmptyString) {
    phantomuid_ = new ::std::string;
  }
  phantomuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_phantomuid() {
  set_has_phantomuid();
  if (phantomuid_ == &::google::protobuf::internal::kEmptyString) {
    phantomuid_ = new ::std::string;
  }
  return phantomuid_;
}
inline ::std::string* RtTpsProtoPlan::release_phantomuid() {
  clear_has_phantomuid();
  if (phantomuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phantomuid_;
    phantomuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string planner = 5;
inline bool RtTpsProtoPlan::has_planner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtTpsProtoPlan::set_has_planner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtTpsProtoPlan::clear_has_planner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtTpsProtoPlan::clear_planner() {
  if (planner_ != &::google::protobuf::internal::kEmptyString) {
    planner_->clear();
  }
  clear_has_planner();
}
inline const ::std::string& RtTpsProtoPlan::planner() const {
  return *planner_;
}
inline void RtTpsProtoPlan::set_planner(const ::std::string& value) {
  set_has_planner();
  if (planner_ == &::google::protobuf::internal::kEmptyString) {
    planner_ = new ::std::string;
  }
  planner_->assign(value);
}
inline void RtTpsProtoPlan::set_planner(const char* value) {
  set_has_planner();
  if (planner_ == &::google::protobuf::internal::kEmptyString) {
    planner_ = new ::std::string;
  }
  planner_->assign(value);
}
inline void RtTpsProtoPlan::set_planner(const char* value, size_t size) {
  set_has_planner();
  if (planner_ == &::google::protobuf::internal::kEmptyString) {
    planner_ = new ::std::string;
  }
  planner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_planner() {
  set_has_planner();
  if (planner_ == &::google::protobuf::internal::kEmptyString) {
    planner_ = new ::std::string;
  }
  return planner_;
}
inline ::std::string* RtTpsProtoPlan::release_planner() {
  clear_has_planner();
  if (planner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = planner_;
    planner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 planSourceType = 6;
inline bool RtTpsProtoPlan::has_plansourcetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtTpsProtoPlan::set_has_plansourcetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtTpsProtoPlan::clear_has_plansourcetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtTpsProtoPlan::clear_plansourcetype() {
  plansourcetype_ = 0;
  clear_has_plansourcetype();
}
inline ::google::protobuf::int32 RtTpsProtoPlan::plansourcetype() const {
  return plansourcetype_;
}
inline void RtTpsProtoPlan::set_plansourcetype(::google::protobuf::int32 value) {
  set_has_plansourcetype();
  plansourcetype_ = value;
}

// optional string rtImageUID = 7;
inline bool RtTpsProtoPlan::has_rtimageuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtTpsProtoPlan::set_has_rtimageuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtTpsProtoPlan::clear_has_rtimageuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtTpsProtoPlan::clear_rtimageuid() {
  if (rtimageuid_ != &::google::protobuf::internal::kEmptyString) {
    rtimageuid_->clear();
  }
  clear_has_rtimageuid();
}
inline const ::std::string& RtTpsProtoPlan::rtimageuid() const {
  return *rtimageuid_;
}
inline void RtTpsProtoPlan::set_rtimageuid(const ::std::string& value) {
  set_has_rtimageuid();
  if (rtimageuid_ == &::google::protobuf::internal::kEmptyString) {
    rtimageuid_ = new ::std::string;
  }
  rtimageuid_->assign(value);
}
inline void RtTpsProtoPlan::set_rtimageuid(const char* value) {
  set_has_rtimageuid();
  if (rtimageuid_ == &::google::protobuf::internal::kEmptyString) {
    rtimageuid_ = new ::std::string;
  }
  rtimageuid_->assign(value);
}
inline void RtTpsProtoPlan::set_rtimageuid(const char* value, size_t size) {
  set_has_rtimageuid();
  if (rtimageuid_ == &::google::protobuf::internal::kEmptyString) {
    rtimageuid_ = new ::std::string;
  }
  rtimageuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_rtimageuid() {
  set_has_rtimageuid();
  if (rtimageuid_ == &::google::protobuf::internal::kEmptyString) {
    rtimageuid_ = new ::std::string;
  }
  return rtimageuid_;
}
inline ::std::string* RtTpsProtoPlan::release_rtimageuid() {
  clear_has_rtimageuid();
  if (rtimageuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rtimageuid_;
    rtimageuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float doseGridSpacingY = 8;
inline bool RtTpsProtoPlan::has_dosegridspacingy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridspacingy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RtTpsProtoPlan::clear_has_dosegridspacingy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RtTpsProtoPlan::clear_dosegridspacingy() {
  dosegridspacingy_ = 0;
  clear_has_dosegridspacingy();
}
inline float RtTpsProtoPlan::dosegridspacingy() const {
  return dosegridspacingy_;
}
inline void RtTpsProtoPlan::set_dosegridspacingy(float value) {
  set_has_dosegridspacingy();
  dosegridspacingy_ = value;
}

// optional float doseGridSpacingZ = 9;
inline bool RtTpsProtoPlan::has_dosegridspacingz() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridspacingz() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RtTpsProtoPlan::clear_has_dosegridspacingz() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RtTpsProtoPlan::clear_dosegridspacingz() {
  dosegridspacingz_ = 0;
  clear_has_dosegridspacingz();
}
inline float RtTpsProtoPlan::dosegridspacingz() const {
  return dosegridspacingz_;
}
inline void RtTpsProtoPlan::set_dosegridspacingz(float value) {
  set_has_dosegridspacingz();
  dosegridspacingz_ = value;
}

// optional float doseGridStartX = 10;
inline bool RtTpsProtoPlan::has_dosegridstartx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridstartx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtTpsProtoPlan::clear_has_dosegridstartx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtTpsProtoPlan::clear_dosegridstartx() {
  dosegridstartx_ = 0;
  clear_has_dosegridstartx();
}
inline float RtTpsProtoPlan::dosegridstartx() const {
  return dosegridstartx_;
}
inline void RtTpsProtoPlan::set_dosegridstartx(float value) {
  set_has_dosegridstartx();
  dosegridstartx_ = value;
}

// optional float doseGridStartY = 11;
inline bool RtTpsProtoPlan::has_dosegridstarty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridstarty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RtTpsProtoPlan::clear_has_dosegridstarty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RtTpsProtoPlan::clear_dosegridstarty() {
  dosegridstarty_ = 0;
  clear_has_dosegridstarty();
}
inline float RtTpsProtoPlan::dosegridstarty() const {
  return dosegridstarty_;
}
inline void RtTpsProtoPlan::set_dosegridstarty(float value) {
  set_has_dosegridstarty();
  dosegridstarty_ = value;
}

// optional float doseGridStartZ = 12;
inline bool RtTpsProtoPlan::has_dosegridstartz() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridstartz() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RtTpsProtoPlan::clear_has_dosegridstartz() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RtTpsProtoPlan::clear_dosegridstartz() {
  dosegridstartz_ = 0;
  clear_has_dosegridstartz();
}
inline float RtTpsProtoPlan::dosegridstartz() const {
  return dosegridstartz_;
}
inline void RtTpsProtoPlan::set_dosegridstartz(float value) {
  set_has_dosegridstartz();
  dosegridstartz_ = value;
}

// optional string courseUID = 13;
inline bool RtTpsProtoPlan::has_courseuid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RtTpsProtoPlan::set_has_courseuid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RtTpsProtoPlan::clear_has_courseuid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RtTpsProtoPlan::clear_courseuid() {
  if (courseuid_ != &::google::protobuf::internal::kEmptyString) {
    courseuid_->clear();
  }
  clear_has_courseuid();
}
inline const ::std::string& RtTpsProtoPlan::courseuid() const {
  return *courseuid_;
}
inline void RtTpsProtoPlan::set_courseuid(const ::std::string& value) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(value);
}
inline void RtTpsProtoPlan::set_courseuid(const char* value) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(value);
}
inline void RtTpsProtoPlan::set_courseuid(const char* value, size_t size) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_courseuid() {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  return courseuid_;
}
inline ::std::string* RtTpsProtoPlan::release_courseuid() {
  clear_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseuid_;
    courseuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string seriesUID = 14;
inline bool RtTpsProtoPlan::has_seriesuid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RtTpsProtoPlan::set_has_seriesuid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RtTpsProtoPlan::clear_has_seriesuid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RtTpsProtoPlan::clear_seriesuid() {
  if (seriesuid_ != &::google::protobuf::internal::kEmptyString) {
    seriesuid_->clear();
  }
  clear_has_seriesuid();
}
inline const ::std::string& RtTpsProtoPlan::seriesuid() const {
  return *seriesuid_;
}
inline void RtTpsProtoPlan::set_seriesuid(const ::std::string& value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void RtTpsProtoPlan::set_seriesuid(const char* value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void RtTpsProtoPlan::set_seriesuid(const char* value, size_t size) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_seriesuid() {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  return seriesuid_;
}
inline ::std::string* RtTpsProtoPlan::release_seriesuid() {
  clear_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesuid_;
    seriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .tps.proto.RtTpsProtoNormalizationGroup normalizationGroupList = 15;
inline int RtTpsProtoPlan::normalizationgrouplist_size() const {
  return normalizationgrouplist_.size();
}
inline void RtTpsProtoPlan::clear_normalizationgrouplist() {
  normalizationgrouplist_.Clear();
}
inline const ::tps::proto::RtTpsProtoNormalizationGroup& RtTpsProtoPlan::normalizationgrouplist(int index) const {
  return normalizationgrouplist_.Get(index);
}
inline ::tps::proto::RtTpsProtoNormalizationGroup* RtTpsProtoPlan::mutable_normalizationgrouplist(int index) {
  return normalizationgrouplist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoNormalizationGroup* RtTpsProtoPlan::add_normalizationgrouplist() {
  return normalizationgrouplist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoNormalizationGroup >&
RtTpsProtoPlan::normalizationgrouplist() const {
  return normalizationgrouplist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoNormalizationGroup >*
RtTpsProtoPlan::mutable_normalizationgrouplist() {
  return &normalizationgrouplist_;
}

// repeated .tps.proto.RtTpsProtoPoi poiList = 16;
inline int RtTpsProtoPlan::poilist_size() const {
  return poilist_.size();
}
inline void RtTpsProtoPlan::clear_poilist() {
  poilist_.Clear();
}
inline const ::tps::proto::RtTpsProtoPoi& RtTpsProtoPlan::poilist(int index) const {
  return poilist_.Get(index);
}
inline ::tps::proto::RtTpsProtoPoi* RtTpsProtoPlan::mutable_poilist(int index) {
  return poilist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoPoi* RtTpsProtoPlan::add_poilist() {
  return poilist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >&
RtTpsProtoPlan::poilist() const {
  return poilist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >*
RtTpsProtoPlan::mutable_poilist() {
  return &poilist_;
}

// optional int32 isApproved = 17;
inline bool RtTpsProtoPlan::has_isapproved() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RtTpsProtoPlan::set_has_isapproved() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RtTpsProtoPlan::clear_has_isapproved() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RtTpsProtoPlan::clear_isapproved() {
  isapproved_ = 0;
  clear_has_isapproved();
}
inline ::google::protobuf::int32 RtTpsProtoPlan::isapproved() const {
  return isapproved_;
}
inline void RtTpsProtoPlan::set_isapproved(::google::protobuf::int32 value) {
  set_has_isapproved();
  isapproved_ = value;
}

// optional float doseGridSpacingX = 18;
inline bool RtTpsProtoPlan::has_dosegridspacingx() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridspacingx() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RtTpsProtoPlan::clear_has_dosegridspacingx() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RtTpsProtoPlan::clear_dosegridspacingx() {
  dosegridspacingx_ = 0;
  clear_has_dosegridspacingx();
}
inline float RtTpsProtoPlan::dosegridspacingx() const {
  return dosegridspacingx_;
}
inline void RtTpsProtoPlan::set_dosegridspacingx(float value) {
  set_has_dosegridspacingx();
  dosegridspacingx_ = value;
}

// optional float specifiedDose = 19;
inline bool RtTpsProtoPlan::has_specifieddose() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RtTpsProtoPlan::set_has_specifieddose() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RtTpsProtoPlan::clear_has_specifieddose() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RtTpsProtoPlan::clear_specifieddose() {
  specifieddose_ = 0;
  clear_has_specifieddose();
}
inline float RtTpsProtoPlan::specifieddose() const {
  return specifieddose_;
}
inline void RtTpsProtoPlan::set_specifieddose(float value) {
  set_has_specifieddose();
  specifieddose_ = value;
}

// optional int32 renderMode = 20;
inline bool RtTpsProtoPlan::has_rendermode() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RtTpsProtoPlan::set_has_rendermode() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RtTpsProtoPlan::clear_has_rendermode() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RtTpsProtoPlan::clear_rendermode() {
  rendermode_ = 0;
  clear_has_rendermode();
}
inline ::google::protobuf::int32 RtTpsProtoPlan::rendermode() const {
  return rendermode_;
}
inline void RtTpsProtoPlan::set_rendermode(::google::protobuf::int32 value) {
  set_has_rendermode();
  rendermode_ = value;
}

// optional float transparency = 21;
inline bool RtTpsProtoPlan::has_transparency() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RtTpsProtoPlan::set_has_transparency() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RtTpsProtoPlan::clear_has_transparency() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RtTpsProtoPlan::clear_transparency() {
  transparency_ = 0;
  clear_has_transparency();
}
inline float RtTpsProtoPlan::transparency() const {
  return transparency_;
}
inline void RtTpsProtoPlan::set_transparency(float value) {
  set_has_transparency();
  transparency_ = value;
}

// optional float transparency3D = 22;
inline bool RtTpsProtoPlan::has_transparency3d() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RtTpsProtoPlan::set_has_transparency3d() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RtTpsProtoPlan::clear_has_transparency3d() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RtTpsProtoPlan::clear_transparency3d() {
  transparency3d_ = 0;
  clear_has_transparency3d();
}
inline float RtTpsProtoPlan::transparency3d() const {
  return transparency3d_;
}
inline void RtTpsProtoPlan::set_transparency3d(float value) {
  set_has_transparency3d();
  transparency3d_ = value;
}

// optional bool enableSkinDoseView = 23;
inline bool RtTpsProtoPlan::has_enableskindoseview() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RtTpsProtoPlan::set_has_enableskindoseview() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RtTpsProtoPlan::clear_has_enableskindoseview() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RtTpsProtoPlan::clear_enableskindoseview() {
  enableskindoseview_ = false;
  clear_has_enableskindoseview();
}
inline bool RtTpsProtoPlan::enableskindoseview() const {
  return enableskindoseview_;
}
inline void RtTpsProtoPlan::set_enableskindoseview(bool value) {
  set_has_enableskindoseview();
  enableskindoseview_ = value;
}

// optional float maxSkinDose = 24;
inline bool RtTpsProtoPlan::has_maxskindose() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RtTpsProtoPlan::set_has_maxskindose() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RtTpsProtoPlan::clear_has_maxskindose() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RtTpsProtoPlan::clear_maxskindose() {
  maxskindose_ = 0;
  clear_has_maxskindose();
}
inline float RtTpsProtoPlan::maxskindose() const {
  return maxskindose_;
}
inline void RtTpsProtoPlan::set_maxskindose(float value) {
  set_has_maxskindose();
  maxskindose_ = value;
}

// optional int32 displayMode = 25;
inline bool RtTpsProtoPlan::has_displaymode() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_displaymode() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RtTpsProtoPlan::clear_has_displaymode() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RtTpsProtoPlan::clear_displaymode() {
  displaymode_ = 0;
  clear_has_displaymode();
}
inline ::google::protobuf::int32 RtTpsProtoPlan::displaymode() const {
  return displaymode_;
}
inline void RtTpsProtoPlan::set_displaymode(::google::protobuf::int32 value) {
  set_has_displaymode();
  displaymode_ = value;
}

// optional int32 hundredPercentDefinition = 26;
inline bool RtTpsProtoPlan::has_hundredpercentdefinition() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_hundredpercentdefinition() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RtTpsProtoPlan::clear_has_hundredpercentdefinition() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RtTpsProtoPlan::clear_hundredpercentdefinition() {
  hundredpercentdefinition_ = 0;
  clear_has_hundredpercentdefinition();
}
inline ::google::protobuf::int32 RtTpsProtoPlan::hundredpercentdefinition() const {
  return hundredpercentdefinition_;
}
inline void RtTpsProtoPlan::set_hundredpercentdefinition(::google::protobuf::int32 value) {
  set_has_hundredpercentdefinition();
  hundredpercentdefinition_ = value;
}

// optional float doseGridSizeZ = 27;
inline bool RtTpsProtoPlan::has_dosegridsizez() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridsizez() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RtTpsProtoPlan::clear_has_dosegridsizez() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RtTpsProtoPlan::clear_dosegridsizez() {
  dosegridsizez_ = 0;
  clear_has_dosegridsizez();
}
inline float RtTpsProtoPlan::dosegridsizez() const {
  return dosegridsizez_;
}
inline void RtTpsProtoPlan::set_dosegridsizez(float value) {
  set_has_dosegridsizez();
  dosegridsizez_ = value;
}

// optional float maxDose = 28;
inline bool RtTpsProtoPlan::has_maxdose() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_maxdose() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RtTpsProtoPlan::clear_has_maxdose() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RtTpsProtoPlan::clear_maxdose() {
  maxdose_ = 0;
  clear_has_maxdose();
}
inline float RtTpsProtoPlan::maxdose() const {
  return maxdose_;
}
inline void RtTpsProtoPlan::set_maxdose(float value) {
  set_has_maxdose();
  maxdose_ = value;
}

// optional bool isIgnoreUpdateMaxDose = 29;
inline bool RtTpsProtoPlan::has_isignoreupdatemaxdose() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_isignoreupdatemaxdose() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RtTpsProtoPlan::clear_has_isignoreupdatemaxdose() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RtTpsProtoPlan::clear_isignoreupdatemaxdose() {
  isignoreupdatemaxdose_ = false;
  clear_has_isignoreupdatemaxdose();
}
inline bool RtTpsProtoPlan::isignoreupdatemaxdose() const {
  return isignoreupdatemaxdose_;
}
inline void RtTpsProtoPlan::set_isignoreupdatemaxdose(bool value) {
  set_has_isignoreupdatemaxdose();
  isignoreupdatemaxdose_ = value;
}

// repeated .tps.proto.RtTpsProtoDoseLine doseLineList = 30;
inline int RtTpsProtoPlan::doselinelist_size() const {
  return doselinelist_.size();
}
inline void RtTpsProtoPlan::clear_doselinelist() {
  doselinelist_.Clear();
}
inline const ::tps::proto::RtTpsProtoDoseLine& RtTpsProtoPlan::doselinelist(int index) const {
  return doselinelist_.Get(index);
}
inline ::tps::proto::RtTpsProtoDoseLine* RtTpsProtoPlan::mutable_doselinelist(int index) {
  return doselinelist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoDoseLine* RtTpsProtoPlan::add_doselinelist() {
  return doselinelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoDoseLine >&
RtTpsProtoPlan::doselinelist() const {
  return doselinelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoDoseLine >*
RtTpsProtoPlan::mutable_doselinelist() {
  return &doselinelist_;
}

// optional float doseGridSizeX = 31;
inline bool RtTpsProtoPlan::has_dosegridsizex() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridsizex() {
  _has_bits_[0] |= 0x40000000u;
}
inline void RtTpsProtoPlan::clear_has_dosegridsizex() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void RtTpsProtoPlan::clear_dosegridsizex() {
  dosegridsizex_ = 0;
  clear_has_dosegridsizex();
}
inline float RtTpsProtoPlan::dosegridsizex() const {
  return dosegridsizex_;
}
inline void RtTpsProtoPlan::set_dosegridsizex(float value) {
  set_has_dosegridsizex();
  dosegridsizex_ = value;
}

// optional float doseGridSizeY = 32;
inline bool RtTpsProtoPlan::has_dosegridsizey() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void RtTpsProtoPlan::set_has_dosegridsizey() {
  _has_bits_[0] |= 0x80000000u;
}
inline void RtTpsProtoPlan::clear_has_dosegridsizey() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void RtTpsProtoPlan::clear_dosegridsizey() {
  dosegridsizey_ = 0;
  clear_has_dosegridsizey();
}
inline float RtTpsProtoPlan::dosegridsizey() const {
  return dosegridsizey_;
}
inline void RtTpsProtoPlan::set_dosegridsizey(float value) {
  set_has_dosegridsizey();
  dosegridsizey_ = value;
}

// optional bool isDoseValid = 33;
inline bool RtTpsProtoPlan::has_isdosevalid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RtTpsProtoPlan::set_has_isdosevalid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RtTpsProtoPlan::clear_has_isdosevalid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RtTpsProtoPlan::clear_isdosevalid() {
  isdosevalid_ = false;
  clear_has_isdosevalid();
}
inline bool RtTpsProtoPlan::isdosevalid() const {
  return isdosevalid_;
}
inline void RtTpsProtoPlan::set_isdosevalid(bool value) {
  set_has_isdosevalid();
  isdosevalid_ = value;
}

// optional string patientPosition = 34;
inline bool RtTpsProtoPlan::has_patientposition() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RtTpsProtoPlan::set_has_patientposition() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RtTpsProtoPlan::clear_has_patientposition() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RtTpsProtoPlan::clear_patientposition() {
  if (patientposition_ != &::google::protobuf::internal::kEmptyString) {
    patientposition_->clear();
  }
  clear_has_patientposition();
}
inline const ::std::string& RtTpsProtoPlan::patientposition() const {
  return *patientposition_;
}
inline void RtTpsProtoPlan::set_patientposition(const ::std::string& value) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(value);
}
inline void RtTpsProtoPlan::set_patientposition(const char* value) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(value);
}
inline void RtTpsProtoPlan::set_patientposition(const char* value, size_t size) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_patientposition() {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  return patientposition_;
}
inline ::std::string* RtTpsProtoPlan::release_patientposition() {
  clear_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientposition_;
    patientposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string planDescription = 35;
inline bool RtTpsProtoPlan::has_plandescription() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RtTpsProtoPlan::set_has_plandescription() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RtTpsProtoPlan::clear_has_plandescription() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RtTpsProtoPlan::clear_plandescription() {
  if (plandescription_ != &::google::protobuf::internal::kEmptyString) {
    plandescription_->clear();
  }
  clear_has_plandescription();
}
inline const ::std::string& RtTpsProtoPlan::plandescription() const {
  return *plandescription_;
}
inline void RtTpsProtoPlan::set_plandescription(const ::std::string& value) {
  set_has_plandescription();
  if (plandescription_ == &::google::protobuf::internal::kEmptyString) {
    plandescription_ = new ::std::string;
  }
  plandescription_->assign(value);
}
inline void RtTpsProtoPlan::set_plandescription(const char* value) {
  set_has_plandescription();
  if (plandescription_ == &::google::protobuf::internal::kEmptyString) {
    plandescription_ = new ::std::string;
  }
  plandescription_->assign(value);
}
inline void RtTpsProtoPlan::set_plandescription(const char* value, size_t size) {
  set_has_plandescription();
  if (plandescription_ == &::google::protobuf::internal::kEmptyString) {
    plandescription_ = new ::std::string;
  }
  plandescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_plandescription() {
  set_has_plandescription();
  if (plandescription_ == &::google::protobuf::internal::kEmptyString) {
    plandescription_ = new ::std::string;
  }
  return plandescription_;
}
inline ::std::string* RtTpsProtoPlan::release_plandescription() {
  clear_has_plandescription();
  if (plandescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plandescription_;
    plandescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string setupPoiUid = 36;
inline bool RtTpsProtoPlan::has_setuppoiuid() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RtTpsProtoPlan::set_has_setuppoiuid() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RtTpsProtoPlan::clear_has_setuppoiuid() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RtTpsProtoPlan::clear_setuppoiuid() {
  if (setuppoiuid_ != &::google::protobuf::internal::kEmptyString) {
    setuppoiuid_->clear();
  }
  clear_has_setuppoiuid();
}
inline const ::std::string& RtTpsProtoPlan::setuppoiuid() const {
  return *setuppoiuid_;
}
inline void RtTpsProtoPlan::set_setuppoiuid(const ::std::string& value) {
  set_has_setuppoiuid();
  if (setuppoiuid_ == &::google::protobuf::internal::kEmptyString) {
    setuppoiuid_ = new ::std::string;
  }
  setuppoiuid_->assign(value);
}
inline void RtTpsProtoPlan::set_setuppoiuid(const char* value) {
  set_has_setuppoiuid();
  if (setuppoiuid_ == &::google::protobuf::internal::kEmptyString) {
    setuppoiuid_ = new ::std::string;
  }
  setuppoiuid_->assign(value);
}
inline void RtTpsProtoPlan::set_setuppoiuid(const char* value, size_t size) {
  set_has_setuppoiuid();
  if (setuppoiuid_ == &::google::protobuf::internal::kEmptyString) {
    setuppoiuid_ = new ::std::string;
  }
  setuppoiuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoPlan::mutable_setuppoiuid() {
  set_has_setuppoiuid();
  if (setuppoiuid_ == &::google::protobuf::internal::kEmptyString) {
    setuppoiuid_ = new ::std::string;
  }
  return setuppoiuid_;
}
inline ::std::string* RtTpsProtoPlan::release_setuppoiuid() {
  clear_has_setuppoiuid();
  if (setuppoiuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = setuppoiuid_;
    setuppoiuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RtTpsProtoRepeatedPlan

// repeated .tps.proto.RtTpsProtoPlan planList = 1;
inline int RtTpsProtoRepeatedPlan::planlist_size() const {
  return planlist_.size();
}
inline void RtTpsProtoRepeatedPlan::clear_planlist() {
  planlist_.Clear();
}
inline const ::tps::proto::RtTpsProtoPlan& RtTpsProtoRepeatedPlan::planlist(int index) const {
  return planlist_.Get(index);
}
inline ::tps::proto::RtTpsProtoPlan* RtTpsProtoRepeatedPlan::mutable_planlist(int index) {
  return planlist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoPlan* RtTpsProtoRepeatedPlan::add_planlist() {
  return planlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPlan >&
RtTpsProtoRepeatedPlan::planlist() const {
  return planlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPlan >*
RtTpsProtoRepeatedPlan::mutable_planlist() {
  return &planlist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fproto_5fplan_2eproto__INCLUDED
