// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_ms_convolution.proto

#ifndef PROTOBUF_rt_5fms_5fconvolution_2eproto__INCLUDED
#define PROTOBUF_rt_5fms_5fconvolution_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ms {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();

class RT_MS_Convolution;
class RT_MS_PDDSpectrum;
class RT_MS_InFieldOffaxisVector;
class RT_MS_ConvolutionContourVerter;
class RT_MS_PhysicalWedgeField;
class RtTpsProtoRepeatedPhysicalWedgeField;
class RT_MS_VirtualWedgeInfo;
class RtTpsProtoRepeatedVirtualWedgeInfo;
class RT_MS_VirtualWedgeField;

// ===================================================================

class RT_MS_Convolution : public ::google::protobuf::Message {
 public:
  RT_MS_Convolution();
  virtual ~RT_MS_Convolution();
  
  RT_MS_Convolution(const RT_MS_Convolution& from);
  
  inline RT_MS_Convolution& operator=(const RT_MS_Convolution& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_Convolution& default_instance();
  
  void Swap(RT_MS_Convolution* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_Convolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_Convolution& from);
  void MergeFrom(const RT_MS_Convolution& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float diamOne = 1;
  inline bool has_diamone() const;
  inline void clear_diamone();
  static const int kDiamOneFieldNumber = 1;
  inline float diamone() const;
  inline void set_diamone(float value);
  
  // optional float diamTwo = 2;
  inline bool has_diamtwo() const;
  inline void clear_diamtwo();
  static const int kDiamTwoFieldNumber = 2;
  inline float diamtwo() const;
  inline void set_diamtwo(float value);
  
  // optional float srcRatio = 3;
  inline bool has_srcratio() const;
  inline void clear_srcratio();
  static const int kSrcRatioFieldNumber = 3;
  inline float srcratio() const;
  inline void set_srcratio(float value);
  
  // optional float transmission = 4;
  inline bool has_transmission() const;
  inline void clear_transmission();
  static const int kTransmissionFieldNumber = 4;
  inline float transmission() const;
  inline void set_transmission(float value);
  
  // optional float psd = 5;
  inline bool has_psd() const;
  inline void clear_psd();
  static const int kPsdFieldNumber = 5;
  inline float psd() const;
  inline void set_psd(float value);
  
  // optional float srcDepth = 6;
  inline bool has_srcdepth() const;
  inline void clear_srcdepth();
  static const int kSrcDepthFieldNumber = 6;
  inline float srcdepth() const;
  inline void set_srcdepth(float value);
  
  // optional float srcAtten = 7;
  inline bool has_srcatten() const;
  inline void clear_srcatten();
  static const int kSrcAttenFieldNumber = 7;
  inline float srcatten() const;
  inline void set_srcatten(float value);
  
  // optional float sddXJaw = 8;
  inline bool has_sddxjaw() const;
  inline void clear_sddxjaw();
  static const int kSddXJawFieldNumber = 8;
  inline float sddxjaw() const;
  inline void set_sddxjaw(float value);
  
  // optional float sddYJaw = 9;
  inline bool has_sddyjaw() const;
  inline void clear_sddyjaw();
  static const int kSddYJawFieldNumber = 9;
  inline float sddyjaw() const;
  inline void set_sddyjaw(float value);
  
  // optional float normTenMultiTen = 10;
  inline bool has_normtenmultiten() const;
  inline void clear_normtenmultiten();
  static const int kNormTenMultiTenFieldNumber = 10;
  inline float normtenmultiten() const;
  inline void set_normtenmultiten(float value);
  
  // optional float xk0 = 11;
  inline bool has_xk0() const;
  inline void clear_xk0();
  static const int kXk0FieldNumber = 11;
  inline float xk0() const;
  inline void set_xk0(float value);
  
  // optional float xk1 = 12;
  inline bool has_xk1() const;
  inline void clear_xk1();
  static const int kXk1FieldNumber = 12;
  inline float xk1() const;
  inline void set_xk1(float value);
  
  // optional float xk2 = 13;
  inline bool has_xk2() const;
  inline void clear_xk2();
  static const int kXk2FieldNumber = 13;
  inline float xk2() const;
  inline void set_xk2(float value);
  
  // optional float yk0 = 14;
  inline bool has_yk0() const;
  inline void clear_yk0();
  static const int kYk0FieldNumber = 14;
  inline float yk0() const;
  inline void set_yk0(float value);
  
  // optional float yk1 = 15;
  inline bool has_yk1() const;
  inline void clear_yk1();
  static const int kYk1FieldNumber = 15;
  inline float yk1() const;
  inline void set_yk1(float value);
  
  // optional float yk2 = 16;
  inline bool has_yk2() const;
  inline void clear_yk2();
  static const int kYk2FieldNumber = 16;
  inline float yk2() const;
  inline void set_yk2(float value);
  
  // optional bool electronContaminationFlag = 17;
  inline bool has_electroncontaminationflag() const;
  inline void clear_electroncontaminationflag();
  static const int kElectronContaminationFlagFieldNumber = 17;
  inline bool electroncontaminationflag() const;
  inline void set_electroncontaminationflag(bool value);
  
  // optional float electronMaxDepth = 18;
  inline bool has_electronmaxdepth() const;
  inline void clear_electronmaxdepth();
  static const int kElectronMaxDepthFieldNumber = 18;
  inline float electronmaxdepth() const;
  inline void set_electronmaxdepth(float value);
  
  // optional float surfaceDose = 19;
  inline bool has_surfacedose() const;
  inline void clear_surfacedose();
  static const int kSurfaceDoseFieldNumber = 19;
  inline float surfacedose() const;
  inline void set_surfacedose(float value);
  
  // optional float depthCoefficientK = 20;
  inline bool has_depthcoefficientk() const;
  inline void clear_depthcoefficientk();
  static const int kDepthCoefficientKFieldNumber = 20;
  inline float depthcoefficientk() const;
  inline void set_depthcoefficientk(float value);
  
  // optional float offaxisCoefficientA = 21;
  inline bool has_offaxiscoefficienta() const;
  inline void clear_offaxiscoefficienta();
  static const int kOffaxisCoefficientAFieldNumber = 21;
  inline float offaxiscoefficienta() const;
  inline void set_offaxiscoefficienta(float value);
  
  // optional float df = 22;
  inline bool has_df() const;
  inline void clear_df();
  static const int kDfFieldNumber = 22;
  inline float df() const;
  inline void set_df(float value);
  
  // optional float sf = 23;
  inline bool has_sf() const;
  inline void clear_sf();
  static const int kSfFieldNumber = 23;
  inline float sf() const;
  inline void set_sf(float value);
  
  // optional float cOne = 24;
  inline bool has_cone() const;
  inline void clear_cone();
  static const int kCOneFieldNumber = 24;
  inline float cone() const;
  inline void set_cone(float value);
  
  // optional float cTwo = 25;
  inline bool has_ctwo() const;
  inline void clear_ctwo();
  static const int kCTwoFieldNumber = 25;
  inline float ctwo() const;
  inline void set_ctwo(float value);
  
  // optional float cThree = 26;
  inline bool has_cthree() const;
  inline void clear_cthree();
  static const int kCThreeFieldNumber = 26;
  inline float cthree() const;
  inline void set_cthree(float value);
  
  // repeated .ms.proto.RT_MS_PDDSpectrum spectrumList = 27;
  inline int spectrumlist_size() const;
  inline void clear_spectrumlist();
  static const int kSpectrumListFieldNumber = 27;
  inline const ::ms::proto::RT_MS_PDDSpectrum& spectrumlist(int index) const;
  inline ::ms::proto::RT_MS_PDDSpectrum* mutable_spectrumlist(int index);
  inline ::ms::proto::RT_MS_PDDSpectrum* add_spectrumlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PDDSpectrum >&
      spectrumlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PDDSpectrum >*
      mutable_spectrumlist();
  
  // repeated .ms.proto.RT_MS_InFieldOffaxisVector inFieldOffaxisVector = 28;
  inline int infieldoffaxisvector_size() const;
  inline void clear_infieldoffaxisvector();
  static const int kInFieldOffaxisVectorFieldNumber = 28;
  inline const ::ms::proto::RT_MS_InFieldOffaxisVector& infieldoffaxisvector(int index) const;
  inline ::ms::proto::RT_MS_InFieldOffaxisVector* mutable_infieldoffaxisvector(int index);
  inline ::ms::proto::RT_MS_InFieldOffaxisVector* add_infieldoffaxisvector();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_InFieldOffaxisVector >&
      infieldoffaxisvector() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_InFieldOffaxisVector >*
      mutable_infieldoffaxisvector();
  
  // repeated .ms.proto.RT_MS_PhysicalWedgeField physicalWedgeFieldList = 29;
  inline int physicalwedgefieldlist_size() const;
  inline void clear_physicalwedgefieldlist();
  static const int kPhysicalWedgeFieldListFieldNumber = 29;
  inline const ::ms::proto::RT_MS_PhysicalWedgeField& physicalwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_PhysicalWedgeField* mutable_physicalwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_PhysicalWedgeField* add_physicalwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >&
      physicalwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >*
      mutable_physicalwedgefieldlist();
  
  // repeated .ms.proto.RT_MS_VirtualWedgeInfo virtualWedgeInfoList = 30;
  inline int virtualwedgeinfolist_size() const;
  inline void clear_virtualwedgeinfolist();
  static const int kVirtualWedgeInfoListFieldNumber = 30;
  inline const ::ms::proto::RT_MS_VirtualWedgeInfo& virtualwedgeinfolist(int index) const;
  inline ::ms::proto::RT_MS_VirtualWedgeInfo* mutable_virtualwedgeinfolist(int index);
  inline ::ms::proto::RT_MS_VirtualWedgeInfo* add_virtualwedgeinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >&
      virtualwedgeinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >*
      mutable_virtualwedgeinfolist();
  
  // optional string commissionUID = 31;
  inline bool has_commissionuid() const;
  inline void clear_commissionuid();
  static const int kCommissionUIDFieldNumber = 31;
  inline const ::std::string& commissionuid() const;
  inline void set_commissionuid(const ::std::string& value);
  inline void set_commissionuid(const char* value);
  inline void set_commissionuid(const char* value, size_t size);
  inline ::std::string* mutable_commissionuid();
  inline ::std::string* release_commissionuid();
  
  // optional string accName = 32;
  inline bool has_accname() const;
  inline void clear_accname();
  static const int kAccNameFieldNumber = 32;
  inline const ::std::string& accname() const;
  inline void set_accname(const ::std::string& value);
  inline void set_accname(const char* value);
  inline void set_accname(const char* value, size_t size);
  inline ::std::string* mutable_accname();
  inline ::std::string* release_accname();
  
  // optional string accessoryUID = 33;
  inline bool has_accessoryuid() const;
  inline void clear_accessoryuid();
  static const int kAccessoryUIDFieldNumber = 33;
  inline const ::std::string& accessoryuid() const;
  inline void set_accessoryuid(const ::std::string& value);
  inline void set_accessoryuid(const char* value);
  inline void set_accessoryuid(const char* value, size_t size);
  inline ::std::string* mutable_accessoryuid();
  inline ::std::string* release_accessoryuid();
  
  // optional string wedgeId = 34;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 34;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional int32 algType = 35;
  inline bool has_algtype() const;
  inline void clear_algtype();
  static const int kAlgTypeFieldNumber = 35;
  inline ::google::protobuf::int32 algtype() const;
  inline void set_algtype(::google::protobuf::int32 value);
  
  // optional float pddMuBase = 36;
  inline bool has_pddmubase() const;
  inline void clear_pddmubase();
  static const int kPddMuBaseFieldNumber = 36;
  inline float pddmubase() const;
  inline void set_pddmubase(float value);
  
  // optional float pddDmumx = 37;
  inline bool has_pdddmumx() const;
  inline void clear_pdddmumx();
  static const int kPddDmumxFieldNumber = 37;
  inline float pdddmumx() const;
  inline void set_pdddmumx(float value);
  
  // optional string mudatax = 38;
  inline bool has_mudatax() const;
  inline void clear_mudatax();
  static const int kMudataxFieldNumber = 38;
  inline const ::std::string& mudatax() const;
  inline void set_mudatax(const ::std::string& value);
  inline void set_mudatax(const char* value);
  inline void set_mudatax(const char* value, size_t size);
  inline ::std::string* mutable_mudatax();
  inline ::std::string* release_mudatax();
  
  // optional string ddmudr = 39;
  inline bool has_ddmudr() const;
  inline void clear_ddmudr();
  static const int kDdmudrFieldNumber = 39;
  inline const ::std::string& ddmudr() const;
  inline void set_ddmudr(const ::std::string& value);
  inline void set_ddmudr(const char* value);
  inline void set_ddmudr(const char* value, size_t size);
  inline ::std::string* mutable_ddmudr();
  inline ::std::string* release_ddmudr();
  
  // optional string mudatay = 40;
  inline bool has_mudatay() const;
  inline void clear_mudatay();
  static const int kMudatayFieldNumber = 40;
  inline const ::std::string& mudatay() const;
  inline void set_mudatay(const ::std::string& value);
  inline void set_mudatay(const char* value);
  inline void set_mudatay(const char* value, size_t size);
  inline ::std::string* mutable_mudatay();
  inline ::std::string* release_mudatay();
  
  // optional string dmudatay = 41;
  inline bool has_dmudatay() const;
  inline void clear_dmudatay();
  static const int kDmudatayFieldNumber = 41;
  inline const ::std::string& dmudatay() const;
  inline void set_dmudatay(const ::std::string& value);
  inline void set_dmudatay(const char* value);
  inline void set_dmudatay(const char* value, size_t size);
  inline ::std::string* mutable_dmudatay();
  inline ::std::string* release_dmudatay();
  
  // optional string outputmuy = 42;
  inline bool has_outputmuy() const;
  inline void clear_outputmuy();
  static const int kOutputmuyFieldNumber = 42;
  inline const ::std::string& outputmuy() const;
  inline void set_outputmuy(const ::std::string& value);
  inline void set_outputmuy(const char* value);
  inline void set_outputmuy(const char* value, size_t size);
  inline ::std::string* mutable_outputmuy();
  inline ::std::string* release_outputmuy();
  
  // optional float dmudr = 43;
  inline bool has_dmudr() const;
  inline void clear_dmudr();
  static const int kDmudrFieldNumber = 43;
  inline float dmudr() const;
  inline void set_dmudr(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_Convolution)
 private:
  inline void set_has_diamone();
  inline void clear_has_diamone();
  inline void set_has_diamtwo();
  inline void clear_has_diamtwo();
  inline void set_has_srcratio();
  inline void clear_has_srcratio();
  inline void set_has_transmission();
  inline void clear_has_transmission();
  inline void set_has_psd();
  inline void clear_has_psd();
  inline void set_has_srcdepth();
  inline void clear_has_srcdepth();
  inline void set_has_srcatten();
  inline void clear_has_srcatten();
  inline void set_has_sddxjaw();
  inline void clear_has_sddxjaw();
  inline void set_has_sddyjaw();
  inline void clear_has_sddyjaw();
  inline void set_has_normtenmultiten();
  inline void clear_has_normtenmultiten();
  inline void set_has_xk0();
  inline void clear_has_xk0();
  inline void set_has_xk1();
  inline void clear_has_xk1();
  inline void set_has_xk2();
  inline void clear_has_xk2();
  inline void set_has_yk0();
  inline void clear_has_yk0();
  inline void set_has_yk1();
  inline void clear_has_yk1();
  inline void set_has_yk2();
  inline void clear_has_yk2();
  inline void set_has_electroncontaminationflag();
  inline void clear_has_electroncontaminationflag();
  inline void set_has_electronmaxdepth();
  inline void clear_has_electronmaxdepth();
  inline void set_has_surfacedose();
  inline void clear_has_surfacedose();
  inline void set_has_depthcoefficientk();
  inline void clear_has_depthcoefficientk();
  inline void set_has_offaxiscoefficienta();
  inline void clear_has_offaxiscoefficienta();
  inline void set_has_df();
  inline void clear_has_df();
  inline void set_has_sf();
  inline void clear_has_sf();
  inline void set_has_cone();
  inline void clear_has_cone();
  inline void set_has_ctwo();
  inline void clear_has_ctwo();
  inline void set_has_cthree();
  inline void clear_has_cthree();
  inline void set_has_commissionuid();
  inline void clear_has_commissionuid();
  inline void set_has_accname();
  inline void clear_has_accname();
  inline void set_has_accessoryuid();
  inline void clear_has_accessoryuid();
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_algtype();
  inline void clear_has_algtype();
  inline void set_has_pddmubase();
  inline void clear_has_pddmubase();
  inline void set_has_pdddmumx();
  inline void clear_has_pdddmumx();
  inline void set_has_mudatax();
  inline void clear_has_mudatax();
  inline void set_has_ddmudr();
  inline void clear_has_ddmudr();
  inline void set_has_mudatay();
  inline void clear_has_mudatay();
  inline void set_has_dmudatay();
  inline void clear_has_dmudatay();
  inline void set_has_outputmuy();
  inline void clear_has_outputmuy();
  inline void set_has_dmudr();
  inline void clear_has_dmudr();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float diamone_;
  float diamtwo_;
  float srcratio_;
  float transmission_;
  float psd_;
  float srcdepth_;
  float srcatten_;
  float sddxjaw_;
  float sddyjaw_;
  float normtenmultiten_;
  float xk0_;
  float xk1_;
  float xk2_;
  float yk0_;
  float yk1_;
  float yk2_;
  bool electroncontaminationflag_;
  float electronmaxdepth_;
  float surfacedose_;
  float depthcoefficientk_;
  float offaxiscoefficienta_;
  float df_;
  float sf_;
  float cone_;
  float ctwo_;
  float cthree_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PDDSpectrum > spectrumlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_InFieldOffaxisVector > infieldoffaxisvector_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField > physicalwedgefieldlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo > virtualwedgeinfolist_;
  ::std::string* commissionuid_;
  ::std::string* accname_;
  ::std::string* accessoryuid_;
  ::std::string* wedgeid_;
  ::google::protobuf::int32 algtype_;
  float pddmubase_;
  ::std::string* mudatax_;
  ::std::string* ddmudr_;
  ::std::string* mudatay_;
  float pdddmumx_;
  float dmudr_;
  ::std::string* dmudatay_;
  ::std::string* outputmuy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(43 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_Convolution* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PDDSpectrum : public ::google::protobuf::Message {
 public:
  RT_MS_PDDSpectrum();
  virtual ~RT_MS_PDDSpectrum();
  
  RT_MS_PDDSpectrum(const RT_MS_PDDSpectrum& from);
  
  inline RT_MS_PDDSpectrum& operator=(const RT_MS_PDDSpectrum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PDDSpectrum& default_instance();
  
  void Swap(RT_MS_PDDSpectrum* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PDDSpectrum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PDDSpectrum& from);
  void MergeFrom(const RT_MS_PDDSpectrum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid0 = 1;
  inline bool has_uid0() const;
  inline void clear_uid0();
  static const int kUid0FieldNumber = 1;
  inline const ::std::string& uid0() const;
  inline void set_uid0(const ::std::string& value);
  inline void set_uid0(const char* value);
  inline void set_uid0(const char* value, size_t size);
  inline ::std::string* mutable_uid0();
  inline ::std::string* release_uid0();
  
  // optional string uid40 = 2;
  inline bool has_uid40() const;
  inline void clear_uid40();
  static const int kUid40FieldNumber = 2;
  inline const ::std::string& uid40() const;
  inline void set_uid40(const ::std::string& value);
  inline void set_uid40(const char* value);
  inline void set_uid40(const char* value, size_t size);
  inline ::std::string* mutable_uid40();
  inline ::std::string* release_uid40();
  
  // optional int32 energy0 = 3;
  inline bool has_energy0() const;
  inline void clear_energy0();
  static const int kEnergy0FieldNumber = 3;
  inline ::google::protobuf::int32 energy0() const;
  inline void set_energy0(::google::protobuf::int32 value);
  
  // optional int32 energy40 = 4;
  inline bool has_energy40() const;
  inline void clear_energy40();
  static const int kEnergy40FieldNumber = 4;
  inline ::google::protobuf::int32 energy40() const;
  inline void set_energy40(::google::protobuf::int32 value);
  
  // optional float kernelWeight0 = 5;
  inline bool has_kernelweight0() const;
  inline void clear_kernelweight0();
  static const int kKernelWeight0FieldNumber = 5;
  inline float kernelweight0() const;
  inline void set_kernelweight0(float value);
  
  // optional float kernelWeight40 = 6;
  inline bool has_kernelweight40() const;
  inline void clear_kernelweight40();
  static const int kKernelWeight40FieldNumber = 6;
  inline float kernelweight40() const;
  inline void set_kernelweight40(float value);
  
  // optional int32 fieldSize = 7;
  inline bool has_fieldsize() const;
  inline void clear_fieldsize();
  static const int kFieldSizeFieldNumber = 7;
  inline ::google::protobuf::int32 fieldsize() const;
  inline void set_fieldsize(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PDDSpectrum)
 private:
  inline void set_has_uid0();
  inline void clear_has_uid0();
  inline void set_has_uid40();
  inline void clear_has_uid40();
  inline void set_has_energy0();
  inline void clear_has_energy0();
  inline void set_has_energy40();
  inline void clear_has_energy40();
  inline void set_has_kernelweight0();
  inline void clear_has_kernelweight0();
  inline void set_has_kernelweight40();
  inline void clear_has_kernelweight40();
  inline void set_has_fieldsize();
  inline void clear_has_fieldsize();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid0_;
  ::std::string* uid40_;
  ::google::protobuf::int32 energy0_;
  ::google::protobuf::int32 energy40_;
  float kernelweight0_;
  float kernelweight40_;
  ::google::protobuf::int32 fieldsize_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PDDSpectrum* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_InFieldOffaxisVector : public ::google::protobuf::Message {
 public:
  RT_MS_InFieldOffaxisVector();
  virtual ~RT_MS_InFieldOffaxisVector();
  
  RT_MS_InFieldOffaxisVector(const RT_MS_InFieldOffaxisVector& from);
  
  inline RT_MS_InFieldOffaxisVector& operator=(const RT_MS_InFieldOffaxisVector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_InFieldOffaxisVector& default_instance();
  
  void Swap(RT_MS_InFieldOffaxisVector* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_InFieldOffaxisVector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_InFieldOffaxisVector& from);
  void MergeFrom(const RT_MS_InFieldOffaxisVector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline float radius() const;
  inline void set_radius(float value);
  
  // optional float offaxisRatio = 3;
  inline bool has_offaxisratio() const;
  inline void clear_offaxisratio();
  static const int kOffaxisRatioFieldNumber = 3;
  inline float offaxisratio() const;
  inline void set_offaxisratio(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_InFieldOffaxisVector)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_offaxisratio();
  inline void clear_has_offaxisratio();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float radius_;
  float offaxisratio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_InFieldOffaxisVector* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_ConvolutionContourVerter : public ::google::protobuf::Message {
 public:
  RT_MS_ConvolutionContourVerter();
  virtual ~RT_MS_ConvolutionContourVerter();
  
  RT_MS_ConvolutionContourVerter(const RT_MS_ConvolutionContourVerter& from);
  
  inline RT_MS_ConvolutionContourVerter& operator=(const RT_MS_ConvolutionContourVerter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_ConvolutionContourVerter& default_instance();
  
  void Swap(RT_MS_ConvolutionContourVerter* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_ConvolutionContourVerter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_ConvolutionContourVerter& from);
  void MergeFrom(const RT_MS_ConvolutionContourVerter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float ContourVerterx = 2;
  inline bool has_contourverterx() const;
  inline void clear_contourverterx();
  static const int kContourVerterxFieldNumber = 2;
  inline float contourverterx() const;
  inline void set_contourverterx(float value);
  
  // optional float ContourVertery = 3;
  inline bool has_contourvertery() const;
  inline void clear_contourvertery();
  static const int kContourVerteryFieldNumber = 3;
  inline float contourvertery() const;
  inline void set_contourvertery(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_ConvolutionContourVerter)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_contourverterx();
  inline void clear_has_contourverterx();
  inline void set_has_contourvertery();
  inline void clear_has_contourvertery();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float contourverterx_;
  float contourvertery_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_ConvolutionContourVerter* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PhysicalWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_PhysicalWedgeField();
  virtual ~RT_MS_PhysicalWedgeField();
  
  RT_MS_PhysicalWedgeField(const RT_MS_PhysicalWedgeField& from);
  
  inline RT_MS_PhysicalWedgeField& operator=(const RT_MS_PhysicalWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PhysicalWedgeField& default_instance();
  
  void Swap(RT_MS_PhysicalWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PhysicalWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PhysicalWedgeField& from);
  void MergeFrom(const RT_MS_PhysicalWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string wedgeUID = 1;
  inline bool has_wedgeuid() const;
  inline void clear_wedgeuid();
  static const int kWedgeUIDFieldNumber = 1;
  inline const ::std::string& wedgeuid() const;
  inline void set_wedgeuid(const ::std::string& value);
  inline void set_wedgeuid(const char* value);
  inline void set_wedgeuid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeuid();
  inline ::std::string* release_wedgeuid();
  
  // optional string wedgeId = 2;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 2;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional string wedgeType = 3;
  inline bool has_wedgetype() const;
  inline void clear_wedgetype();
  static const int kWedgeTypeFieldNumber = 3;
  inline const ::std::string& wedgetype() const;
  inline void set_wedgetype(const ::std::string& value);
  inline void set_wedgetype(const char* value);
  inline void set_wedgetype(const char* value, size_t size);
  inline ::std::string* mutable_wedgetype();
  inline ::std::string* release_wedgetype();
  
  // optional float mu = 4;
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 4;
  inline float mu() const;
  inline void set_mu(float value);
  
  // optional float dmudx = 5;
  inline bool has_dmudx() const;
  inline void clear_dmudx();
  static const int kDmudxFieldNumber = 5;
  inline float dmudx() const;
  inline void set_dmudx(float value);
  
  // optional float dmudr = 6;
  inline bool has_dmudr() const;
  inline void clear_dmudr();
  static const int kDmudrFieldNumber = 6;
  inline float dmudr() const;
  inline void set_dmudr(float value);
  
  // optional float dmuda = 7;
  inline bool has_dmuda() const;
  inline void clear_dmuda();
  static const int kDmudaFieldNumber = 7;
  inline float dmuda() const;
  inline void set_dmuda(float value);
  
  // optional float hvlSlope = 8;
  inline bool has_hvlslope() const;
  inline void clear_hvlslope();
  static const int kHvlSlopeFieldNumber = 8;
  inline float hvlslope() const;
  inline void set_hvlslope(float value);
  
  // optional string CarrierUDI = 9;
  inline bool has_carrierudi() const;
  inline void clear_carrierudi();
  static const int kCarrierUDIFieldNumber = 9;
  inline const ::std::string& carrierudi() const;
  inline void set_carrierudi(const ::std::string& value);
  inline void set_carrierudi(const char* value);
  inline void set_carrierudi(const char* value, size_t size);
  inline ::std::string* mutable_carrierudi();
  inline ::std::string* release_carrierudi();
  
  // optional float Carriermu = 10;
  inline bool has_carriermu() const;
  inline void clear_carriermu();
  static const int kCarriermuFieldNumber = 10;
  inline float carriermu() const;
  inline void set_carriermu(float value);
  
  // optional float Carrierdmudx = 11;
  inline bool has_carrierdmudx() const;
  inline void clear_carrierdmudx();
  static const int kCarrierdmudxFieldNumber = 11;
  inline float carrierdmudx() const;
  inline void set_carrierdmudx(float value);
  
  // optional float Carrierdmudr = 12;
  inline bool has_carrierdmudr() const;
  inline void clear_carrierdmudr();
  static const int kCarrierdmudrFieldNumber = 12;
  inline float carrierdmudr() const;
  inline void set_carrierdmudr(float value);
  
  // optional float Carrierdmuda = 13;
  inline bool has_carrierdmuda() const;
  inline void clear_carrierdmuda();
  static const int kCarrierdmudaFieldNumber = 13;
  inline float carrierdmuda() const;
  inline void set_carrierdmuda(float value);
  
  // optional float CarrierhvlSlope = 14;
  inline bool has_carrierhvlslope() const;
  inline void clear_carrierhvlslope();
  static const int kCarrierhvlSlopeFieldNumber = 14;
  inline float carrierhvlslope() const;
  inline void set_carrierhvlslope(float value);
  
  // optional float wedgeThick = 15;
  inline bool has_wedgethick() const;
  inline void clear_wedgethick();
  static const int kWedgeThickFieldNumber = 15;
  inline float wedgethick() const;
  inline void set_wedgethick(float value);
  
  // optional float carrierThick = 16;
  inline bool has_carrierthick() const;
  inline void clear_carrierthick();
  static const int kCarrierThickFieldNumber = 16;
  inline float carrierthick() const;
  inline void set_carrierthick(float value);
  
  // repeated .ms.proto.RT_MS_ConvolutionContourVerter weightContourVerterList = 17;
  inline int weightcontourverterlist_size() const;
  inline void clear_weightcontourverterlist();
  static const int kWeightContourVerterListFieldNumber = 17;
  inline const ::ms::proto::RT_MS_ConvolutionContourVerter& weightcontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_ConvolutionContourVerter* mutable_weightcontourverterlist(int index);
  inline ::ms::proto::RT_MS_ConvolutionContourVerter* add_weightcontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >&
      weightcontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >*
      mutable_weightcontourverterlist();
  
  // repeated .ms.proto.RT_MS_ConvolutionContourVerter carrierContourVerterList = 18;
  inline int carriercontourverterlist_size() const;
  inline void clear_carriercontourverterlist();
  static const int kCarrierContourVerterListFieldNumber = 18;
  inline const ::ms::proto::RT_MS_ConvolutionContourVerter& carriercontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_ConvolutionContourVerter* mutable_carriercontourverterlist(int index);
  inline ::ms::proto::RT_MS_ConvolutionContourVerter* add_carriercontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >&
      carriercontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >*
      mutable_carriercontourverterlist();
  
  // optional string contourUID1 = 19;
  inline bool has_contouruid1() const;
  inline void clear_contouruid1();
  static const int kContourUID1FieldNumber = 19;
  inline const ::std::string& contouruid1() const;
  inline void set_contouruid1(const ::std::string& value);
  inline void set_contouruid1(const char* value);
  inline void set_contouruid1(const char* value, size_t size);
  inline ::std::string* mutable_contouruid1();
  inline ::std::string* release_contouruid1();
  
  // optional string contourUID2 = 20;
  inline bool has_contouruid2() const;
  inline void clear_contouruid2();
  static const int kContourUID2FieldNumber = 20;
  inline const ::std::string& contouruid2() const;
  inline void set_contouruid2(const ::std::string& value);
  inline void set_contouruid2(const char* value);
  inline void set_contouruid2(const char* value, size_t size);
  inline ::std::string* mutable_contouruid2();
  inline ::std::string* release_contouruid2();
  
  // optional string parentUID = 21;
  inline bool has_parentuid() const;
  inline void clear_parentuid();
  static const int kParentUIDFieldNumber = 21;
  inline const ::std::string& parentuid() const;
  inline void set_parentuid(const ::std::string& value);
  inline void set_parentuid(const char* value);
  inline void set_parentuid(const char* value, size_t size);
  inline ::std::string* mutable_parentuid();
  inline ::std::string* release_parentuid();
  
  // optional int32 algType = 22;
  inline bool has_algtype() const;
  inline void clear_algtype();
  static const int kAlgTypeFieldNumber = 22;
  inline ::google::protobuf::int32 algtype() const;
  inline void set_algtype(::google::protobuf::int32 value);
  
  // optional float density = 23;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 23;
  inline float density() const;
  inline void set_density(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PhysicalWedgeField)
 private:
  inline void set_has_wedgeuid();
  inline void clear_has_wedgeuid();
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_wedgetype();
  inline void clear_has_wedgetype();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_dmudx();
  inline void clear_has_dmudx();
  inline void set_has_dmudr();
  inline void clear_has_dmudr();
  inline void set_has_dmuda();
  inline void clear_has_dmuda();
  inline void set_has_hvlslope();
  inline void clear_has_hvlslope();
  inline void set_has_carrierudi();
  inline void clear_has_carrierudi();
  inline void set_has_carriermu();
  inline void clear_has_carriermu();
  inline void set_has_carrierdmudx();
  inline void clear_has_carrierdmudx();
  inline void set_has_carrierdmudr();
  inline void clear_has_carrierdmudr();
  inline void set_has_carrierdmuda();
  inline void clear_has_carrierdmuda();
  inline void set_has_carrierhvlslope();
  inline void clear_has_carrierhvlslope();
  inline void set_has_wedgethick();
  inline void clear_has_wedgethick();
  inline void set_has_carrierthick();
  inline void clear_has_carrierthick();
  inline void set_has_contouruid1();
  inline void clear_has_contouruid1();
  inline void set_has_contouruid2();
  inline void clear_has_contouruid2();
  inline void set_has_parentuid();
  inline void clear_has_parentuid();
  inline void set_has_algtype();
  inline void clear_has_algtype();
  inline void set_has_density();
  inline void clear_has_density();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* wedgeuid_;
  ::std::string* wedgeid_;
  ::std::string* wedgetype_;
  float mu_;
  float dmudx_;
  float dmudr_;
  float dmuda_;
  ::std::string* carrierudi_;
  float hvlslope_;
  float carriermu_;
  float carrierdmudx_;
  float carrierdmudr_;
  float carrierdmuda_;
  float carrierhvlslope_;
  float wedgethick_;
  float carrierthick_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter > weightcontourverterlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter > carriercontourverterlist_;
  ::std::string* contouruid1_;
  ::std::string* contouruid2_;
  ::std::string* parentuid_;
  ::google::protobuf::int32 algtype_;
  float density_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PhysicalWedgeField* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoRepeatedPhysicalWedgeField : public ::google::protobuf::Message {
 public:
  RtTpsProtoRepeatedPhysicalWedgeField();
  virtual ~RtTpsProtoRepeatedPhysicalWedgeField();
  
  RtTpsProtoRepeatedPhysicalWedgeField(const RtTpsProtoRepeatedPhysicalWedgeField& from);
  
  inline RtTpsProtoRepeatedPhysicalWedgeField& operator=(const RtTpsProtoRepeatedPhysicalWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoRepeatedPhysicalWedgeField& default_instance();
  
  void Swap(RtTpsProtoRepeatedPhysicalWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoRepeatedPhysicalWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoRepeatedPhysicalWedgeField& from);
  void MergeFrom(const RtTpsProtoRepeatedPhysicalWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ms.proto.RT_MS_PhysicalWedgeField physicalwedgefieldlist = 1;
  inline int physicalwedgefieldlist_size() const;
  inline void clear_physicalwedgefieldlist();
  static const int kPhysicalwedgefieldlistFieldNumber = 1;
  inline const ::ms::proto::RT_MS_PhysicalWedgeField& physicalwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_PhysicalWedgeField* mutable_physicalwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_PhysicalWedgeField* add_physicalwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >&
      physicalwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >*
      mutable_physicalwedgefieldlist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RtTpsProtoRepeatedPhysicalWedgeField)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField > physicalwedgefieldlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoRepeatedPhysicalWedgeField* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_VirtualWedgeInfo : public ::google::protobuf::Message {
 public:
  RT_MS_VirtualWedgeInfo();
  virtual ~RT_MS_VirtualWedgeInfo();
  
  RT_MS_VirtualWedgeInfo(const RT_MS_VirtualWedgeInfo& from);
  
  inline RT_MS_VirtualWedgeInfo& operator=(const RT_MS_VirtualWedgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_VirtualWedgeInfo& default_instance();
  
  void Swap(RT_MS_VirtualWedgeInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_VirtualWedgeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_VirtualWedgeInfo& from);
  void MergeFrom(const RT_MS_VirtualWedgeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string parentUID = 1;
  inline bool has_parentuid() const;
  inline void clear_parentuid();
  static const int kParentUIDFieldNumber = 1;
  inline const ::std::string& parentuid() const;
  inline void set_parentuid(const ::std::string& value);
  inline void set_parentuid(const char* value);
  inline void set_parentuid(const char* value, size_t size);
  inline ::std::string* mutable_parentuid();
  inline ::std::string* release_parentuid();
  
  // optional string virtualUid = 2;
  inline bool has_virtualuid() const;
  inline void clear_virtualuid();
  static const int kVirtualUidFieldNumber = 2;
  inline const ::std::string& virtualuid() const;
  inline void set_virtualuid(const ::std::string& value);
  inline void set_virtualuid(const char* value);
  inline void set_virtualuid(const char* value, size_t size);
  inline ::std::string* mutable_virtualuid();
  inline ::std::string* release_virtualuid();
  
  // optional string goldenUID = 3;
  inline bool has_goldenuid() const;
  inline void clear_goldenuid();
  static const int kGoldenUIDFieldNumber = 3;
  inline const ::std::string& goldenuid() const;
  inline void set_goldenuid(const ::std::string& value);
  inline void set_goldenuid(const char* value);
  inline void set_goldenuid(const char* value, size_t size);
  inline ::std::string* mutable_goldenuid();
  inline ::std::string* release_goldenuid();
  
  // repeated .ms.proto.RT_MS_VirtualWedgeField virtualWedgeFieldList = 4;
  inline int virtualwedgefieldlist_size() const;
  inline void clear_virtualwedgefieldlist();
  static const int kVirtualWedgeFieldListFieldNumber = 4;
  inline const ::ms::proto::RT_MS_VirtualWedgeField& virtualwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_VirtualWedgeField* mutable_virtualwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_VirtualWedgeField* add_virtualwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeField >&
      virtualwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeField >*
      mutable_virtualwedgefieldlist();
  
  // optional int32 algType = 5;
  inline bool has_algtype() const;
  inline void clear_algtype();
  static const int kAlgTypeFieldNumber = 5;
  inline ::google::protobuf::int32 algtype() const;
  inline void set_algtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_VirtualWedgeInfo)
 private:
  inline void set_has_parentuid();
  inline void clear_has_parentuid();
  inline void set_has_virtualuid();
  inline void clear_has_virtualuid();
  inline void set_has_goldenuid();
  inline void clear_has_goldenuid();
  inline void set_has_algtype();
  inline void clear_has_algtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* parentuid_;
  ::std::string* virtualuid_;
  ::std::string* goldenuid_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeField > virtualwedgefieldlist_;
  ::google::protobuf::int32 algtype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_VirtualWedgeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoRepeatedVirtualWedgeInfo : public ::google::protobuf::Message {
 public:
  RtTpsProtoRepeatedVirtualWedgeInfo();
  virtual ~RtTpsProtoRepeatedVirtualWedgeInfo();
  
  RtTpsProtoRepeatedVirtualWedgeInfo(const RtTpsProtoRepeatedVirtualWedgeInfo& from);
  
  inline RtTpsProtoRepeatedVirtualWedgeInfo& operator=(const RtTpsProtoRepeatedVirtualWedgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoRepeatedVirtualWedgeInfo& default_instance();
  
  void Swap(RtTpsProtoRepeatedVirtualWedgeInfo* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoRepeatedVirtualWedgeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoRepeatedVirtualWedgeInfo& from);
  void MergeFrom(const RtTpsProtoRepeatedVirtualWedgeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ms.proto.RT_MS_VirtualWedgeInfo virtualwedgeinfolist = 1;
  inline int virtualwedgeinfolist_size() const;
  inline void clear_virtualwedgeinfolist();
  static const int kVirtualwedgeinfolistFieldNumber = 1;
  inline const ::ms::proto::RT_MS_VirtualWedgeInfo& virtualwedgeinfolist(int index) const;
  inline ::ms::proto::RT_MS_VirtualWedgeInfo* mutable_virtualwedgeinfolist(int index);
  inline ::ms::proto::RT_MS_VirtualWedgeInfo* add_virtualwedgeinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >&
      virtualwedgeinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >*
      mutable_virtualwedgeinfolist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RtTpsProtoRepeatedVirtualWedgeInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo > virtualwedgeinfolist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoRepeatedVirtualWedgeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_VirtualWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_VirtualWedgeField();
  virtual ~RT_MS_VirtualWedgeField();
  
  RT_MS_VirtualWedgeField(const RT_MS_VirtualWedgeField& from);
  
  inline RT_MS_VirtualWedgeField& operator=(const RT_MS_VirtualWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_VirtualWedgeField& default_instance();
  
  void Swap(RT_MS_VirtualWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_VirtualWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_VirtualWedgeField& from);
  void MergeFrom(const RT_MS_VirtualWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float collimatorX1Position = 2;
  inline bool has_collimatorx1position() const;
  inline void clear_collimatorx1position();
  static const int kCollimatorX1PositionFieldNumber = 2;
  inline float collimatorx1position() const;
  inline void set_collimatorx1position(float value);
  
  // optional float collimatorX2Position = 3;
  inline bool has_collimatorx2position() const;
  inline void clear_collimatorx2position();
  static const int kCollimatorX2PositionFieldNumber = 3;
  inline float collimatorx2position() const;
  inline void set_collimatorx2position(float value);
  
  // optional float relativeMU = 4;
  inline bool has_relativemu() const;
  inline void clear_relativemu();
  static const int kRelativeMUFieldNumber = 4;
  inline float relativemu() const;
  inline void set_relativemu(float value);
  
  // optional float correctionFactor = 5;
  inline bool has_correctionfactor() const;
  inline void clear_correctionfactor();
  static const int kCorrectionFactorFieldNumber = 5;
  inline float correctionfactor() const;
  inline void set_correctionfactor(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_VirtualWedgeField)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_collimatorx1position();
  inline void clear_has_collimatorx1position();
  inline void set_has_collimatorx2position();
  inline void clear_has_collimatorx2position();
  inline void set_has_relativemu();
  inline void clear_has_relativemu();
  inline void set_has_correctionfactor();
  inline void clear_has_correctionfactor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float collimatorx1position_;
  float collimatorx2position_;
  float relativemu_;
  float correctionfactor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fconvolution_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fconvolution_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_VirtualWedgeField* default_instance_;
};
// ===================================================================


// ===================================================================

// RT_MS_Convolution

// optional float diamOne = 1;
inline bool RT_MS_Convolution::has_diamone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_Convolution::set_has_diamone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_Convolution::clear_has_diamone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_Convolution::clear_diamone() {
  diamone_ = 0;
  clear_has_diamone();
}
inline float RT_MS_Convolution::diamone() const {
  return diamone_;
}
inline void RT_MS_Convolution::set_diamone(float value) {
  set_has_diamone();
  diamone_ = value;
}

// optional float diamTwo = 2;
inline bool RT_MS_Convolution::has_diamtwo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_Convolution::set_has_diamtwo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_Convolution::clear_has_diamtwo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_Convolution::clear_diamtwo() {
  diamtwo_ = 0;
  clear_has_diamtwo();
}
inline float RT_MS_Convolution::diamtwo() const {
  return diamtwo_;
}
inline void RT_MS_Convolution::set_diamtwo(float value) {
  set_has_diamtwo();
  diamtwo_ = value;
}

// optional float srcRatio = 3;
inline bool RT_MS_Convolution::has_srcratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_Convolution::set_has_srcratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_Convolution::clear_has_srcratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_Convolution::clear_srcratio() {
  srcratio_ = 0;
  clear_has_srcratio();
}
inline float RT_MS_Convolution::srcratio() const {
  return srcratio_;
}
inline void RT_MS_Convolution::set_srcratio(float value) {
  set_has_srcratio();
  srcratio_ = value;
}

// optional float transmission = 4;
inline bool RT_MS_Convolution::has_transmission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_Convolution::set_has_transmission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_Convolution::clear_has_transmission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_Convolution::clear_transmission() {
  transmission_ = 0;
  clear_has_transmission();
}
inline float RT_MS_Convolution::transmission() const {
  return transmission_;
}
inline void RT_MS_Convolution::set_transmission(float value) {
  set_has_transmission();
  transmission_ = value;
}

// optional float psd = 5;
inline bool RT_MS_Convolution::has_psd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_Convolution::set_has_psd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_Convolution::clear_has_psd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_Convolution::clear_psd() {
  psd_ = 0;
  clear_has_psd();
}
inline float RT_MS_Convolution::psd() const {
  return psd_;
}
inline void RT_MS_Convolution::set_psd(float value) {
  set_has_psd();
  psd_ = value;
}

// optional float srcDepth = 6;
inline bool RT_MS_Convolution::has_srcdepth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_Convolution::set_has_srcdepth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_Convolution::clear_has_srcdepth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_Convolution::clear_srcdepth() {
  srcdepth_ = 0;
  clear_has_srcdepth();
}
inline float RT_MS_Convolution::srcdepth() const {
  return srcdepth_;
}
inline void RT_MS_Convolution::set_srcdepth(float value) {
  set_has_srcdepth();
  srcdepth_ = value;
}

// optional float srcAtten = 7;
inline bool RT_MS_Convolution::has_srcatten() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_Convolution::set_has_srcatten() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_Convolution::clear_has_srcatten() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_Convolution::clear_srcatten() {
  srcatten_ = 0;
  clear_has_srcatten();
}
inline float RT_MS_Convolution::srcatten() const {
  return srcatten_;
}
inline void RT_MS_Convolution::set_srcatten(float value) {
  set_has_srcatten();
  srcatten_ = value;
}

// optional float sddXJaw = 8;
inline bool RT_MS_Convolution::has_sddxjaw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_Convolution::set_has_sddxjaw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_Convolution::clear_has_sddxjaw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_Convolution::clear_sddxjaw() {
  sddxjaw_ = 0;
  clear_has_sddxjaw();
}
inline float RT_MS_Convolution::sddxjaw() const {
  return sddxjaw_;
}
inline void RT_MS_Convolution::set_sddxjaw(float value) {
  set_has_sddxjaw();
  sddxjaw_ = value;
}

// optional float sddYJaw = 9;
inline bool RT_MS_Convolution::has_sddyjaw() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_Convolution::set_has_sddyjaw() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_Convolution::clear_has_sddyjaw() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_Convolution::clear_sddyjaw() {
  sddyjaw_ = 0;
  clear_has_sddyjaw();
}
inline float RT_MS_Convolution::sddyjaw() const {
  return sddyjaw_;
}
inline void RT_MS_Convolution::set_sddyjaw(float value) {
  set_has_sddyjaw();
  sddyjaw_ = value;
}

// optional float normTenMultiTen = 10;
inline bool RT_MS_Convolution::has_normtenmultiten() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_Convolution::set_has_normtenmultiten() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_Convolution::clear_has_normtenmultiten() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_Convolution::clear_normtenmultiten() {
  normtenmultiten_ = 0;
  clear_has_normtenmultiten();
}
inline float RT_MS_Convolution::normtenmultiten() const {
  return normtenmultiten_;
}
inline void RT_MS_Convolution::set_normtenmultiten(float value) {
  set_has_normtenmultiten();
  normtenmultiten_ = value;
}

// optional float xk0 = 11;
inline bool RT_MS_Convolution::has_xk0() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_Convolution::set_has_xk0() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_Convolution::clear_has_xk0() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_Convolution::clear_xk0() {
  xk0_ = 0;
  clear_has_xk0();
}
inline float RT_MS_Convolution::xk0() const {
  return xk0_;
}
inline void RT_MS_Convolution::set_xk0(float value) {
  set_has_xk0();
  xk0_ = value;
}

// optional float xk1 = 12;
inline bool RT_MS_Convolution::has_xk1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_Convolution::set_has_xk1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_Convolution::clear_has_xk1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_Convolution::clear_xk1() {
  xk1_ = 0;
  clear_has_xk1();
}
inline float RT_MS_Convolution::xk1() const {
  return xk1_;
}
inline void RT_MS_Convolution::set_xk1(float value) {
  set_has_xk1();
  xk1_ = value;
}

// optional float xk2 = 13;
inline bool RT_MS_Convolution::has_xk2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_Convolution::set_has_xk2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_Convolution::clear_has_xk2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_Convolution::clear_xk2() {
  xk2_ = 0;
  clear_has_xk2();
}
inline float RT_MS_Convolution::xk2() const {
  return xk2_;
}
inline void RT_MS_Convolution::set_xk2(float value) {
  set_has_xk2();
  xk2_ = value;
}

// optional float yk0 = 14;
inline bool RT_MS_Convolution::has_yk0() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_Convolution::set_has_yk0() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_Convolution::clear_has_yk0() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_Convolution::clear_yk0() {
  yk0_ = 0;
  clear_has_yk0();
}
inline float RT_MS_Convolution::yk0() const {
  return yk0_;
}
inline void RT_MS_Convolution::set_yk0(float value) {
  set_has_yk0();
  yk0_ = value;
}

// optional float yk1 = 15;
inline bool RT_MS_Convolution::has_yk1() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_Convolution::set_has_yk1() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_Convolution::clear_has_yk1() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_Convolution::clear_yk1() {
  yk1_ = 0;
  clear_has_yk1();
}
inline float RT_MS_Convolution::yk1() const {
  return yk1_;
}
inline void RT_MS_Convolution::set_yk1(float value) {
  set_has_yk1();
  yk1_ = value;
}

// optional float yk2 = 16;
inline bool RT_MS_Convolution::has_yk2() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_Convolution::set_has_yk2() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_Convolution::clear_has_yk2() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_Convolution::clear_yk2() {
  yk2_ = 0;
  clear_has_yk2();
}
inline float RT_MS_Convolution::yk2() const {
  return yk2_;
}
inline void RT_MS_Convolution::set_yk2(float value) {
  set_has_yk2();
  yk2_ = value;
}

// optional bool electronContaminationFlag = 17;
inline bool RT_MS_Convolution::has_electroncontaminationflag() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_Convolution::set_has_electroncontaminationflag() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_Convolution::clear_has_electroncontaminationflag() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_Convolution::clear_electroncontaminationflag() {
  electroncontaminationflag_ = false;
  clear_has_electroncontaminationflag();
}
inline bool RT_MS_Convolution::electroncontaminationflag() const {
  return electroncontaminationflag_;
}
inline void RT_MS_Convolution::set_electroncontaminationflag(bool value) {
  set_has_electroncontaminationflag();
  electroncontaminationflag_ = value;
}

// optional float electronMaxDepth = 18;
inline bool RT_MS_Convolution::has_electronmaxdepth() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_Convolution::set_has_electronmaxdepth() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_Convolution::clear_has_electronmaxdepth() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_Convolution::clear_electronmaxdepth() {
  electronmaxdepth_ = 0;
  clear_has_electronmaxdepth();
}
inline float RT_MS_Convolution::electronmaxdepth() const {
  return electronmaxdepth_;
}
inline void RT_MS_Convolution::set_electronmaxdepth(float value) {
  set_has_electronmaxdepth();
  electronmaxdepth_ = value;
}

// optional float surfaceDose = 19;
inline bool RT_MS_Convolution::has_surfacedose() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_Convolution::set_has_surfacedose() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_Convolution::clear_has_surfacedose() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_Convolution::clear_surfacedose() {
  surfacedose_ = 0;
  clear_has_surfacedose();
}
inline float RT_MS_Convolution::surfacedose() const {
  return surfacedose_;
}
inline void RT_MS_Convolution::set_surfacedose(float value) {
  set_has_surfacedose();
  surfacedose_ = value;
}

// optional float depthCoefficientK = 20;
inline bool RT_MS_Convolution::has_depthcoefficientk() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_Convolution::set_has_depthcoefficientk() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_Convolution::clear_has_depthcoefficientk() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_Convolution::clear_depthcoefficientk() {
  depthcoefficientk_ = 0;
  clear_has_depthcoefficientk();
}
inline float RT_MS_Convolution::depthcoefficientk() const {
  return depthcoefficientk_;
}
inline void RT_MS_Convolution::set_depthcoefficientk(float value) {
  set_has_depthcoefficientk();
  depthcoefficientk_ = value;
}

// optional float offaxisCoefficientA = 21;
inline bool RT_MS_Convolution::has_offaxiscoefficienta() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_Convolution::set_has_offaxiscoefficienta() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_Convolution::clear_has_offaxiscoefficienta() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_Convolution::clear_offaxiscoefficienta() {
  offaxiscoefficienta_ = 0;
  clear_has_offaxiscoefficienta();
}
inline float RT_MS_Convolution::offaxiscoefficienta() const {
  return offaxiscoefficienta_;
}
inline void RT_MS_Convolution::set_offaxiscoefficienta(float value) {
  set_has_offaxiscoefficienta();
  offaxiscoefficienta_ = value;
}

// optional float df = 22;
inline bool RT_MS_Convolution::has_df() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_Convolution::set_has_df() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_Convolution::clear_has_df() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_Convolution::clear_df() {
  df_ = 0;
  clear_has_df();
}
inline float RT_MS_Convolution::df() const {
  return df_;
}
inline void RT_MS_Convolution::set_df(float value) {
  set_has_df();
  df_ = value;
}

// optional float sf = 23;
inline bool RT_MS_Convolution::has_sf() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_Convolution::set_has_sf() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_Convolution::clear_has_sf() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_Convolution::clear_sf() {
  sf_ = 0;
  clear_has_sf();
}
inline float RT_MS_Convolution::sf() const {
  return sf_;
}
inline void RT_MS_Convolution::set_sf(float value) {
  set_has_sf();
  sf_ = value;
}

// optional float cOne = 24;
inline bool RT_MS_Convolution::has_cone() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RT_MS_Convolution::set_has_cone() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RT_MS_Convolution::clear_has_cone() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RT_MS_Convolution::clear_cone() {
  cone_ = 0;
  clear_has_cone();
}
inline float RT_MS_Convolution::cone() const {
  return cone_;
}
inline void RT_MS_Convolution::set_cone(float value) {
  set_has_cone();
  cone_ = value;
}

// optional float cTwo = 25;
inline bool RT_MS_Convolution::has_ctwo() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RT_MS_Convolution::set_has_ctwo() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RT_MS_Convolution::clear_has_ctwo() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RT_MS_Convolution::clear_ctwo() {
  ctwo_ = 0;
  clear_has_ctwo();
}
inline float RT_MS_Convolution::ctwo() const {
  return ctwo_;
}
inline void RT_MS_Convolution::set_ctwo(float value) {
  set_has_ctwo();
  ctwo_ = value;
}

// optional float cThree = 26;
inline bool RT_MS_Convolution::has_cthree() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RT_MS_Convolution::set_has_cthree() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RT_MS_Convolution::clear_has_cthree() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RT_MS_Convolution::clear_cthree() {
  cthree_ = 0;
  clear_has_cthree();
}
inline float RT_MS_Convolution::cthree() const {
  return cthree_;
}
inline void RT_MS_Convolution::set_cthree(float value) {
  set_has_cthree();
  cthree_ = value;
}

// repeated .ms.proto.RT_MS_PDDSpectrum spectrumList = 27;
inline int RT_MS_Convolution::spectrumlist_size() const {
  return spectrumlist_.size();
}
inline void RT_MS_Convolution::clear_spectrumlist() {
  spectrumlist_.Clear();
}
inline const ::ms::proto::RT_MS_PDDSpectrum& RT_MS_Convolution::spectrumlist(int index) const {
  return spectrumlist_.Get(index);
}
inline ::ms::proto::RT_MS_PDDSpectrum* RT_MS_Convolution::mutable_spectrumlist(int index) {
  return spectrumlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PDDSpectrum* RT_MS_Convolution::add_spectrumlist() {
  return spectrumlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PDDSpectrum >&
RT_MS_Convolution::spectrumlist() const {
  return spectrumlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PDDSpectrum >*
RT_MS_Convolution::mutable_spectrumlist() {
  return &spectrumlist_;
}

// repeated .ms.proto.RT_MS_InFieldOffaxisVector inFieldOffaxisVector = 28;
inline int RT_MS_Convolution::infieldoffaxisvector_size() const {
  return infieldoffaxisvector_.size();
}
inline void RT_MS_Convolution::clear_infieldoffaxisvector() {
  infieldoffaxisvector_.Clear();
}
inline const ::ms::proto::RT_MS_InFieldOffaxisVector& RT_MS_Convolution::infieldoffaxisvector(int index) const {
  return infieldoffaxisvector_.Get(index);
}
inline ::ms::proto::RT_MS_InFieldOffaxisVector* RT_MS_Convolution::mutable_infieldoffaxisvector(int index) {
  return infieldoffaxisvector_.Mutable(index);
}
inline ::ms::proto::RT_MS_InFieldOffaxisVector* RT_MS_Convolution::add_infieldoffaxisvector() {
  return infieldoffaxisvector_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_InFieldOffaxisVector >&
RT_MS_Convolution::infieldoffaxisvector() const {
  return infieldoffaxisvector_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_InFieldOffaxisVector >*
RT_MS_Convolution::mutable_infieldoffaxisvector() {
  return &infieldoffaxisvector_;
}

// repeated .ms.proto.RT_MS_PhysicalWedgeField physicalWedgeFieldList = 29;
inline int RT_MS_Convolution::physicalwedgefieldlist_size() const {
  return physicalwedgefieldlist_.size();
}
inline void RT_MS_Convolution::clear_physicalwedgefieldlist() {
  physicalwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_PhysicalWedgeField& RT_MS_Convolution::physicalwedgefieldlist(int index) const {
  return physicalwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_PhysicalWedgeField* RT_MS_Convolution::mutable_physicalwedgefieldlist(int index) {
  return physicalwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PhysicalWedgeField* RT_MS_Convolution::add_physicalwedgefieldlist() {
  return physicalwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >&
RT_MS_Convolution::physicalwedgefieldlist() const {
  return physicalwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >*
RT_MS_Convolution::mutable_physicalwedgefieldlist() {
  return &physicalwedgefieldlist_;
}

// repeated .ms.proto.RT_MS_VirtualWedgeInfo virtualWedgeInfoList = 30;
inline int RT_MS_Convolution::virtualwedgeinfolist_size() const {
  return virtualwedgeinfolist_.size();
}
inline void RT_MS_Convolution::clear_virtualwedgeinfolist() {
  virtualwedgeinfolist_.Clear();
}
inline const ::ms::proto::RT_MS_VirtualWedgeInfo& RT_MS_Convolution::virtualwedgeinfolist(int index) const {
  return virtualwedgeinfolist_.Get(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeInfo* RT_MS_Convolution::mutable_virtualwedgeinfolist(int index) {
  return virtualwedgeinfolist_.Mutable(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeInfo* RT_MS_Convolution::add_virtualwedgeinfolist() {
  return virtualwedgeinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >&
RT_MS_Convolution::virtualwedgeinfolist() const {
  return virtualwedgeinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >*
RT_MS_Convolution::mutable_virtualwedgeinfolist() {
  return &virtualwedgeinfolist_;
}

// optional string commissionUID = 31;
inline bool RT_MS_Convolution::has_commissionuid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void RT_MS_Convolution::set_has_commissionuid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void RT_MS_Convolution::clear_has_commissionuid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void RT_MS_Convolution::clear_commissionuid() {
  if (commissionuid_ != &::google::protobuf::internal::kEmptyString) {
    commissionuid_->clear();
  }
  clear_has_commissionuid();
}
inline const ::std::string& RT_MS_Convolution::commissionuid() const {
  return *commissionuid_;
}
inline void RT_MS_Convolution::set_commissionuid(const ::std::string& value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_Convolution::set_commissionuid(const char* value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_Convolution::set_commissionuid(const char* value, size_t size) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_commissionuid() {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  return commissionuid_;
}
inline ::std::string* RT_MS_Convolution::release_commissionuid() {
  clear_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commissionuid_;
    commissionuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string accName = 32;
inline bool RT_MS_Convolution::has_accname() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void RT_MS_Convolution::set_has_accname() {
  _has_bits_[0] |= 0x80000000u;
}
inline void RT_MS_Convolution::clear_has_accname() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void RT_MS_Convolution::clear_accname() {
  if (accname_ != &::google::protobuf::internal::kEmptyString) {
    accname_->clear();
  }
  clear_has_accname();
}
inline const ::std::string& RT_MS_Convolution::accname() const {
  return *accname_;
}
inline void RT_MS_Convolution::set_accname(const ::std::string& value) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(value);
}
inline void RT_MS_Convolution::set_accname(const char* value) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(value);
}
inline void RT_MS_Convolution::set_accname(const char* value, size_t size) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_accname() {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  return accname_;
}
inline ::std::string* RT_MS_Convolution::release_accname() {
  clear_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accname_;
    accname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string accessoryUID = 33;
inline bool RT_MS_Convolution::has_accessoryuid() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RT_MS_Convolution::set_has_accessoryuid() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RT_MS_Convolution::clear_has_accessoryuid() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RT_MS_Convolution::clear_accessoryuid() {
  if (accessoryuid_ != &::google::protobuf::internal::kEmptyString) {
    accessoryuid_->clear();
  }
  clear_has_accessoryuid();
}
inline const ::std::string& RT_MS_Convolution::accessoryuid() const {
  return *accessoryuid_;
}
inline void RT_MS_Convolution::set_accessoryuid(const ::std::string& value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_Convolution::set_accessoryuid(const char* value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_Convolution::set_accessoryuid(const char* value, size_t size) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_accessoryuid() {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  return accessoryuid_;
}
inline ::std::string* RT_MS_Convolution::release_accessoryuid() {
  clear_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessoryuid_;
    accessoryuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeId = 34;
inline bool RT_MS_Convolution::has_wedgeid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RT_MS_Convolution::set_has_wedgeid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RT_MS_Convolution::clear_has_wedgeid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RT_MS_Convolution::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_Convolution::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_Convolution::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_Convolution::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_Convolution::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_Convolution::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 algType = 35;
inline bool RT_MS_Convolution::has_algtype() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RT_MS_Convolution::set_has_algtype() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RT_MS_Convolution::clear_has_algtype() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RT_MS_Convolution::clear_algtype() {
  algtype_ = 0;
  clear_has_algtype();
}
inline ::google::protobuf::int32 RT_MS_Convolution::algtype() const {
  return algtype_;
}
inline void RT_MS_Convolution::set_algtype(::google::protobuf::int32 value) {
  set_has_algtype();
  algtype_ = value;
}

// optional float pddMuBase = 36;
inline bool RT_MS_Convolution::has_pddmubase() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RT_MS_Convolution::set_has_pddmubase() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RT_MS_Convolution::clear_has_pddmubase() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RT_MS_Convolution::clear_pddmubase() {
  pddmubase_ = 0;
  clear_has_pddmubase();
}
inline float RT_MS_Convolution::pddmubase() const {
  return pddmubase_;
}
inline void RT_MS_Convolution::set_pddmubase(float value) {
  set_has_pddmubase();
  pddmubase_ = value;
}

// optional float pddDmumx = 37;
inline bool RT_MS_Convolution::has_pdddmumx() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void RT_MS_Convolution::set_has_pdddmumx() {
  _has_bits_[1] |= 0x00000010u;
}
inline void RT_MS_Convolution::clear_has_pdddmumx() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void RT_MS_Convolution::clear_pdddmumx() {
  pdddmumx_ = 0;
  clear_has_pdddmumx();
}
inline float RT_MS_Convolution::pdddmumx() const {
  return pdddmumx_;
}
inline void RT_MS_Convolution::set_pdddmumx(float value) {
  set_has_pdddmumx();
  pdddmumx_ = value;
}

// optional string mudatax = 38;
inline bool RT_MS_Convolution::has_mudatax() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void RT_MS_Convolution::set_has_mudatax() {
  _has_bits_[1] |= 0x00000020u;
}
inline void RT_MS_Convolution::clear_has_mudatax() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void RT_MS_Convolution::clear_mudatax() {
  if (mudatax_ != &::google::protobuf::internal::kEmptyString) {
    mudatax_->clear();
  }
  clear_has_mudatax();
}
inline const ::std::string& RT_MS_Convolution::mudatax() const {
  return *mudatax_;
}
inline void RT_MS_Convolution::set_mudatax(const ::std::string& value) {
  set_has_mudatax();
  if (mudatax_ == &::google::protobuf::internal::kEmptyString) {
    mudatax_ = new ::std::string;
  }
  mudatax_->assign(value);
}
inline void RT_MS_Convolution::set_mudatax(const char* value) {
  set_has_mudatax();
  if (mudatax_ == &::google::protobuf::internal::kEmptyString) {
    mudatax_ = new ::std::string;
  }
  mudatax_->assign(value);
}
inline void RT_MS_Convolution::set_mudatax(const char* value, size_t size) {
  set_has_mudatax();
  if (mudatax_ == &::google::protobuf::internal::kEmptyString) {
    mudatax_ = new ::std::string;
  }
  mudatax_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_mudatax() {
  set_has_mudatax();
  if (mudatax_ == &::google::protobuf::internal::kEmptyString) {
    mudatax_ = new ::std::string;
  }
  return mudatax_;
}
inline ::std::string* RT_MS_Convolution::release_mudatax() {
  clear_has_mudatax();
  if (mudatax_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mudatax_;
    mudatax_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ddmudr = 39;
inline bool RT_MS_Convolution::has_ddmudr() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void RT_MS_Convolution::set_has_ddmudr() {
  _has_bits_[1] |= 0x00000040u;
}
inline void RT_MS_Convolution::clear_has_ddmudr() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void RT_MS_Convolution::clear_ddmudr() {
  if (ddmudr_ != &::google::protobuf::internal::kEmptyString) {
    ddmudr_->clear();
  }
  clear_has_ddmudr();
}
inline const ::std::string& RT_MS_Convolution::ddmudr() const {
  return *ddmudr_;
}
inline void RT_MS_Convolution::set_ddmudr(const ::std::string& value) {
  set_has_ddmudr();
  if (ddmudr_ == &::google::protobuf::internal::kEmptyString) {
    ddmudr_ = new ::std::string;
  }
  ddmudr_->assign(value);
}
inline void RT_MS_Convolution::set_ddmudr(const char* value) {
  set_has_ddmudr();
  if (ddmudr_ == &::google::protobuf::internal::kEmptyString) {
    ddmudr_ = new ::std::string;
  }
  ddmudr_->assign(value);
}
inline void RT_MS_Convolution::set_ddmudr(const char* value, size_t size) {
  set_has_ddmudr();
  if (ddmudr_ == &::google::protobuf::internal::kEmptyString) {
    ddmudr_ = new ::std::string;
  }
  ddmudr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_ddmudr() {
  set_has_ddmudr();
  if (ddmudr_ == &::google::protobuf::internal::kEmptyString) {
    ddmudr_ = new ::std::string;
  }
  return ddmudr_;
}
inline ::std::string* RT_MS_Convolution::release_ddmudr() {
  clear_has_ddmudr();
  if (ddmudr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ddmudr_;
    ddmudr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string mudatay = 40;
inline bool RT_MS_Convolution::has_mudatay() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void RT_MS_Convolution::set_has_mudatay() {
  _has_bits_[1] |= 0x00000080u;
}
inline void RT_MS_Convolution::clear_has_mudatay() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void RT_MS_Convolution::clear_mudatay() {
  if (mudatay_ != &::google::protobuf::internal::kEmptyString) {
    mudatay_->clear();
  }
  clear_has_mudatay();
}
inline const ::std::string& RT_MS_Convolution::mudatay() const {
  return *mudatay_;
}
inline void RT_MS_Convolution::set_mudatay(const ::std::string& value) {
  set_has_mudatay();
  if (mudatay_ == &::google::protobuf::internal::kEmptyString) {
    mudatay_ = new ::std::string;
  }
  mudatay_->assign(value);
}
inline void RT_MS_Convolution::set_mudatay(const char* value) {
  set_has_mudatay();
  if (mudatay_ == &::google::protobuf::internal::kEmptyString) {
    mudatay_ = new ::std::string;
  }
  mudatay_->assign(value);
}
inline void RT_MS_Convolution::set_mudatay(const char* value, size_t size) {
  set_has_mudatay();
  if (mudatay_ == &::google::protobuf::internal::kEmptyString) {
    mudatay_ = new ::std::string;
  }
  mudatay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_mudatay() {
  set_has_mudatay();
  if (mudatay_ == &::google::protobuf::internal::kEmptyString) {
    mudatay_ = new ::std::string;
  }
  return mudatay_;
}
inline ::std::string* RT_MS_Convolution::release_mudatay() {
  clear_has_mudatay();
  if (mudatay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mudatay_;
    mudatay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string dmudatay = 41;
inline bool RT_MS_Convolution::has_dmudatay() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void RT_MS_Convolution::set_has_dmudatay() {
  _has_bits_[1] |= 0x00000100u;
}
inline void RT_MS_Convolution::clear_has_dmudatay() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void RT_MS_Convolution::clear_dmudatay() {
  if (dmudatay_ != &::google::protobuf::internal::kEmptyString) {
    dmudatay_->clear();
  }
  clear_has_dmudatay();
}
inline const ::std::string& RT_MS_Convolution::dmudatay() const {
  return *dmudatay_;
}
inline void RT_MS_Convolution::set_dmudatay(const ::std::string& value) {
  set_has_dmudatay();
  if (dmudatay_ == &::google::protobuf::internal::kEmptyString) {
    dmudatay_ = new ::std::string;
  }
  dmudatay_->assign(value);
}
inline void RT_MS_Convolution::set_dmudatay(const char* value) {
  set_has_dmudatay();
  if (dmudatay_ == &::google::protobuf::internal::kEmptyString) {
    dmudatay_ = new ::std::string;
  }
  dmudatay_->assign(value);
}
inline void RT_MS_Convolution::set_dmudatay(const char* value, size_t size) {
  set_has_dmudatay();
  if (dmudatay_ == &::google::protobuf::internal::kEmptyString) {
    dmudatay_ = new ::std::string;
  }
  dmudatay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_dmudatay() {
  set_has_dmudatay();
  if (dmudatay_ == &::google::protobuf::internal::kEmptyString) {
    dmudatay_ = new ::std::string;
  }
  return dmudatay_;
}
inline ::std::string* RT_MS_Convolution::release_dmudatay() {
  clear_has_dmudatay();
  if (dmudatay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dmudatay_;
    dmudatay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string outputmuy = 42;
inline bool RT_MS_Convolution::has_outputmuy() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void RT_MS_Convolution::set_has_outputmuy() {
  _has_bits_[1] |= 0x00000200u;
}
inline void RT_MS_Convolution::clear_has_outputmuy() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void RT_MS_Convolution::clear_outputmuy() {
  if (outputmuy_ != &::google::protobuf::internal::kEmptyString) {
    outputmuy_->clear();
  }
  clear_has_outputmuy();
}
inline const ::std::string& RT_MS_Convolution::outputmuy() const {
  return *outputmuy_;
}
inline void RT_MS_Convolution::set_outputmuy(const ::std::string& value) {
  set_has_outputmuy();
  if (outputmuy_ == &::google::protobuf::internal::kEmptyString) {
    outputmuy_ = new ::std::string;
  }
  outputmuy_->assign(value);
}
inline void RT_MS_Convolution::set_outputmuy(const char* value) {
  set_has_outputmuy();
  if (outputmuy_ == &::google::protobuf::internal::kEmptyString) {
    outputmuy_ = new ::std::string;
  }
  outputmuy_->assign(value);
}
inline void RT_MS_Convolution::set_outputmuy(const char* value, size_t size) {
  set_has_outputmuy();
  if (outputmuy_ == &::google::protobuf::internal::kEmptyString) {
    outputmuy_ = new ::std::string;
  }
  outputmuy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Convolution::mutable_outputmuy() {
  set_has_outputmuy();
  if (outputmuy_ == &::google::protobuf::internal::kEmptyString) {
    outputmuy_ = new ::std::string;
  }
  return outputmuy_;
}
inline ::std::string* RT_MS_Convolution::release_outputmuy() {
  clear_has_outputmuy();
  if (outputmuy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = outputmuy_;
    outputmuy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float dmudr = 43;
inline bool RT_MS_Convolution::has_dmudr() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void RT_MS_Convolution::set_has_dmudr() {
  _has_bits_[1] |= 0x00000400u;
}
inline void RT_MS_Convolution::clear_has_dmudr() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void RT_MS_Convolution::clear_dmudr() {
  dmudr_ = 0;
  clear_has_dmudr();
}
inline float RT_MS_Convolution::dmudr() const {
  return dmudr_;
}
inline void RT_MS_Convolution::set_dmudr(float value) {
  set_has_dmudr();
  dmudr_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PDDSpectrum

// optional string uid0 = 1;
inline bool RT_MS_PDDSpectrum::has_uid0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_uid0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PDDSpectrum::clear_has_uid0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PDDSpectrum::clear_uid0() {
  if (uid0_ != &::google::protobuf::internal::kEmptyString) {
    uid0_->clear();
  }
  clear_has_uid0();
}
inline const ::std::string& RT_MS_PDDSpectrum::uid0() const {
  return *uid0_;
}
inline void RT_MS_PDDSpectrum::set_uid0(const ::std::string& value) {
  set_has_uid0();
  if (uid0_ == &::google::protobuf::internal::kEmptyString) {
    uid0_ = new ::std::string;
  }
  uid0_->assign(value);
}
inline void RT_MS_PDDSpectrum::set_uid0(const char* value) {
  set_has_uid0();
  if (uid0_ == &::google::protobuf::internal::kEmptyString) {
    uid0_ = new ::std::string;
  }
  uid0_->assign(value);
}
inline void RT_MS_PDDSpectrum::set_uid0(const char* value, size_t size) {
  set_has_uid0();
  if (uid0_ == &::google::protobuf::internal::kEmptyString) {
    uid0_ = new ::std::string;
  }
  uid0_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PDDSpectrum::mutable_uid0() {
  set_has_uid0();
  if (uid0_ == &::google::protobuf::internal::kEmptyString) {
    uid0_ = new ::std::string;
  }
  return uid0_;
}
inline ::std::string* RT_MS_PDDSpectrum::release_uid0() {
  clear_has_uid0();
  if (uid0_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid0_;
    uid0_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid40 = 2;
inline bool RT_MS_PDDSpectrum::has_uid40() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_uid40() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PDDSpectrum::clear_has_uid40() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PDDSpectrum::clear_uid40() {
  if (uid40_ != &::google::protobuf::internal::kEmptyString) {
    uid40_->clear();
  }
  clear_has_uid40();
}
inline const ::std::string& RT_MS_PDDSpectrum::uid40() const {
  return *uid40_;
}
inline void RT_MS_PDDSpectrum::set_uid40(const ::std::string& value) {
  set_has_uid40();
  if (uid40_ == &::google::protobuf::internal::kEmptyString) {
    uid40_ = new ::std::string;
  }
  uid40_->assign(value);
}
inline void RT_MS_PDDSpectrum::set_uid40(const char* value) {
  set_has_uid40();
  if (uid40_ == &::google::protobuf::internal::kEmptyString) {
    uid40_ = new ::std::string;
  }
  uid40_->assign(value);
}
inline void RT_MS_PDDSpectrum::set_uid40(const char* value, size_t size) {
  set_has_uid40();
  if (uid40_ == &::google::protobuf::internal::kEmptyString) {
    uid40_ = new ::std::string;
  }
  uid40_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PDDSpectrum::mutable_uid40() {
  set_has_uid40();
  if (uid40_ == &::google::protobuf::internal::kEmptyString) {
    uid40_ = new ::std::string;
  }
  return uid40_;
}
inline ::std::string* RT_MS_PDDSpectrum::release_uid40() {
  clear_has_uid40();
  if (uid40_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid40_;
    uid40_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 energy0 = 3;
inline bool RT_MS_PDDSpectrum::has_energy0() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_energy0() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PDDSpectrum::clear_has_energy0() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PDDSpectrum::clear_energy0() {
  energy0_ = 0;
  clear_has_energy0();
}
inline ::google::protobuf::int32 RT_MS_PDDSpectrum::energy0() const {
  return energy0_;
}
inline void RT_MS_PDDSpectrum::set_energy0(::google::protobuf::int32 value) {
  set_has_energy0();
  energy0_ = value;
}

// optional int32 energy40 = 4;
inline bool RT_MS_PDDSpectrum::has_energy40() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_energy40() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_PDDSpectrum::clear_has_energy40() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_PDDSpectrum::clear_energy40() {
  energy40_ = 0;
  clear_has_energy40();
}
inline ::google::protobuf::int32 RT_MS_PDDSpectrum::energy40() const {
  return energy40_;
}
inline void RT_MS_PDDSpectrum::set_energy40(::google::protobuf::int32 value) {
  set_has_energy40();
  energy40_ = value;
}

// optional float kernelWeight0 = 5;
inline bool RT_MS_PDDSpectrum::has_kernelweight0() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_kernelweight0() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_PDDSpectrum::clear_has_kernelweight0() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_PDDSpectrum::clear_kernelweight0() {
  kernelweight0_ = 0;
  clear_has_kernelweight0();
}
inline float RT_MS_PDDSpectrum::kernelweight0() const {
  return kernelweight0_;
}
inline void RT_MS_PDDSpectrum::set_kernelweight0(float value) {
  set_has_kernelweight0();
  kernelweight0_ = value;
}

// optional float kernelWeight40 = 6;
inline bool RT_MS_PDDSpectrum::has_kernelweight40() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_kernelweight40() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_PDDSpectrum::clear_has_kernelweight40() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_PDDSpectrum::clear_kernelweight40() {
  kernelweight40_ = 0;
  clear_has_kernelweight40();
}
inline float RT_MS_PDDSpectrum::kernelweight40() const {
  return kernelweight40_;
}
inline void RT_MS_PDDSpectrum::set_kernelweight40(float value) {
  set_has_kernelweight40();
  kernelweight40_ = value;
}

// optional int32 fieldSize = 7;
inline bool RT_MS_PDDSpectrum::has_fieldsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_PDDSpectrum::set_has_fieldsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_PDDSpectrum::clear_has_fieldsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_PDDSpectrum::clear_fieldsize() {
  fieldsize_ = 0;
  clear_has_fieldsize();
}
inline ::google::protobuf::int32 RT_MS_PDDSpectrum::fieldsize() const {
  return fieldsize_;
}
inline void RT_MS_PDDSpectrum::set_fieldsize(::google::protobuf::int32 value) {
  set_has_fieldsize();
  fieldsize_ = value;
}

// -------------------------------------------------------------------

// RT_MS_InFieldOffaxisVector

// optional string uid = 1;
inline bool RT_MS_InFieldOffaxisVector::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_InFieldOffaxisVector::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_InFieldOffaxisVector::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_InFieldOffaxisVector::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_InFieldOffaxisVector::uid() const {
  return *uid_;
}
inline void RT_MS_InFieldOffaxisVector::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_InFieldOffaxisVector::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_InFieldOffaxisVector::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_InFieldOffaxisVector::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_InFieldOffaxisVector::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float radius = 2;
inline bool RT_MS_InFieldOffaxisVector::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_InFieldOffaxisVector::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_InFieldOffaxisVector::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_InFieldOffaxisVector::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float RT_MS_InFieldOffaxisVector::radius() const {
  return radius_;
}
inline void RT_MS_InFieldOffaxisVector::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float offaxisRatio = 3;
inline bool RT_MS_InFieldOffaxisVector::has_offaxisratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_InFieldOffaxisVector::set_has_offaxisratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_InFieldOffaxisVector::clear_has_offaxisratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_InFieldOffaxisVector::clear_offaxisratio() {
  offaxisratio_ = 0;
  clear_has_offaxisratio();
}
inline float RT_MS_InFieldOffaxisVector::offaxisratio() const {
  return offaxisratio_;
}
inline void RT_MS_InFieldOffaxisVector::set_offaxisratio(float value) {
  set_has_offaxisratio();
  offaxisratio_ = value;
}

// -------------------------------------------------------------------

// RT_MS_ConvolutionContourVerter

// optional string uid = 1;
inline bool RT_MS_ConvolutionContourVerter::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_ConvolutionContourVerter::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_ConvolutionContourVerter::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_ConvolutionContourVerter::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_ConvolutionContourVerter::uid() const {
  return *uid_;
}
inline void RT_MS_ConvolutionContourVerter::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_ConvolutionContourVerter::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_ConvolutionContourVerter::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_ConvolutionContourVerter::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_ConvolutionContourVerter::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float ContourVerterx = 2;
inline bool RT_MS_ConvolutionContourVerter::has_contourverterx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_ConvolutionContourVerter::set_has_contourverterx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_ConvolutionContourVerter::clear_has_contourverterx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_ConvolutionContourVerter::clear_contourverterx() {
  contourverterx_ = 0;
  clear_has_contourverterx();
}
inline float RT_MS_ConvolutionContourVerter::contourverterx() const {
  return contourverterx_;
}
inline void RT_MS_ConvolutionContourVerter::set_contourverterx(float value) {
  set_has_contourverterx();
  contourverterx_ = value;
}

// optional float ContourVertery = 3;
inline bool RT_MS_ConvolutionContourVerter::has_contourvertery() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_ConvolutionContourVerter::set_has_contourvertery() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_ConvolutionContourVerter::clear_has_contourvertery() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_ConvolutionContourVerter::clear_contourvertery() {
  contourvertery_ = 0;
  clear_has_contourvertery();
}
inline float RT_MS_ConvolutionContourVerter::contourvertery() const {
  return contourvertery_;
}
inline void RT_MS_ConvolutionContourVerter::set_contourvertery(float value) {
  set_has_contourvertery();
  contourvertery_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PhysicalWedgeField

// optional string wedgeUID = 1;
inline bool RT_MS_PhysicalWedgeField::has_wedgeuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_wedgeuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_wedgeuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PhysicalWedgeField::clear_wedgeuid() {
  if (wedgeuid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeuid_->clear();
  }
  clear_has_wedgeuid();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::wedgeuid() const {
  return *wedgeuid_;
}
inline void RT_MS_PhysicalWedgeField::set_wedgeuid(const ::std::string& value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgeuid(const char* value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgeuid(const char* value, size_t size) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_wedgeuid() {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  return wedgeuid_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_wedgeuid() {
  clear_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeuid_;
    wedgeuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeId = 2;
inline bool RT_MS_PhysicalWedgeField::has_wedgeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_wedgeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_wedgeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PhysicalWedgeField::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_PhysicalWedgeField::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeType = 3;
inline bool RT_MS_PhysicalWedgeField::has_wedgetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_wedgetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_wedgetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PhysicalWedgeField::clear_wedgetype() {
  if (wedgetype_ != &::google::protobuf::internal::kEmptyString) {
    wedgetype_->clear();
  }
  clear_has_wedgetype();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::wedgetype() const {
  return *wedgetype_;
}
inline void RT_MS_PhysicalWedgeField::set_wedgetype(const ::std::string& value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgetype(const char* value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_wedgetype(const char* value, size_t size) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_wedgetype() {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  return wedgetype_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_wedgetype() {
  clear_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgetype_;
    wedgetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float mu = 4;
inline bool RT_MS_PhysicalWedgeField::has_mu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_mu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_mu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_PhysicalWedgeField::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline float RT_MS_PhysicalWedgeField::mu() const {
  return mu_;
}
inline void RT_MS_PhysicalWedgeField::set_mu(float value) {
  set_has_mu();
  mu_ = value;
}

// optional float dmudx = 5;
inline bool RT_MS_PhysicalWedgeField::has_dmudx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_dmudx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_dmudx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_PhysicalWedgeField::clear_dmudx() {
  dmudx_ = 0;
  clear_has_dmudx();
}
inline float RT_MS_PhysicalWedgeField::dmudx() const {
  return dmudx_;
}
inline void RT_MS_PhysicalWedgeField::set_dmudx(float value) {
  set_has_dmudx();
  dmudx_ = value;
}

// optional float dmudr = 6;
inline bool RT_MS_PhysicalWedgeField::has_dmudr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_dmudr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_dmudr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_PhysicalWedgeField::clear_dmudr() {
  dmudr_ = 0;
  clear_has_dmudr();
}
inline float RT_MS_PhysicalWedgeField::dmudr() const {
  return dmudr_;
}
inline void RT_MS_PhysicalWedgeField::set_dmudr(float value) {
  set_has_dmudr();
  dmudr_ = value;
}

// optional float dmuda = 7;
inline bool RT_MS_PhysicalWedgeField::has_dmuda() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_dmuda() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_dmuda() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_PhysicalWedgeField::clear_dmuda() {
  dmuda_ = 0;
  clear_has_dmuda();
}
inline float RT_MS_PhysicalWedgeField::dmuda() const {
  return dmuda_;
}
inline void RT_MS_PhysicalWedgeField::set_dmuda(float value) {
  set_has_dmuda();
  dmuda_ = value;
}

// optional float hvlSlope = 8;
inline bool RT_MS_PhysicalWedgeField::has_hvlslope() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_hvlslope() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_hvlslope() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_PhysicalWedgeField::clear_hvlslope() {
  hvlslope_ = 0;
  clear_has_hvlslope();
}
inline float RT_MS_PhysicalWedgeField::hvlslope() const {
  return hvlslope_;
}
inline void RT_MS_PhysicalWedgeField::set_hvlslope(float value) {
  set_has_hvlslope();
  hvlslope_ = value;
}

// optional string CarrierUDI = 9;
inline bool RT_MS_PhysicalWedgeField::has_carrierudi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierudi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierudi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierudi() {
  if (carrierudi_ != &::google::protobuf::internal::kEmptyString) {
    carrierudi_->clear();
  }
  clear_has_carrierudi();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::carrierudi() const {
  return *carrierudi_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierudi(const ::std::string& value) {
  set_has_carrierudi();
  if (carrierudi_ == &::google::protobuf::internal::kEmptyString) {
    carrierudi_ = new ::std::string;
  }
  carrierudi_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_carrierudi(const char* value) {
  set_has_carrierudi();
  if (carrierudi_ == &::google::protobuf::internal::kEmptyString) {
    carrierudi_ = new ::std::string;
  }
  carrierudi_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_carrierudi(const char* value, size_t size) {
  set_has_carrierudi();
  if (carrierudi_ == &::google::protobuf::internal::kEmptyString) {
    carrierudi_ = new ::std::string;
  }
  carrierudi_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_carrierudi() {
  set_has_carrierudi();
  if (carrierudi_ == &::google::protobuf::internal::kEmptyString) {
    carrierudi_ = new ::std::string;
  }
  return carrierudi_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_carrierudi() {
  clear_has_carrierudi();
  if (carrierudi_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carrierudi_;
    carrierudi_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float Carriermu = 10;
inline bool RT_MS_PhysicalWedgeField::has_carriermu() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carriermu() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carriermu() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_PhysicalWedgeField::clear_carriermu() {
  carriermu_ = 0;
  clear_has_carriermu();
}
inline float RT_MS_PhysicalWedgeField::carriermu() const {
  return carriermu_;
}
inline void RT_MS_PhysicalWedgeField::set_carriermu(float value) {
  set_has_carriermu();
  carriermu_ = value;
}

// optional float Carrierdmudx = 11;
inline bool RT_MS_PhysicalWedgeField::has_carrierdmudx() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierdmudx() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierdmudx() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierdmudx() {
  carrierdmudx_ = 0;
  clear_has_carrierdmudx();
}
inline float RT_MS_PhysicalWedgeField::carrierdmudx() const {
  return carrierdmudx_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierdmudx(float value) {
  set_has_carrierdmudx();
  carrierdmudx_ = value;
}

// optional float Carrierdmudr = 12;
inline bool RT_MS_PhysicalWedgeField::has_carrierdmudr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierdmudr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierdmudr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierdmudr() {
  carrierdmudr_ = 0;
  clear_has_carrierdmudr();
}
inline float RT_MS_PhysicalWedgeField::carrierdmudr() const {
  return carrierdmudr_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierdmudr(float value) {
  set_has_carrierdmudr();
  carrierdmudr_ = value;
}

// optional float Carrierdmuda = 13;
inline bool RT_MS_PhysicalWedgeField::has_carrierdmuda() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierdmuda() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierdmuda() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierdmuda() {
  carrierdmuda_ = 0;
  clear_has_carrierdmuda();
}
inline float RT_MS_PhysicalWedgeField::carrierdmuda() const {
  return carrierdmuda_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierdmuda(float value) {
  set_has_carrierdmuda();
  carrierdmuda_ = value;
}

// optional float CarrierhvlSlope = 14;
inline bool RT_MS_PhysicalWedgeField::has_carrierhvlslope() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierhvlslope() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierhvlslope() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierhvlslope() {
  carrierhvlslope_ = 0;
  clear_has_carrierhvlslope();
}
inline float RT_MS_PhysicalWedgeField::carrierhvlslope() const {
  return carrierhvlslope_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierhvlslope(float value) {
  set_has_carrierhvlslope();
  carrierhvlslope_ = value;
}

// optional float wedgeThick = 15;
inline bool RT_MS_PhysicalWedgeField::has_wedgethick() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_wedgethick() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_wedgethick() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_PhysicalWedgeField::clear_wedgethick() {
  wedgethick_ = 0;
  clear_has_wedgethick();
}
inline float RT_MS_PhysicalWedgeField::wedgethick() const {
  return wedgethick_;
}
inline void RT_MS_PhysicalWedgeField::set_wedgethick(float value) {
  set_has_wedgethick();
  wedgethick_ = value;
}

// optional float carrierThick = 16;
inline bool RT_MS_PhysicalWedgeField::has_carrierthick() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_carrierthick() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_carrierthick() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_PhysicalWedgeField::clear_carrierthick() {
  carrierthick_ = 0;
  clear_has_carrierthick();
}
inline float RT_MS_PhysicalWedgeField::carrierthick() const {
  return carrierthick_;
}
inline void RT_MS_PhysicalWedgeField::set_carrierthick(float value) {
  set_has_carrierthick();
  carrierthick_ = value;
}

// repeated .ms.proto.RT_MS_ConvolutionContourVerter weightContourVerterList = 17;
inline int RT_MS_PhysicalWedgeField::weightcontourverterlist_size() const {
  return weightcontourverterlist_.size();
}
inline void RT_MS_PhysicalWedgeField::clear_weightcontourverterlist() {
  weightcontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_ConvolutionContourVerter& RT_MS_PhysicalWedgeField::weightcontourverterlist(int index) const {
  return weightcontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_ConvolutionContourVerter* RT_MS_PhysicalWedgeField::mutable_weightcontourverterlist(int index) {
  return weightcontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_ConvolutionContourVerter* RT_MS_PhysicalWedgeField::add_weightcontourverterlist() {
  return weightcontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >&
RT_MS_PhysicalWedgeField::weightcontourverterlist() const {
  return weightcontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >*
RT_MS_PhysicalWedgeField::mutable_weightcontourverterlist() {
  return &weightcontourverterlist_;
}

// repeated .ms.proto.RT_MS_ConvolutionContourVerter carrierContourVerterList = 18;
inline int RT_MS_PhysicalWedgeField::carriercontourverterlist_size() const {
  return carriercontourverterlist_.size();
}
inline void RT_MS_PhysicalWedgeField::clear_carriercontourverterlist() {
  carriercontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_ConvolutionContourVerter& RT_MS_PhysicalWedgeField::carriercontourverterlist(int index) const {
  return carriercontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_ConvolutionContourVerter* RT_MS_PhysicalWedgeField::mutable_carriercontourverterlist(int index) {
  return carriercontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_ConvolutionContourVerter* RT_MS_PhysicalWedgeField::add_carriercontourverterlist() {
  return carriercontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >&
RT_MS_PhysicalWedgeField::carriercontourverterlist() const {
  return carriercontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ConvolutionContourVerter >*
RT_MS_PhysicalWedgeField::mutable_carriercontourverterlist() {
  return &carriercontourverterlist_;
}

// optional string contourUID1 = 19;
inline bool RT_MS_PhysicalWedgeField::has_contouruid1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_contouruid1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_contouruid1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_PhysicalWedgeField::clear_contouruid1() {
  if (contouruid1_ != &::google::protobuf::internal::kEmptyString) {
    contouruid1_->clear();
  }
  clear_has_contouruid1();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::contouruid1() const {
  return *contouruid1_;
}
inline void RT_MS_PhysicalWedgeField::set_contouruid1(const ::std::string& value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_contouruid1(const char* value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_contouruid1(const char* value, size_t size) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_contouruid1() {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  return contouruid1_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_contouruid1() {
  clear_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid1_;
    contouruid1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contourUID2 = 20;
inline bool RT_MS_PhysicalWedgeField::has_contouruid2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_contouruid2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_contouruid2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_PhysicalWedgeField::clear_contouruid2() {
  if (contouruid2_ != &::google::protobuf::internal::kEmptyString) {
    contouruid2_->clear();
  }
  clear_has_contouruid2();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::contouruid2() const {
  return *contouruid2_;
}
inline void RT_MS_PhysicalWedgeField::set_contouruid2(const ::std::string& value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_contouruid2(const char* value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_contouruid2(const char* value, size_t size) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_contouruid2() {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  return contouruid2_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_contouruid2() {
  clear_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid2_;
    contouruid2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string parentUID = 21;
inline bool RT_MS_PhysicalWedgeField::has_parentuid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_parentuid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_parentuid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_PhysicalWedgeField::clear_parentuid() {
  if (parentuid_ != &::google::protobuf::internal::kEmptyString) {
    parentuid_->clear();
  }
  clear_has_parentuid();
}
inline const ::std::string& RT_MS_PhysicalWedgeField::parentuid() const {
  return *parentuid_;
}
inline void RT_MS_PhysicalWedgeField::set_parentuid(const ::std::string& value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_parentuid(const char* value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_PhysicalWedgeField::set_parentuid(const char* value, size_t size) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PhysicalWedgeField::mutable_parentuid() {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  return parentuid_;
}
inline ::std::string* RT_MS_PhysicalWedgeField::release_parentuid() {
  clear_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentuid_;
    parentuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 algType = 22;
inline bool RT_MS_PhysicalWedgeField::has_algtype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_algtype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_algtype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_PhysicalWedgeField::clear_algtype() {
  algtype_ = 0;
  clear_has_algtype();
}
inline ::google::protobuf::int32 RT_MS_PhysicalWedgeField::algtype() const {
  return algtype_;
}
inline void RT_MS_PhysicalWedgeField::set_algtype(::google::protobuf::int32 value) {
  set_has_algtype();
  algtype_ = value;
}

// optional float density = 23;
inline bool RT_MS_PhysicalWedgeField::has_density() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_PhysicalWedgeField::set_has_density() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_PhysicalWedgeField::clear_has_density() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_PhysicalWedgeField::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float RT_MS_PhysicalWedgeField::density() const {
  return density_;
}
inline void RT_MS_PhysicalWedgeField::set_density(float value) {
  set_has_density();
  density_ = value;
}

// -------------------------------------------------------------------

// RtTpsProtoRepeatedPhysicalWedgeField

// repeated .ms.proto.RT_MS_PhysicalWedgeField physicalwedgefieldlist = 1;
inline int RtTpsProtoRepeatedPhysicalWedgeField::physicalwedgefieldlist_size() const {
  return physicalwedgefieldlist_.size();
}
inline void RtTpsProtoRepeatedPhysicalWedgeField::clear_physicalwedgefieldlist() {
  physicalwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_PhysicalWedgeField& RtTpsProtoRepeatedPhysicalWedgeField::physicalwedgefieldlist(int index) const {
  return physicalwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_PhysicalWedgeField* RtTpsProtoRepeatedPhysicalWedgeField::mutable_physicalwedgefieldlist(int index) {
  return physicalwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PhysicalWedgeField* RtTpsProtoRepeatedPhysicalWedgeField::add_physicalwedgefieldlist() {
  return physicalwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >&
RtTpsProtoRepeatedPhysicalWedgeField::physicalwedgefieldlist() const {
  return physicalwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PhysicalWedgeField >*
RtTpsProtoRepeatedPhysicalWedgeField::mutable_physicalwedgefieldlist() {
  return &physicalwedgefieldlist_;
}

// -------------------------------------------------------------------

// RT_MS_VirtualWedgeInfo

// optional string parentUID = 1;
inline bool RT_MS_VirtualWedgeInfo::has_parentuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_VirtualWedgeInfo::set_has_parentuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_VirtualWedgeInfo::clear_has_parentuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_VirtualWedgeInfo::clear_parentuid() {
  if (parentuid_ != &::google::protobuf::internal::kEmptyString) {
    parentuid_->clear();
  }
  clear_has_parentuid();
}
inline const ::std::string& RT_MS_VirtualWedgeInfo::parentuid() const {
  return *parentuid_;
}
inline void RT_MS_VirtualWedgeInfo::set_parentuid(const ::std::string& value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_parentuid(const char* value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_parentuid(const char* value, size_t size) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_VirtualWedgeInfo::mutable_parentuid() {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  return parentuid_;
}
inline ::std::string* RT_MS_VirtualWedgeInfo::release_parentuid() {
  clear_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentuid_;
    parentuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string virtualUid = 2;
inline bool RT_MS_VirtualWedgeInfo::has_virtualuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_VirtualWedgeInfo::set_has_virtualuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_VirtualWedgeInfo::clear_has_virtualuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_VirtualWedgeInfo::clear_virtualuid() {
  if (virtualuid_ != &::google::protobuf::internal::kEmptyString) {
    virtualuid_->clear();
  }
  clear_has_virtualuid();
}
inline const ::std::string& RT_MS_VirtualWedgeInfo::virtualuid() const {
  return *virtualuid_;
}
inline void RT_MS_VirtualWedgeInfo::set_virtualuid(const ::std::string& value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_virtualuid(const char* value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_virtualuid(const char* value, size_t size) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_VirtualWedgeInfo::mutable_virtualuid() {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  return virtualuid_;
}
inline ::std::string* RT_MS_VirtualWedgeInfo::release_virtualuid() {
  clear_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = virtualuid_;
    virtualuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string goldenUID = 3;
inline bool RT_MS_VirtualWedgeInfo::has_goldenuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_VirtualWedgeInfo::set_has_goldenuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_VirtualWedgeInfo::clear_has_goldenuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_VirtualWedgeInfo::clear_goldenuid() {
  if (goldenuid_ != &::google::protobuf::internal::kEmptyString) {
    goldenuid_->clear();
  }
  clear_has_goldenuid();
}
inline const ::std::string& RT_MS_VirtualWedgeInfo::goldenuid() const {
  return *goldenuid_;
}
inline void RT_MS_VirtualWedgeInfo::set_goldenuid(const ::std::string& value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_goldenuid(const char* value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_VirtualWedgeInfo::set_goldenuid(const char* value, size_t size) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_VirtualWedgeInfo::mutable_goldenuid() {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  return goldenuid_;
}
inline ::std::string* RT_MS_VirtualWedgeInfo::release_goldenuid() {
  clear_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = goldenuid_;
    goldenuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ms.proto.RT_MS_VirtualWedgeField virtualWedgeFieldList = 4;
inline int RT_MS_VirtualWedgeInfo::virtualwedgefieldlist_size() const {
  return virtualwedgefieldlist_.size();
}
inline void RT_MS_VirtualWedgeInfo::clear_virtualwedgefieldlist() {
  virtualwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_VirtualWedgeField& RT_MS_VirtualWedgeInfo::virtualwedgefieldlist(int index) const {
  return virtualwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeField* RT_MS_VirtualWedgeInfo::mutable_virtualwedgefieldlist(int index) {
  return virtualwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeField* RT_MS_VirtualWedgeInfo::add_virtualwedgefieldlist() {
  return virtualwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeField >&
RT_MS_VirtualWedgeInfo::virtualwedgefieldlist() const {
  return virtualwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeField >*
RT_MS_VirtualWedgeInfo::mutable_virtualwedgefieldlist() {
  return &virtualwedgefieldlist_;
}

// optional int32 algType = 5;
inline bool RT_MS_VirtualWedgeInfo::has_algtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_VirtualWedgeInfo::set_has_algtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_VirtualWedgeInfo::clear_has_algtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_VirtualWedgeInfo::clear_algtype() {
  algtype_ = 0;
  clear_has_algtype();
}
inline ::google::protobuf::int32 RT_MS_VirtualWedgeInfo::algtype() const {
  return algtype_;
}
inline void RT_MS_VirtualWedgeInfo::set_algtype(::google::protobuf::int32 value) {
  set_has_algtype();
  algtype_ = value;
}

// -------------------------------------------------------------------

// RtTpsProtoRepeatedVirtualWedgeInfo

// repeated .ms.proto.RT_MS_VirtualWedgeInfo virtualwedgeinfolist = 1;
inline int RtTpsProtoRepeatedVirtualWedgeInfo::virtualwedgeinfolist_size() const {
  return virtualwedgeinfolist_.size();
}
inline void RtTpsProtoRepeatedVirtualWedgeInfo::clear_virtualwedgeinfolist() {
  virtualwedgeinfolist_.Clear();
}
inline const ::ms::proto::RT_MS_VirtualWedgeInfo& RtTpsProtoRepeatedVirtualWedgeInfo::virtualwedgeinfolist(int index) const {
  return virtualwedgeinfolist_.Get(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeInfo* RtTpsProtoRepeatedVirtualWedgeInfo::mutable_virtualwedgeinfolist(int index) {
  return virtualwedgeinfolist_.Mutable(index);
}
inline ::ms::proto::RT_MS_VirtualWedgeInfo* RtTpsProtoRepeatedVirtualWedgeInfo::add_virtualwedgeinfolist() {
  return virtualwedgeinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >&
RtTpsProtoRepeatedVirtualWedgeInfo::virtualwedgeinfolist() const {
  return virtualwedgeinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_VirtualWedgeInfo >*
RtTpsProtoRepeatedVirtualWedgeInfo::mutable_virtualwedgeinfolist() {
  return &virtualwedgeinfolist_;
}

// -------------------------------------------------------------------

// RT_MS_VirtualWedgeField

// optional string uid = 1;
inline bool RT_MS_VirtualWedgeField::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_VirtualWedgeField::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_VirtualWedgeField::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_VirtualWedgeField::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_VirtualWedgeField::uid() const {
  return *uid_;
}
inline void RT_MS_VirtualWedgeField::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_VirtualWedgeField::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_VirtualWedgeField::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_VirtualWedgeField::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_VirtualWedgeField::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float collimatorX1Position = 2;
inline bool RT_MS_VirtualWedgeField::has_collimatorx1position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_VirtualWedgeField::set_has_collimatorx1position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_VirtualWedgeField::clear_has_collimatorx1position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_VirtualWedgeField::clear_collimatorx1position() {
  collimatorx1position_ = 0;
  clear_has_collimatorx1position();
}
inline float RT_MS_VirtualWedgeField::collimatorx1position() const {
  return collimatorx1position_;
}
inline void RT_MS_VirtualWedgeField::set_collimatorx1position(float value) {
  set_has_collimatorx1position();
  collimatorx1position_ = value;
}

// optional float collimatorX2Position = 3;
inline bool RT_MS_VirtualWedgeField::has_collimatorx2position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_VirtualWedgeField::set_has_collimatorx2position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_VirtualWedgeField::clear_has_collimatorx2position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_VirtualWedgeField::clear_collimatorx2position() {
  collimatorx2position_ = 0;
  clear_has_collimatorx2position();
}
inline float RT_MS_VirtualWedgeField::collimatorx2position() const {
  return collimatorx2position_;
}
inline void RT_MS_VirtualWedgeField::set_collimatorx2position(float value) {
  set_has_collimatorx2position();
  collimatorx2position_ = value;
}

// optional float relativeMU = 4;
inline bool RT_MS_VirtualWedgeField::has_relativemu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_VirtualWedgeField::set_has_relativemu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_VirtualWedgeField::clear_has_relativemu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_VirtualWedgeField::clear_relativemu() {
  relativemu_ = 0;
  clear_has_relativemu();
}
inline float RT_MS_VirtualWedgeField::relativemu() const {
  return relativemu_;
}
inline void RT_MS_VirtualWedgeField::set_relativemu(float value) {
  set_has_relativemu();
  relativemu_ = value;
}

// optional float correctionFactor = 5;
inline bool RT_MS_VirtualWedgeField::has_correctionfactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_VirtualWedgeField::set_has_correctionfactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_VirtualWedgeField::clear_has_correctionfactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_VirtualWedgeField::clear_correctionfactor() {
  correctionfactor_ = 0;
  clear_has_correctionfactor();
}
inline float RT_MS_VirtualWedgeField::correctionfactor() const {
  return correctionfactor_;
}
inline void RT_MS_VirtualWedgeField::set_correctionfactor(float value) {
  set_has_correctionfactor();
  correctionfactor_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace ms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5fms_5fconvolution_2eproto__INCLUDED
