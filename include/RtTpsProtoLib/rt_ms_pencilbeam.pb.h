// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_ms_pencilbeam.proto

#ifndef PROTOBUF_rt_5fms_5fpencilbeam_2eproto__INCLUDED
#define PROTOBUF_rt_5fms_5fpencilbeam_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ms {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();

class RT_MS_PencilBeam;
class RT_MS_PencilPDDTMR;
class RT_MS_PencilBeamPhysicalWedgeField;
class RT_MS_PencilContourVerter;
class RT_MS_PencilBeamVirtualWedgeInfo;
class RT_MS_PencilVirtualWedgeField;

// ===================================================================

class RT_MS_PencilBeam : public ::google::protobuf::Message {
 public:
  RT_MS_PencilBeam();
  virtual ~RT_MS_PencilBeam();
  
  RT_MS_PencilBeam(const RT_MS_PencilBeam& from);
  
  inline RT_MS_PencilBeam& operator=(const RT_MS_PencilBeam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilBeam& default_instance();
  
  void Swap(RT_MS_PencilBeam* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilBeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilBeam& from);
  void MergeFrom(const RT_MS_PencilBeam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float diamOne = 1;
  inline bool has_diamone() const;
  inline void clear_diamone();
  static const int kDiamOneFieldNumber = 1;
  inline float diamone() const;
  inline void set_diamone(float value);
  
  // optional float diamTwo = 2;
  inline bool has_diamtwo() const;
  inline void clear_diamtwo();
  static const int kDiamTwoFieldNumber = 2;
  inline float diamtwo() const;
  inline void set_diamtwo(float value);
  
  // optional float srcRatio = 3;
  inline bool has_srcratio() const;
  inline void clear_srcratio();
  static const int kSrcRatioFieldNumber = 3;
  inline float srcratio() const;
  inline void set_srcratio(float value);
  
  // optional float transmission = 4;
  inline bool has_transmission() const;
  inline void clear_transmission();
  static const int kTransmissionFieldNumber = 4;
  inline float transmission() const;
  inline void set_transmission(float value);
  
  // optional float psd = 5;
  inline bool has_psd() const;
  inline void clear_psd();
  static const int kPsdFieldNumber = 5;
  inline float psd() const;
  inline void set_psd(float value);
  
  // optional float sddXJaw = 6;
  inline bool has_sddxjaw() const;
  inline void clear_sddxjaw();
  static const int kSddXJawFieldNumber = 6;
  inline float sddxjaw() const;
  inline void set_sddxjaw(float value);
  
  // optional float sddYJaw = 7;
  inline bool has_sddyjaw() const;
  inline void clear_sddyjaw();
  static const int kSddYJawFieldNumber = 7;
  inline float sddyjaw() const;
  inline void set_sddyjaw(float value);
  
  // optional float xk0 = 8;
  inline bool has_xk0() const;
  inline void clear_xk0();
  static const int kXk0FieldNumber = 8;
  inline float xk0() const;
  inline void set_xk0(float value);
  
  // optional float xk1 = 9;
  inline bool has_xk1() const;
  inline void clear_xk1();
  static const int kXk1FieldNumber = 9;
  inline float xk1() const;
  inline void set_xk1(float value);
  
  // optional float xk2 = 10;
  inline bool has_xk2() const;
  inline void clear_xk2();
  static const int kXk2FieldNumber = 10;
  inline float xk2() const;
  inline void set_xk2(float value);
  
  // optional float yk0 = 11;
  inline bool has_yk0() const;
  inline void clear_yk0();
  static const int kYk0FieldNumber = 11;
  inline float yk0() const;
  inline void set_yk0(float value);
  
  // optional float yk1 = 12;
  inline bool has_yk1() const;
  inline void clear_yk1();
  static const int kYk1FieldNumber = 12;
  inline float yk1() const;
  inline void set_yk1(float value);
  
  // optional float yk2 = 13;
  inline bool has_yk2() const;
  inline void clear_yk2();
  static const int kYk2FieldNumber = 13;
  inline float yk2() const;
  inline void set_yk2(float value);
  
  // repeated .ms.proto.RT_MS_PencilPDDTMR tMRListList = 14;
  inline int tmrlistlist_size() const;
  inline void clear_tmrlistlist();
  static const int kTMRListListFieldNumber = 14;
  inline const ::ms::proto::RT_MS_PencilPDDTMR& tmrlistlist(int index) const;
  inline ::ms::proto::RT_MS_PencilPDDTMR* mutable_tmrlistlist(int index);
  inline ::ms::proto::RT_MS_PencilPDDTMR* add_tmrlistlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilPDDTMR >&
      tmrlistlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilPDDTMR >*
      mutable_tmrlistlist();
  
  // repeated .ms.proto.RT_MS_PencilBeamPhysicalWedgeField physicalWedgeFieldList = 15;
  inline int physicalwedgefieldlist_size() const;
  inline void clear_physicalwedgefieldlist();
  static const int kPhysicalWedgeFieldListFieldNumber = 15;
  inline const ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField& physicalwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField* mutable_physicalwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField* add_physicalwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField >&
      physicalwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField >*
      mutable_physicalwedgefieldlist();
  
  // repeated .ms.proto.RT_MS_PencilBeamVirtualWedgeInfo virtualWedgeInfoList = 16;
  inline int virtualwedgeinfolist_size() const;
  inline void clear_virtualwedgeinfolist();
  static const int kVirtualWedgeInfoListFieldNumber = 16;
  inline const ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo& virtualwedgeinfolist(int index) const;
  inline ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo* mutable_virtualwedgeinfolist(int index);
  inline ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo* add_virtualwedgeinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo >&
      virtualwedgeinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo >*
      mutable_virtualwedgeinfolist();
  
  // optional string commissionUID = 17;
  inline bool has_commissionuid() const;
  inline void clear_commissionuid();
  static const int kCommissionUIDFieldNumber = 17;
  inline const ::std::string& commissionuid() const;
  inline void set_commissionuid(const ::std::string& value);
  inline void set_commissionuid(const char* value);
  inline void set_commissionuid(const char* value, size_t size);
  inline ::std::string* mutable_commissionuid();
  inline ::std::string* release_commissionuid();
  
  // optional string accName = 18;
  inline bool has_accname() const;
  inline void clear_accname();
  static const int kAccNameFieldNumber = 18;
  inline const ::std::string& accname() const;
  inline void set_accname(const ::std::string& value);
  inline void set_accname(const char* value);
  inline void set_accname(const char* value, size_t size);
  inline ::std::string* mutable_accname();
  inline ::std::string* release_accname();
  
  // optional string accessoryUID = 19;
  inline bool has_accessoryuid() const;
  inline void clear_accessoryuid();
  static const int kAccessoryUIDFieldNumber = 19;
  inline const ::std::string& accessoryuid() const;
  inline void set_accessoryuid(const ::std::string& value);
  inline void set_accessoryuid(const char* value);
  inline void set_accessoryuid(const char* value, size_t size);
  inline ::std::string* mutable_accessoryuid();
  inline ::std::string* release_accessoryuid();
  
  // optional string wedgeId = 20;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 20;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional int32 algType = 21;
  inline bool has_algtype() const;
  inline void clear_algtype();
  static const int kAlgTypeFieldNumber = 21;
  inline ::google::protobuf::int32 algtype() const;
  inline void set_algtype(::google::protobuf::int32 value);
  
  // optional int32 scXcountProto = 22;
  inline bool has_scxcountproto() const;
  inline void clear_scxcountproto();
  static const int kScXcountProtoFieldNumber = 22;
  inline ::google::protobuf::int32 scxcountproto() const;
  inline void set_scxcountproto(::google::protobuf::int32 value);
  
  // optional int32 scYcountProto = 23;
  inline bool has_scycountproto() const;
  inline void clear_scycountproto();
  static const int kScYcountProtoFieldNumber = 23;
  inline ::google::protobuf::int32 scycountproto() const;
  inline void set_scycountproto(::google::protobuf::int32 value);
  
  // optional string scXPositionsProto = 24;
  inline bool has_scxpositionsproto() const;
  inline void clear_scxpositionsproto();
  static const int kScXPositionsProtoFieldNumber = 24;
  inline const ::std::string& scxpositionsproto() const;
  inline void set_scxpositionsproto(const ::std::string& value);
  inline void set_scxpositionsproto(const char* value);
  inline void set_scxpositionsproto(const char* value, size_t size);
  inline ::std::string* mutable_scxpositionsproto();
  inline ::std::string* release_scxpositionsproto();
  
  // optional string scYpositionsProto = 25;
  inline bool has_scypositionsproto() const;
  inline void clear_scypositionsproto();
  static const int kScYpositionsProtoFieldNumber = 25;
  inline const ::std::string& scypositionsproto() const;
  inline void set_scypositionsproto(const ::std::string& value);
  inline void set_scypositionsproto(const char* value);
  inline void set_scypositionsproto(const char* value, size_t size);
  inline ::std::string* mutable_scypositionsproto();
  inline ::std::string* release_scypositionsproto();
  
  // optional string scBlocbProto = 26;
  inline bool has_scblocbproto() const;
  inline void clear_scblocbproto();
  static const int kScBlocbProtoFieldNumber = 26;
  inline const ::std::string& scblocbproto() const;
  inline void set_scblocbproto(const ::std::string& value);
  inline void set_scblocbproto(const char* value);
  inline void set_scblocbproto(const char* value, size_t size);
  inline ::std::string* mutable_scblocbproto();
  inline ::std::string* release_scblocbproto();
  
  // optional float referencefluence = 27;
  inline bool has_referencefluence() const;
  inline void clear_referencefluence();
  static const int kReferencefluenceFieldNumber = 27;
  inline float referencefluence() const;
  inline void set_referencefluence(float value);
  
  // optional float diamThree = 28;
  inline bool has_diamthree() const;
  inline void clear_diamthree();
  static const int kDiamThreeFieldNumber = 28;
  inline float diamthree() const;
  inline void set_diamthree(float value);
  
  // optional float srcRatio3 = 29;
  inline bool has_srcratio3() const;
  inline void clear_srcratio3();
  static const int kSrcRatio3FieldNumber = 29;
  inline float srcratio3() const;
  inline void set_srcratio3(float value);
  
  // optional float eeqdiam = 30;
  inline bool has_eeqdiam() const;
  inline void clear_eeqdiam();
  static const int kEeqdiamFieldNumber = 30;
  inline float eeqdiam() const;
  inline void set_eeqdiam(float value);
  
  // optional string depthvec = 31;
  inline bool has_depthvec() const;
  inline void clear_depthvec();
  static const int kDepthvecFieldNumber = 31;
  inline const ::std::string& depthvec() const;
  inline void set_depthvec(const ::std::string& value);
  inline void set_depthvec(const char* value);
  inline void set_depthvec(const char* value, size_t size);
  inline ::std::string* mutable_depthvec();
  inline ::std::string* release_depthvec();
  
  // optional string radiusvec = 32;
  inline bool has_radiusvec() const;
  inline void clear_radiusvec();
  static const int kRadiusvecFieldNumber = 32;
  inline const ::std::string& radiusvec() const;
  inline void set_radiusvec(const ::std::string& value);
  inline void set_radiusvec(const char* value);
  inline void set_radiusvec(const char* value, size_t size);
  inline ::std::string* mutable_radiusvec();
  inline ::std::string* release_radiusvec();
  
  // optional string sar = 33;
  inline bool has_sar() const;
  inline void clear_sar();
  static const int kSarFieldNumber = 33;
  inline const ::std::string& sar() const;
  inline void set_sar(const ::std::string& value);
  inline void set_sar(const char* value);
  inline void set_sar(const char* value, size_t size);
  inline ::std::string* mutable_sar();
  inline ::std::string* release_sar();
  
  // optional string flatnessradiusvec = 34;
  inline bool has_flatnessradiusvec() const;
  inline void clear_flatnessradiusvec();
  static const int kFlatnessradiusvecFieldNumber = 34;
  inline const ::std::string& flatnessradiusvec() const;
  inline void set_flatnessradiusvec(const ::std::string& value);
  inline void set_flatnessradiusvec(const char* value);
  inline void set_flatnessradiusvec(const char* value, size_t size);
  inline ::std::string* mutable_flatnessradiusvec();
  inline ::std::string* release_flatnessradiusvec();
  
  // optional string flatnessdepthvec = 35;
  inline bool has_flatnessdepthvec() const;
  inline void clear_flatnessdepthvec();
  static const int kFlatnessdepthvecFieldNumber = 35;
  inline const ::std::string& flatnessdepthvec() const;
  inline void set_flatnessdepthvec(const ::std::string& value);
  inline void set_flatnessdepthvec(const char* value);
  inline void set_flatnessdepthvec(const char* value, size_t size);
  inline ::std::string* mutable_flatnessdepthvec();
  inline ::std::string* release_flatnessdepthvec();
  
  // optional string flatness = 36;
  inline bool has_flatness() const;
  inline void clear_flatness();
  static const int kFlatnessFieldNumber = 36;
  inline const ::std::string& flatness() const;
  inline void set_flatness(const ::std::string& value);
  inline void set_flatness(const char* value);
  inline void set_flatness(const char* value, size_t size);
  inline ::std::string* mutable_flatness();
  inline ::std::string* release_flatness();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilBeam)
 private:
  inline void set_has_diamone();
  inline void clear_has_diamone();
  inline void set_has_diamtwo();
  inline void clear_has_diamtwo();
  inline void set_has_srcratio();
  inline void clear_has_srcratio();
  inline void set_has_transmission();
  inline void clear_has_transmission();
  inline void set_has_psd();
  inline void clear_has_psd();
  inline void set_has_sddxjaw();
  inline void clear_has_sddxjaw();
  inline void set_has_sddyjaw();
  inline void clear_has_sddyjaw();
  inline void set_has_xk0();
  inline void clear_has_xk0();
  inline void set_has_xk1();
  inline void clear_has_xk1();
  inline void set_has_xk2();
  inline void clear_has_xk2();
  inline void set_has_yk0();
  inline void clear_has_yk0();
  inline void set_has_yk1();
  inline void clear_has_yk1();
  inline void set_has_yk2();
  inline void clear_has_yk2();
  inline void set_has_commissionuid();
  inline void clear_has_commissionuid();
  inline void set_has_accname();
  inline void clear_has_accname();
  inline void set_has_accessoryuid();
  inline void clear_has_accessoryuid();
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_algtype();
  inline void clear_has_algtype();
  inline void set_has_scxcountproto();
  inline void clear_has_scxcountproto();
  inline void set_has_scycountproto();
  inline void clear_has_scycountproto();
  inline void set_has_scxpositionsproto();
  inline void clear_has_scxpositionsproto();
  inline void set_has_scypositionsproto();
  inline void clear_has_scypositionsproto();
  inline void set_has_scblocbproto();
  inline void clear_has_scblocbproto();
  inline void set_has_referencefluence();
  inline void clear_has_referencefluence();
  inline void set_has_diamthree();
  inline void clear_has_diamthree();
  inline void set_has_srcratio3();
  inline void clear_has_srcratio3();
  inline void set_has_eeqdiam();
  inline void clear_has_eeqdiam();
  inline void set_has_depthvec();
  inline void clear_has_depthvec();
  inline void set_has_radiusvec();
  inline void clear_has_radiusvec();
  inline void set_has_sar();
  inline void clear_has_sar();
  inline void set_has_flatnessradiusvec();
  inline void clear_has_flatnessradiusvec();
  inline void set_has_flatnessdepthvec();
  inline void clear_has_flatnessdepthvec();
  inline void set_has_flatness();
  inline void clear_has_flatness();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float diamone_;
  float diamtwo_;
  float srcratio_;
  float transmission_;
  float psd_;
  float sddxjaw_;
  float sddyjaw_;
  float xk0_;
  float xk1_;
  float xk2_;
  float yk0_;
  float yk1_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilPDDTMR > tmrlistlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField > physicalwedgefieldlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo > virtualwedgeinfolist_;
  ::std::string* commissionuid_;
  float yk2_;
  ::google::protobuf::int32 algtype_;
  ::std::string* accname_;
  ::std::string* accessoryuid_;
  ::std::string* wedgeid_;
  ::google::protobuf::int32 scxcountproto_;
  ::google::protobuf::int32 scycountproto_;
  ::std::string* scxpositionsproto_;
  ::std::string* scypositionsproto_;
  ::std::string* scblocbproto_;
  float referencefluence_;
  float diamthree_;
  float srcratio3_;
  float eeqdiam_;
  ::std::string* depthvec_;
  ::std::string* radiusvec_;
  ::std::string* sar_;
  ::std::string* flatnessradiusvec_;
  ::std::string* flatnessdepthvec_;
  ::std::string* flatness_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(36 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilBeam* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PencilPDDTMR : public ::google::protobuf::Message {
 public:
  RT_MS_PencilPDDTMR();
  virtual ~RT_MS_PencilPDDTMR();
  
  RT_MS_PencilPDDTMR(const RT_MS_PencilPDDTMR& from);
  
  inline RT_MS_PencilPDDTMR& operator=(const RT_MS_PencilPDDTMR& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilPDDTMR& default_instance();
  
  void Swap(RT_MS_PencilPDDTMR* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilPDDTMR* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilPDDTMR& from);
  void MergeFrom(const RT_MS_PencilPDDTMR& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float depth = 2;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 2;
  inline float depth() const;
  inline void set_depth(float value);
  
  // optional float value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline float value() const;
  inline void set_value(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilPDDTMR)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float depth_;
  float value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilPDDTMR* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PencilBeamPhysicalWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_PencilBeamPhysicalWedgeField();
  virtual ~RT_MS_PencilBeamPhysicalWedgeField();
  
  RT_MS_PencilBeamPhysicalWedgeField(const RT_MS_PencilBeamPhysicalWedgeField& from);
  
  inline RT_MS_PencilBeamPhysicalWedgeField& operator=(const RT_MS_PencilBeamPhysicalWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilBeamPhysicalWedgeField& default_instance();
  
  void Swap(RT_MS_PencilBeamPhysicalWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilBeamPhysicalWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilBeamPhysicalWedgeField& from);
  void MergeFrom(const RT_MS_PencilBeamPhysicalWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string wedgeType = 1;
  inline bool has_wedgetype() const;
  inline void clear_wedgetype();
  static const int kWedgeTypeFieldNumber = 1;
  inline const ::std::string& wedgetype() const;
  inline void set_wedgetype(const ::std::string& value);
  inline void set_wedgetype(const char* value);
  inline void set_wedgetype(const char* value, size_t size);
  inline ::std::string* mutable_wedgetype();
  inline ::std::string* release_wedgetype();
  
  // optional string wedgeId = 2;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 2;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional float mu = 3;
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 3;
  inline float mu() const;
  inline void set_mu(float value);
  
  // optional float dmudx = 4;
  inline bool has_dmudx() const;
  inline void clear_dmudx();
  static const int kDmudxFieldNumber = 4;
  inline float dmudx() const;
  inline void set_dmudx(float value);
  
  // optional float dmudr = 5;
  inline bool has_dmudr() const;
  inline void clear_dmudr();
  static const int kDmudrFieldNumber = 5;
  inline float dmudr() const;
  inline void set_dmudr(float value);
  
  // optional float dmuda = 6;
  inline bool has_dmuda() const;
  inline void clear_dmuda();
  static const int kDmudaFieldNumber = 6;
  inline float dmuda() const;
  inline void set_dmuda(float value);
  
  // optional float hvlSlope = 7;
  inline bool has_hvlslope() const;
  inline void clear_hvlslope();
  static const int kHvlSlopeFieldNumber = 7;
  inline float hvlslope() const;
  inline void set_hvlslope(float value);
  
  // optional float Carriermu = 8;
  inline bool has_carriermu() const;
  inline void clear_carriermu();
  static const int kCarriermuFieldNumber = 8;
  inline float carriermu() const;
  inline void set_carriermu(float value);
  
  // optional float Carrierdmudx = 9;
  inline bool has_carrierdmudx() const;
  inline void clear_carrierdmudx();
  static const int kCarrierdmudxFieldNumber = 9;
  inline float carrierdmudx() const;
  inline void set_carrierdmudx(float value);
  
  // optional float Carrierdmudr = 10;
  inline bool has_carrierdmudr() const;
  inline void clear_carrierdmudr();
  static const int kCarrierdmudrFieldNumber = 10;
  inline float carrierdmudr() const;
  inline void set_carrierdmudr(float value);
  
  // optional float Carrierdmuda = 11;
  inline bool has_carrierdmuda() const;
  inline void clear_carrierdmuda();
  static const int kCarrierdmudaFieldNumber = 11;
  inline float carrierdmuda() const;
  inline void set_carrierdmuda(float value);
  
  // optional float CarrierhvlSlope = 12;
  inline bool has_carrierhvlslope() const;
  inline void clear_carrierhvlslope();
  static const int kCarrierhvlSlopeFieldNumber = 12;
  inline float carrierhvlslope() const;
  inline void set_carrierhvlslope(float value);
  
  // optional float wedgeThick = 13;
  inline bool has_wedgethick() const;
  inline void clear_wedgethick();
  static const int kWedgeThickFieldNumber = 13;
  inline float wedgethick() const;
  inline void set_wedgethick(float value);
  
  // optional float carrierThick = 14;
  inline bool has_carrierthick() const;
  inline void clear_carrierthick();
  static const int kCarrierThickFieldNumber = 14;
  inline float carrierthick() const;
  inline void set_carrierthick(float value);
  
  // repeated .ms.proto.RT_MS_PencilContourVerter weightContourVerterList = 15;
  inline int weightcontourverterlist_size() const;
  inline void clear_weightcontourverterlist();
  static const int kWeightContourVerterListFieldNumber = 15;
  inline const ::ms::proto::RT_MS_PencilContourVerter& weightcontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_PencilContourVerter* mutable_weightcontourverterlist(int index);
  inline ::ms::proto::RT_MS_PencilContourVerter* add_weightcontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >&
      weightcontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >*
      mutable_weightcontourverterlist();
  
  // repeated .ms.proto.RT_MS_PencilContourVerter carrierContourVerterList = 16;
  inline int carriercontourverterlist_size() const;
  inline void clear_carriercontourverterlist();
  static const int kCarrierContourVerterListFieldNumber = 16;
  inline const ::ms::proto::RT_MS_PencilContourVerter& carriercontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_PencilContourVerter* mutable_carriercontourverterlist(int index);
  inline ::ms::proto::RT_MS_PencilContourVerter* add_carriercontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >&
      carriercontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >*
      mutable_carriercontourverterlist();
  
  // optional string wedgeUID = 17;
  inline bool has_wedgeuid() const;
  inline void clear_wedgeuid();
  static const int kWedgeUIDFieldNumber = 17;
  inline const ::std::string& wedgeuid() const;
  inline void set_wedgeuid(const ::std::string& value);
  inline void set_wedgeuid(const char* value);
  inline void set_wedgeuid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeuid();
  inline ::std::string* release_wedgeuid();
  
  // optional string carrierUID = 18;
  inline bool has_carrieruid() const;
  inline void clear_carrieruid();
  static const int kCarrierUIDFieldNumber = 18;
  inline const ::std::string& carrieruid() const;
  inline void set_carrieruid(const ::std::string& value);
  inline void set_carrieruid(const char* value);
  inline void set_carrieruid(const char* value, size_t size);
  inline ::std::string* mutable_carrieruid();
  inline ::std::string* release_carrieruid();
  
  // optional string contourUID1 = 19;
  inline bool has_contouruid1() const;
  inline void clear_contouruid1();
  static const int kContourUID1FieldNumber = 19;
  inline const ::std::string& contouruid1() const;
  inline void set_contouruid1(const ::std::string& value);
  inline void set_contouruid1(const char* value);
  inline void set_contouruid1(const char* value, size_t size);
  inline ::std::string* mutable_contouruid1();
  inline ::std::string* release_contouruid1();
  
  // optional string contourUID2 = 20;
  inline bool has_contouruid2() const;
  inline void clear_contouruid2();
  static const int kContourUID2FieldNumber = 20;
  inline const ::std::string& contouruid2() const;
  inline void set_contouruid2(const ::std::string& value);
  inline void set_contouruid2(const char* value);
  inline void set_contouruid2(const char* value, size_t size);
  inline ::std::string* mutable_contouruid2();
  inline ::std::string* release_contouruid2();
  
  // optional float density = 21;
  inline bool has_density() const;
  inline void clear_density();
  static const int kDensityFieldNumber = 21;
  inline float density() const;
  inline void set_density(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilBeamPhysicalWedgeField)
 private:
  inline void set_has_wedgetype();
  inline void clear_has_wedgetype();
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_dmudx();
  inline void clear_has_dmudx();
  inline void set_has_dmudr();
  inline void clear_has_dmudr();
  inline void set_has_dmuda();
  inline void clear_has_dmuda();
  inline void set_has_hvlslope();
  inline void clear_has_hvlslope();
  inline void set_has_carriermu();
  inline void clear_has_carriermu();
  inline void set_has_carrierdmudx();
  inline void clear_has_carrierdmudx();
  inline void set_has_carrierdmudr();
  inline void clear_has_carrierdmudr();
  inline void set_has_carrierdmuda();
  inline void clear_has_carrierdmuda();
  inline void set_has_carrierhvlslope();
  inline void clear_has_carrierhvlslope();
  inline void set_has_wedgethick();
  inline void clear_has_wedgethick();
  inline void set_has_carrierthick();
  inline void clear_has_carrierthick();
  inline void set_has_wedgeuid();
  inline void clear_has_wedgeuid();
  inline void set_has_carrieruid();
  inline void clear_has_carrieruid();
  inline void set_has_contouruid1();
  inline void clear_has_contouruid1();
  inline void set_has_contouruid2();
  inline void clear_has_contouruid2();
  inline void set_has_density();
  inline void clear_has_density();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* wedgetype_;
  ::std::string* wedgeid_;
  float mu_;
  float dmudx_;
  float dmudr_;
  float dmuda_;
  float hvlslope_;
  float carriermu_;
  float carrierdmudx_;
  float carrierdmudr_;
  float carrierdmuda_;
  float carrierhvlslope_;
  float wedgethick_;
  float carrierthick_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter > weightcontourverterlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter > carriercontourverterlist_;
  ::std::string* wedgeuid_;
  ::std::string* carrieruid_;
  ::std::string* contouruid1_;
  ::std::string* contouruid2_;
  float density_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilBeamPhysicalWedgeField* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PencilContourVerter : public ::google::protobuf::Message {
 public:
  RT_MS_PencilContourVerter();
  virtual ~RT_MS_PencilContourVerter();
  
  RT_MS_PencilContourVerter(const RT_MS_PencilContourVerter& from);
  
  inline RT_MS_PencilContourVerter& operator=(const RT_MS_PencilContourVerter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilContourVerter& default_instance();
  
  void Swap(RT_MS_PencilContourVerter* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilContourVerter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilContourVerter& from);
  void MergeFrom(const RT_MS_PencilContourVerter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float ContourVerterx = 2;
  inline bool has_contourverterx() const;
  inline void clear_contourverterx();
  static const int kContourVerterxFieldNumber = 2;
  inline float contourverterx() const;
  inline void set_contourverterx(float value);
  
  // optional float ContourVertery = 3;
  inline bool has_contourvertery() const;
  inline void clear_contourvertery();
  static const int kContourVerteryFieldNumber = 3;
  inline float contourvertery() const;
  inline void set_contourvertery(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilContourVerter)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_contourverterx();
  inline void clear_has_contourverterx();
  inline void set_has_contourvertery();
  inline void clear_has_contourvertery();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float contourverterx_;
  float contourvertery_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilContourVerter* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PencilBeamVirtualWedgeInfo : public ::google::protobuf::Message {
 public:
  RT_MS_PencilBeamVirtualWedgeInfo();
  virtual ~RT_MS_PencilBeamVirtualWedgeInfo();
  
  RT_MS_PencilBeamVirtualWedgeInfo(const RT_MS_PencilBeamVirtualWedgeInfo& from);
  
  inline RT_MS_PencilBeamVirtualWedgeInfo& operator=(const RT_MS_PencilBeamVirtualWedgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilBeamVirtualWedgeInfo& default_instance();
  
  void Swap(RT_MS_PencilBeamVirtualWedgeInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilBeamVirtualWedgeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilBeamVirtualWedgeInfo& from);
  void MergeFrom(const RT_MS_PencilBeamVirtualWedgeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string virtualUid = 1;
  inline bool has_virtualuid() const;
  inline void clear_virtualuid();
  static const int kVirtualUidFieldNumber = 1;
  inline const ::std::string& virtualuid() const;
  inline void set_virtualuid(const ::std::string& value);
  inline void set_virtualuid(const char* value);
  inline void set_virtualuid(const char* value, size_t size);
  inline ::std::string* mutable_virtualuid();
  inline ::std::string* release_virtualuid();
  
  // optional string goldenUID = 2;
  inline bool has_goldenuid() const;
  inline void clear_goldenuid();
  static const int kGoldenUIDFieldNumber = 2;
  inline const ::std::string& goldenuid() const;
  inline void set_goldenuid(const ::std::string& value);
  inline void set_goldenuid(const char* value);
  inline void set_goldenuid(const char* value, size_t size);
  inline ::std::string* mutable_goldenuid();
  inline ::std::string* release_goldenuid();
  
  // repeated .ms.proto.RT_MS_PencilVirtualWedgeField virtualWedgeFieldList = 3;
  inline int virtualwedgefieldlist_size() const;
  inline void clear_virtualwedgefieldlist();
  static const int kVirtualWedgeFieldListFieldNumber = 3;
  inline const ::ms::proto::RT_MS_PencilVirtualWedgeField& virtualwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_PencilVirtualWedgeField* mutable_virtualwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_PencilVirtualWedgeField* add_virtualwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilVirtualWedgeField >&
      virtualwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilVirtualWedgeField >*
      mutable_virtualwedgefieldlist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilBeamVirtualWedgeInfo)
 private:
  inline void set_has_virtualuid();
  inline void clear_has_virtualuid();
  inline void set_has_goldenuid();
  inline void clear_has_goldenuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* virtualuid_;
  ::std::string* goldenuid_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilVirtualWedgeField > virtualwedgefieldlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilBeamVirtualWedgeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PencilVirtualWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_PencilVirtualWedgeField();
  virtual ~RT_MS_PencilVirtualWedgeField();
  
  RT_MS_PencilVirtualWedgeField(const RT_MS_PencilVirtualWedgeField& from);
  
  inline RT_MS_PencilVirtualWedgeField& operator=(const RT_MS_PencilVirtualWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PencilVirtualWedgeField& default_instance();
  
  void Swap(RT_MS_PencilVirtualWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PencilVirtualWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PencilVirtualWedgeField& from);
  void MergeFrom(const RT_MS_PencilVirtualWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float collimatorX1Position = 2;
  inline bool has_collimatorx1position() const;
  inline void clear_collimatorx1position();
  static const int kCollimatorX1PositionFieldNumber = 2;
  inline float collimatorx1position() const;
  inline void set_collimatorx1position(float value);
  
  // optional float collimatorX2Position = 3;
  inline bool has_collimatorx2position() const;
  inline void clear_collimatorx2position();
  static const int kCollimatorX2PositionFieldNumber = 3;
  inline float collimatorx2position() const;
  inline void set_collimatorx2position(float value);
  
  // optional float relativeMU = 4;
  inline bool has_relativemu() const;
  inline void clear_relativemu();
  static const int kRelativeMUFieldNumber = 4;
  inline float relativemu() const;
  inline void set_relativemu(float value);
  
  // optional float correctionFactor = 5;
  inline bool has_correctionfactor() const;
  inline void clear_correctionfactor();
  static const int kCorrectionFactorFieldNumber = 5;
  inline float correctionfactor() const;
  inline void set_correctionfactor(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PencilVirtualWedgeField)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_collimatorx1position();
  inline void clear_has_collimatorx1position();
  inline void set_has_collimatorx2position();
  inline void clear_has_collimatorx2position();
  inline void set_has_relativemu();
  inline void clear_has_relativemu();
  inline void set_has_correctionfactor();
  inline void clear_has_correctionfactor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float collimatorx1position_;
  float collimatorx2position_;
  float relativemu_;
  float correctionfactor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fpencilbeam_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fpencilbeam_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PencilVirtualWedgeField* default_instance_;
};
// ===================================================================


// ===================================================================

// RT_MS_PencilBeam

// optional float diamOne = 1;
inline bool RT_MS_PencilBeam::has_diamone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilBeam::set_has_diamone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilBeam::clear_has_diamone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilBeam::clear_diamone() {
  diamone_ = 0;
  clear_has_diamone();
}
inline float RT_MS_PencilBeam::diamone() const {
  return diamone_;
}
inline void RT_MS_PencilBeam::set_diamone(float value) {
  set_has_diamone();
  diamone_ = value;
}

// optional float diamTwo = 2;
inline bool RT_MS_PencilBeam::has_diamtwo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilBeam::set_has_diamtwo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilBeam::clear_has_diamtwo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilBeam::clear_diamtwo() {
  diamtwo_ = 0;
  clear_has_diamtwo();
}
inline float RT_MS_PencilBeam::diamtwo() const {
  return diamtwo_;
}
inline void RT_MS_PencilBeam::set_diamtwo(float value) {
  set_has_diamtwo();
  diamtwo_ = value;
}

// optional float srcRatio = 3;
inline bool RT_MS_PencilBeam::has_srcratio() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PencilBeam::set_has_srcratio() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PencilBeam::clear_has_srcratio() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PencilBeam::clear_srcratio() {
  srcratio_ = 0;
  clear_has_srcratio();
}
inline float RT_MS_PencilBeam::srcratio() const {
  return srcratio_;
}
inline void RT_MS_PencilBeam::set_srcratio(float value) {
  set_has_srcratio();
  srcratio_ = value;
}

// optional float transmission = 4;
inline bool RT_MS_PencilBeam::has_transmission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_PencilBeam::set_has_transmission() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_PencilBeam::clear_has_transmission() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_PencilBeam::clear_transmission() {
  transmission_ = 0;
  clear_has_transmission();
}
inline float RT_MS_PencilBeam::transmission() const {
  return transmission_;
}
inline void RT_MS_PencilBeam::set_transmission(float value) {
  set_has_transmission();
  transmission_ = value;
}

// optional float psd = 5;
inline bool RT_MS_PencilBeam::has_psd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_PencilBeam::set_has_psd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_PencilBeam::clear_has_psd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_PencilBeam::clear_psd() {
  psd_ = 0;
  clear_has_psd();
}
inline float RT_MS_PencilBeam::psd() const {
  return psd_;
}
inline void RT_MS_PencilBeam::set_psd(float value) {
  set_has_psd();
  psd_ = value;
}

// optional float sddXJaw = 6;
inline bool RT_MS_PencilBeam::has_sddxjaw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_PencilBeam::set_has_sddxjaw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_PencilBeam::clear_has_sddxjaw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_PencilBeam::clear_sddxjaw() {
  sddxjaw_ = 0;
  clear_has_sddxjaw();
}
inline float RT_MS_PencilBeam::sddxjaw() const {
  return sddxjaw_;
}
inline void RT_MS_PencilBeam::set_sddxjaw(float value) {
  set_has_sddxjaw();
  sddxjaw_ = value;
}

// optional float sddYJaw = 7;
inline bool RT_MS_PencilBeam::has_sddyjaw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_PencilBeam::set_has_sddyjaw() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_PencilBeam::clear_has_sddyjaw() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_PencilBeam::clear_sddyjaw() {
  sddyjaw_ = 0;
  clear_has_sddyjaw();
}
inline float RT_MS_PencilBeam::sddyjaw() const {
  return sddyjaw_;
}
inline void RT_MS_PencilBeam::set_sddyjaw(float value) {
  set_has_sddyjaw();
  sddyjaw_ = value;
}

// optional float xk0 = 8;
inline bool RT_MS_PencilBeam::has_xk0() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_PencilBeam::set_has_xk0() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_PencilBeam::clear_has_xk0() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_PencilBeam::clear_xk0() {
  xk0_ = 0;
  clear_has_xk0();
}
inline float RT_MS_PencilBeam::xk0() const {
  return xk0_;
}
inline void RT_MS_PencilBeam::set_xk0(float value) {
  set_has_xk0();
  xk0_ = value;
}

// optional float xk1 = 9;
inline bool RT_MS_PencilBeam::has_xk1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_PencilBeam::set_has_xk1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_PencilBeam::clear_has_xk1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_PencilBeam::clear_xk1() {
  xk1_ = 0;
  clear_has_xk1();
}
inline float RT_MS_PencilBeam::xk1() const {
  return xk1_;
}
inline void RT_MS_PencilBeam::set_xk1(float value) {
  set_has_xk1();
  xk1_ = value;
}

// optional float xk2 = 10;
inline bool RT_MS_PencilBeam::has_xk2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_PencilBeam::set_has_xk2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_PencilBeam::clear_has_xk2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_PencilBeam::clear_xk2() {
  xk2_ = 0;
  clear_has_xk2();
}
inline float RT_MS_PencilBeam::xk2() const {
  return xk2_;
}
inline void RT_MS_PencilBeam::set_xk2(float value) {
  set_has_xk2();
  xk2_ = value;
}

// optional float yk0 = 11;
inline bool RT_MS_PencilBeam::has_yk0() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_PencilBeam::set_has_yk0() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_PencilBeam::clear_has_yk0() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_PencilBeam::clear_yk0() {
  yk0_ = 0;
  clear_has_yk0();
}
inline float RT_MS_PencilBeam::yk0() const {
  return yk0_;
}
inline void RT_MS_PencilBeam::set_yk0(float value) {
  set_has_yk0();
  yk0_ = value;
}

// optional float yk1 = 12;
inline bool RT_MS_PencilBeam::has_yk1() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_PencilBeam::set_has_yk1() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_PencilBeam::clear_has_yk1() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_PencilBeam::clear_yk1() {
  yk1_ = 0;
  clear_has_yk1();
}
inline float RT_MS_PencilBeam::yk1() const {
  return yk1_;
}
inline void RT_MS_PencilBeam::set_yk1(float value) {
  set_has_yk1();
  yk1_ = value;
}

// optional float yk2 = 13;
inline bool RT_MS_PencilBeam::has_yk2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_yk2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_PencilBeam::clear_has_yk2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_PencilBeam::clear_yk2() {
  yk2_ = 0;
  clear_has_yk2();
}
inline float RT_MS_PencilBeam::yk2() const {
  return yk2_;
}
inline void RT_MS_PencilBeam::set_yk2(float value) {
  set_has_yk2();
  yk2_ = value;
}

// repeated .ms.proto.RT_MS_PencilPDDTMR tMRListList = 14;
inline int RT_MS_PencilBeam::tmrlistlist_size() const {
  return tmrlistlist_.size();
}
inline void RT_MS_PencilBeam::clear_tmrlistlist() {
  tmrlistlist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilPDDTMR& RT_MS_PencilBeam::tmrlistlist(int index) const {
  return tmrlistlist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilPDDTMR* RT_MS_PencilBeam::mutable_tmrlistlist(int index) {
  return tmrlistlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilPDDTMR* RT_MS_PencilBeam::add_tmrlistlist() {
  return tmrlistlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilPDDTMR >&
RT_MS_PencilBeam::tmrlistlist() const {
  return tmrlistlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilPDDTMR >*
RT_MS_PencilBeam::mutable_tmrlistlist() {
  return &tmrlistlist_;
}

// repeated .ms.proto.RT_MS_PencilBeamPhysicalWedgeField physicalWedgeFieldList = 15;
inline int RT_MS_PencilBeam::physicalwedgefieldlist_size() const {
  return physicalwedgefieldlist_.size();
}
inline void RT_MS_PencilBeam::clear_physicalwedgefieldlist() {
  physicalwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField& RT_MS_PencilBeam::physicalwedgefieldlist(int index) const {
  return physicalwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField* RT_MS_PencilBeam::mutable_physicalwedgefieldlist(int index) {
  return physicalwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField* RT_MS_PencilBeam::add_physicalwedgefieldlist() {
  return physicalwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField >&
RT_MS_PencilBeam::physicalwedgefieldlist() const {
  return physicalwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamPhysicalWedgeField >*
RT_MS_PencilBeam::mutable_physicalwedgefieldlist() {
  return &physicalwedgefieldlist_;
}

// repeated .ms.proto.RT_MS_PencilBeamVirtualWedgeInfo virtualWedgeInfoList = 16;
inline int RT_MS_PencilBeam::virtualwedgeinfolist_size() const {
  return virtualwedgeinfolist_.size();
}
inline void RT_MS_PencilBeam::clear_virtualwedgeinfolist() {
  virtualwedgeinfolist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo& RT_MS_PencilBeam::virtualwedgeinfolist(int index) const {
  return virtualwedgeinfolist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo* RT_MS_PencilBeam::mutable_virtualwedgeinfolist(int index) {
  return virtualwedgeinfolist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo* RT_MS_PencilBeam::add_virtualwedgeinfolist() {
  return virtualwedgeinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo >&
RT_MS_PencilBeam::virtualwedgeinfolist() const {
  return virtualwedgeinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilBeamVirtualWedgeInfo >*
RT_MS_PencilBeam::mutable_virtualwedgeinfolist() {
  return &virtualwedgeinfolist_;
}

// optional string commissionUID = 17;
inline bool RT_MS_PencilBeam::has_commissionuid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_commissionuid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_PencilBeam::clear_has_commissionuid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_PencilBeam::clear_commissionuid() {
  if (commissionuid_ != &::google::protobuf::internal::kEmptyString) {
    commissionuid_->clear();
  }
  clear_has_commissionuid();
}
inline const ::std::string& RT_MS_PencilBeam::commissionuid() const {
  return *commissionuid_;
}
inline void RT_MS_PencilBeam::set_commissionuid(const ::std::string& value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_PencilBeam::set_commissionuid(const char* value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_PencilBeam::set_commissionuid(const char* value, size_t size) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_commissionuid() {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  return commissionuid_;
}
inline ::std::string* RT_MS_PencilBeam::release_commissionuid() {
  clear_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commissionuid_;
    commissionuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string accName = 18;
inline bool RT_MS_PencilBeam::has_accname() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_accname() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_PencilBeam::clear_has_accname() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_PencilBeam::clear_accname() {
  if (accname_ != &::google::protobuf::internal::kEmptyString) {
    accname_->clear();
  }
  clear_has_accname();
}
inline const ::std::string& RT_MS_PencilBeam::accname() const {
  return *accname_;
}
inline void RT_MS_PencilBeam::set_accname(const ::std::string& value) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(value);
}
inline void RT_MS_PencilBeam::set_accname(const char* value) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(value);
}
inline void RT_MS_PencilBeam::set_accname(const char* value, size_t size) {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  accname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_accname() {
  set_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    accname_ = new ::std::string;
  }
  return accname_;
}
inline ::std::string* RT_MS_PencilBeam::release_accname() {
  clear_has_accname();
  if (accname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accname_;
    accname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string accessoryUID = 19;
inline bool RT_MS_PencilBeam::has_accessoryuid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_accessoryuid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_PencilBeam::clear_has_accessoryuid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_PencilBeam::clear_accessoryuid() {
  if (accessoryuid_ != &::google::protobuf::internal::kEmptyString) {
    accessoryuid_->clear();
  }
  clear_has_accessoryuid();
}
inline const ::std::string& RT_MS_PencilBeam::accessoryuid() const {
  return *accessoryuid_;
}
inline void RT_MS_PencilBeam::set_accessoryuid(const ::std::string& value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_PencilBeam::set_accessoryuid(const char* value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_PencilBeam::set_accessoryuid(const char* value, size_t size) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_accessoryuid() {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  return accessoryuid_;
}
inline ::std::string* RT_MS_PencilBeam::release_accessoryuid() {
  clear_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessoryuid_;
    accessoryuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeId = 20;
inline bool RT_MS_PencilBeam::has_wedgeid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_wedgeid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_PencilBeam::clear_has_wedgeid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_PencilBeam::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_PencilBeam::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_PencilBeam::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PencilBeam::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PencilBeam::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_PencilBeam::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 algType = 21;
inline bool RT_MS_PencilBeam::has_algtype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_algtype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_PencilBeam::clear_has_algtype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_PencilBeam::clear_algtype() {
  algtype_ = 0;
  clear_has_algtype();
}
inline ::google::protobuf::int32 RT_MS_PencilBeam::algtype() const {
  return algtype_;
}
inline void RT_MS_PencilBeam::set_algtype(::google::protobuf::int32 value) {
  set_has_algtype();
  algtype_ = value;
}

// optional int32 scXcountProto = 22;
inline bool RT_MS_PencilBeam::has_scxcountproto() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_scxcountproto() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_PencilBeam::clear_has_scxcountproto() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_PencilBeam::clear_scxcountproto() {
  scxcountproto_ = 0;
  clear_has_scxcountproto();
}
inline ::google::protobuf::int32 RT_MS_PencilBeam::scxcountproto() const {
  return scxcountproto_;
}
inline void RT_MS_PencilBeam::set_scxcountproto(::google::protobuf::int32 value) {
  set_has_scxcountproto();
  scxcountproto_ = value;
}

// optional int32 scYcountProto = 23;
inline bool RT_MS_PencilBeam::has_scycountproto() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_scycountproto() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_PencilBeam::clear_has_scycountproto() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_PencilBeam::clear_scycountproto() {
  scycountproto_ = 0;
  clear_has_scycountproto();
}
inline ::google::protobuf::int32 RT_MS_PencilBeam::scycountproto() const {
  return scycountproto_;
}
inline void RT_MS_PencilBeam::set_scycountproto(::google::protobuf::int32 value) {
  set_has_scycountproto();
  scycountproto_ = value;
}

// optional string scXPositionsProto = 24;
inline bool RT_MS_PencilBeam::has_scxpositionsproto() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_scxpositionsproto() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RT_MS_PencilBeam::clear_has_scxpositionsproto() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RT_MS_PencilBeam::clear_scxpositionsproto() {
  if (scxpositionsproto_ != &::google::protobuf::internal::kEmptyString) {
    scxpositionsproto_->clear();
  }
  clear_has_scxpositionsproto();
}
inline const ::std::string& RT_MS_PencilBeam::scxpositionsproto() const {
  return *scxpositionsproto_;
}
inline void RT_MS_PencilBeam::set_scxpositionsproto(const ::std::string& value) {
  set_has_scxpositionsproto();
  if (scxpositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scxpositionsproto_ = new ::std::string;
  }
  scxpositionsproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scxpositionsproto(const char* value) {
  set_has_scxpositionsproto();
  if (scxpositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scxpositionsproto_ = new ::std::string;
  }
  scxpositionsproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scxpositionsproto(const char* value, size_t size) {
  set_has_scxpositionsproto();
  if (scxpositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scxpositionsproto_ = new ::std::string;
  }
  scxpositionsproto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_scxpositionsproto() {
  set_has_scxpositionsproto();
  if (scxpositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scxpositionsproto_ = new ::std::string;
  }
  return scxpositionsproto_;
}
inline ::std::string* RT_MS_PencilBeam::release_scxpositionsproto() {
  clear_has_scxpositionsproto();
  if (scxpositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scxpositionsproto_;
    scxpositionsproto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string scYpositionsProto = 25;
inline bool RT_MS_PencilBeam::has_scypositionsproto() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_scypositionsproto() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RT_MS_PencilBeam::clear_has_scypositionsproto() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RT_MS_PencilBeam::clear_scypositionsproto() {
  if (scypositionsproto_ != &::google::protobuf::internal::kEmptyString) {
    scypositionsproto_->clear();
  }
  clear_has_scypositionsproto();
}
inline const ::std::string& RT_MS_PencilBeam::scypositionsproto() const {
  return *scypositionsproto_;
}
inline void RT_MS_PencilBeam::set_scypositionsproto(const ::std::string& value) {
  set_has_scypositionsproto();
  if (scypositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scypositionsproto_ = new ::std::string;
  }
  scypositionsproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scypositionsproto(const char* value) {
  set_has_scypositionsproto();
  if (scypositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scypositionsproto_ = new ::std::string;
  }
  scypositionsproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scypositionsproto(const char* value, size_t size) {
  set_has_scypositionsproto();
  if (scypositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scypositionsproto_ = new ::std::string;
  }
  scypositionsproto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_scypositionsproto() {
  set_has_scypositionsproto();
  if (scypositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    scypositionsproto_ = new ::std::string;
  }
  return scypositionsproto_;
}
inline ::std::string* RT_MS_PencilBeam::release_scypositionsproto() {
  clear_has_scypositionsproto();
  if (scypositionsproto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scypositionsproto_;
    scypositionsproto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string scBlocbProto = 26;
inline bool RT_MS_PencilBeam::has_scblocbproto() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_scblocbproto() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RT_MS_PencilBeam::clear_has_scblocbproto() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RT_MS_PencilBeam::clear_scblocbproto() {
  if (scblocbproto_ != &::google::protobuf::internal::kEmptyString) {
    scblocbproto_->clear();
  }
  clear_has_scblocbproto();
}
inline const ::std::string& RT_MS_PencilBeam::scblocbproto() const {
  return *scblocbproto_;
}
inline void RT_MS_PencilBeam::set_scblocbproto(const ::std::string& value) {
  set_has_scblocbproto();
  if (scblocbproto_ == &::google::protobuf::internal::kEmptyString) {
    scblocbproto_ = new ::std::string;
  }
  scblocbproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scblocbproto(const char* value) {
  set_has_scblocbproto();
  if (scblocbproto_ == &::google::protobuf::internal::kEmptyString) {
    scblocbproto_ = new ::std::string;
  }
  scblocbproto_->assign(value);
}
inline void RT_MS_PencilBeam::set_scblocbproto(const char* value, size_t size) {
  set_has_scblocbproto();
  if (scblocbproto_ == &::google::protobuf::internal::kEmptyString) {
    scblocbproto_ = new ::std::string;
  }
  scblocbproto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_scblocbproto() {
  set_has_scblocbproto();
  if (scblocbproto_ == &::google::protobuf::internal::kEmptyString) {
    scblocbproto_ = new ::std::string;
  }
  return scblocbproto_;
}
inline ::std::string* RT_MS_PencilBeam::release_scblocbproto() {
  clear_has_scblocbproto();
  if (scblocbproto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = scblocbproto_;
    scblocbproto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float referencefluence = 27;
inline bool RT_MS_PencilBeam::has_referencefluence() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_referencefluence() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RT_MS_PencilBeam::clear_has_referencefluence() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RT_MS_PencilBeam::clear_referencefluence() {
  referencefluence_ = 0;
  clear_has_referencefluence();
}
inline float RT_MS_PencilBeam::referencefluence() const {
  return referencefluence_;
}
inline void RT_MS_PencilBeam::set_referencefluence(float value) {
  set_has_referencefluence();
  referencefluence_ = value;
}

// optional float diamThree = 28;
inline bool RT_MS_PencilBeam::has_diamthree() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_diamthree() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RT_MS_PencilBeam::clear_has_diamthree() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RT_MS_PencilBeam::clear_diamthree() {
  diamthree_ = 0;
  clear_has_diamthree();
}
inline float RT_MS_PencilBeam::diamthree() const {
  return diamthree_;
}
inline void RT_MS_PencilBeam::set_diamthree(float value) {
  set_has_diamthree();
  diamthree_ = value;
}

// optional float srcRatio3 = 29;
inline bool RT_MS_PencilBeam::has_srcratio3() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_srcratio3() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RT_MS_PencilBeam::clear_has_srcratio3() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RT_MS_PencilBeam::clear_srcratio3() {
  srcratio3_ = 0;
  clear_has_srcratio3();
}
inline float RT_MS_PencilBeam::srcratio3() const {
  return srcratio3_;
}
inline void RT_MS_PencilBeam::set_srcratio3(float value) {
  set_has_srcratio3();
  srcratio3_ = value;
}

// optional float eeqdiam = 30;
inline bool RT_MS_PencilBeam::has_eeqdiam() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_eeqdiam() {
  _has_bits_[0] |= 0x20000000u;
}
inline void RT_MS_PencilBeam::clear_has_eeqdiam() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void RT_MS_PencilBeam::clear_eeqdiam() {
  eeqdiam_ = 0;
  clear_has_eeqdiam();
}
inline float RT_MS_PencilBeam::eeqdiam() const {
  return eeqdiam_;
}
inline void RT_MS_PencilBeam::set_eeqdiam(float value) {
  set_has_eeqdiam();
  eeqdiam_ = value;
}

// optional string depthvec = 31;
inline bool RT_MS_PencilBeam::has_depthvec() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_depthvec() {
  _has_bits_[0] |= 0x40000000u;
}
inline void RT_MS_PencilBeam::clear_has_depthvec() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void RT_MS_PencilBeam::clear_depthvec() {
  if (depthvec_ != &::google::protobuf::internal::kEmptyString) {
    depthvec_->clear();
  }
  clear_has_depthvec();
}
inline const ::std::string& RT_MS_PencilBeam::depthvec() const {
  return *depthvec_;
}
inline void RT_MS_PencilBeam::set_depthvec(const ::std::string& value) {
  set_has_depthvec();
  if (depthvec_ == &::google::protobuf::internal::kEmptyString) {
    depthvec_ = new ::std::string;
  }
  depthvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_depthvec(const char* value) {
  set_has_depthvec();
  if (depthvec_ == &::google::protobuf::internal::kEmptyString) {
    depthvec_ = new ::std::string;
  }
  depthvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_depthvec(const char* value, size_t size) {
  set_has_depthvec();
  if (depthvec_ == &::google::protobuf::internal::kEmptyString) {
    depthvec_ = new ::std::string;
  }
  depthvec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_depthvec() {
  set_has_depthvec();
  if (depthvec_ == &::google::protobuf::internal::kEmptyString) {
    depthvec_ = new ::std::string;
  }
  return depthvec_;
}
inline ::std::string* RT_MS_PencilBeam::release_depthvec() {
  clear_has_depthvec();
  if (depthvec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = depthvec_;
    depthvec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string radiusvec = 32;
inline bool RT_MS_PencilBeam::has_radiusvec() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void RT_MS_PencilBeam::set_has_radiusvec() {
  _has_bits_[0] |= 0x80000000u;
}
inline void RT_MS_PencilBeam::clear_has_radiusvec() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void RT_MS_PencilBeam::clear_radiusvec() {
  if (radiusvec_ != &::google::protobuf::internal::kEmptyString) {
    radiusvec_->clear();
  }
  clear_has_radiusvec();
}
inline const ::std::string& RT_MS_PencilBeam::radiusvec() const {
  return *radiusvec_;
}
inline void RT_MS_PencilBeam::set_radiusvec(const ::std::string& value) {
  set_has_radiusvec();
  if (radiusvec_ == &::google::protobuf::internal::kEmptyString) {
    radiusvec_ = new ::std::string;
  }
  radiusvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_radiusvec(const char* value) {
  set_has_radiusvec();
  if (radiusvec_ == &::google::protobuf::internal::kEmptyString) {
    radiusvec_ = new ::std::string;
  }
  radiusvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_radiusvec(const char* value, size_t size) {
  set_has_radiusvec();
  if (radiusvec_ == &::google::protobuf::internal::kEmptyString) {
    radiusvec_ = new ::std::string;
  }
  radiusvec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_radiusvec() {
  set_has_radiusvec();
  if (radiusvec_ == &::google::protobuf::internal::kEmptyString) {
    radiusvec_ = new ::std::string;
  }
  return radiusvec_;
}
inline ::std::string* RT_MS_PencilBeam::release_radiusvec() {
  clear_has_radiusvec();
  if (radiusvec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = radiusvec_;
    radiusvec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sar = 33;
inline bool RT_MS_PencilBeam::has_sar() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RT_MS_PencilBeam::set_has_sar() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RT_MS_PencilBeam::clear_has_sar() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RT_MS_PencilBeam::clear_sar() {
  if (sar_ != &::google::protobuf::internal::kEmptyString) {
    sar_->clear();
  }
  clear_has_sar();
}
inline const ::std::string& RT_MS_PencilBeam::sar() const {
  return *sar_;
}
inline void RT_MS_PencilBeam::set_sar(const ::std::string& value) {
  set_has_sar();
  if (sar_ == &::google::protobuf::internal::kEmptyString) {
    sar_ = new ::std::string;
  }
  sar_->assign(value);
}
inline void RT_MS_PencilBeam::set_sar(const char* value) {
  set_has_sar();
  if (sar_ == &::google::protobuf::internal::kEmptyString) {
    sar_ = new ::std::string;
  }
  sar_->assign(value);
}
inline void RT_MS_PencilBeam::set_sar(const char* value, size_t size) {
  set_has_sar();
  if (sar_ == &::google::protobuf::internal::kEmptyString) {
    sar_ = new ::std::string;
  }
  sar_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_sar() {
  set_has_sar();
  if (sar_ == &::google::protobuf::internal::kEmptyString) {
    sar_ = new ::std::string;
  }
  return sar_;
}
inline ::std::string* RT_MS_PencilBeam::release_sar() {
  clear_has_sar();
  if (sar_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sar_;
    sar_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string flatnessradiusvec = 34;
inline bool RT_MS_PencilBeam::has_flatnessradiusvec() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RT_MS_PencilBeam::set_has_flatnessradiusvec() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RT_MS_PencilBeam::clear_has_flatnessradiusvec() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RT_MS_PencilBeam::clear_flatnessradiusvec() {
  if (flatnessradiusvec_ != &::google::protobuf::internal::kEmptyString) {
    flatnessradiusvec_->clear();
  }
  clear_has_flatnessradiusvec();
}
inline const ::std::string& RT_MS_PencilBeam::flatnessradiusvec() const {
  return *flatnessradiusvec_;
}
inline void RT_MS_PencilBeam::set_flatnessradiusvec(const ::std::string& value) {
  set_has_flatnessradiusvec();
  if (flatnessradiusvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessradiusvec_ = new ::std::string;
  }
  flatnessradiusvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatnessradiusvec(const char* value) {
  set_has_flatnessradiusvec();
  if (flatnessradiusvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessradiusvec_ = new ::std::string;
  }
  flatnessradiusvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatnessradiusvec(const char* value, size_t size) {
  set_has_flatnessradiusvec();
  if (flatnessradiusvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessradiusvec_ = new ::std::string;
  }
  flatnessradiusvec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_flatnessradiusvec() {
  set_has_flatnessradiusvec();
  if (flatnessradiusvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessradiusvec_ = new ::std::string;
  }
  return flatnessradiusvec_;
}
inline ::std::string* RT_MS_PencilBeam::release_flatnessradiusvec() {
  clear_has_flatnessradiusvec();
  if (flatnessradiusvec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flatnessradiusvec_;
    flatnessradiusvec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string flatnessdepthvec = 35;
inline bool RT_MS_PencilBeam::has_flatnessdepthvec() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RT_MS_PencilBeam::set_has_flatnessdepthvec() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RT_MS_PencilBeam::clear_has_flatnessdepthvec() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RT_MS_PencilBeam::clear_flatnessdepthvec() {
  if (flatnessdepthvec_ != &::google::protobuf::internal::kEmptyString) {
    flatnessdepthvec_->clear();
  }
  clear_has_flatnessdepthvec();
}
inline const ::std::string& RT_MS_PencilBeam::flatnessdepthvec() const {
  return *flatnessdepthvec_;
}
inline void RT_MS_PencilBeam::set_flatnessdepthvec(const ::std::string& value) {
  set_has_flatnessdepthvec();
  if (flatnessdepthvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessdepthvec_ = new ::std::string;
  }
  flatnessdepthvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatnessdepthvec(const char* value) {
  set_has_flatnessdepthvec();
  if (flatnessdepthvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessdepthvec_ = new ::std::string;
  }
  flatnessdepthvec_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatnessdepthvec(const char* value, size_t size) {
  set_has_flatnessdepthvec();
  if (flatnessdepthvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessdepthvec_ = new ::std::string;
  }
  flatnessdepthvec_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_flatnessdepthvec() {
  set_has_flatnessdepthvec();
  if (flatnessdepthvec_ == &::google::protobuf::internal::kEmptyString) {
    flatnessdepthvec_ = new ::std::string;
  }
  return flatnessdepthvec_;
}
inline ::std::string* RT_MS_PencilBeam::release_flatnessdepthvec() {
  clear_has_flatnessdepthvec();
  if (flatnessdepthvec_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flatnessdepthvec_;
    flatnessdepthvec_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string flatness = 36;
inline bool RT_MS_PencilBeam::has_flatness() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RT_MS_PencilBeam::set_has_flatness() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RT_MS_PencilBeam::clear_has_flatness() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RT_MS_PencilBeam::clear_flatness() {
  if (flatness_ != &::google::protobuf::internal::kEmptyString) {
    flatness_->clear();
  }
  clear_has_flatness();
}
inline const ::std::string& RT_MS_PencilBeam::flatness() const {
  return *flatness_;
}
inline void RT_MS_PencilBeam::set_flatness(const ::std::string& value) {
  set_has_flatness();
  if (flatness_ == &::google::protobuf::internal::kEmptyString) {
    flatness_ = new ::std::string;
  }
  flatness_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatness(const char* value) {
  set_has_flatness();
  if (flatness_ == &::google::protobuf::internal::kEmptyString) {
    flatness_ = new ::std::string;
  }
  flatness_->assign(value);
}
inline void RT_MS_PencilBeam::set_flatness(const char* value, size_t size) {
  set_has_flatness();
  if (flatness_ == &::google::protobuf::internal::kEmptyString) {
    flatness_ = new ::std::string;
  }
  flatness_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeam::mutable_flatness() {
  set_has_flatness();
  if (flatness_ == &::google::protobuf::internal::kEmptyString) {
    flatness_ = new ::std::string;
  }
  return flatness_;
}
inline ::std::string* RT_MS_PencilBeam::release_flatness() {
  clear_has_flatness();
  if (flatness_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flatness_;
    flatness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RT_MS_PencilPDDTMR

// optional string uid = 1;
inline bool RT_MS_PencilPDDTMR::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilPDDTMR::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilPDDTMR::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilPDDTMR::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_PencilPDDTMR::uid() const {
  return *uid_;
}
inline void RT_MS_PencilPDDTMR::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilPDDTMR::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilPDDTMR::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilPDDTMR::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_PencilPDDTMR::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float depth = 2;
inline bool RT_MS_PencilPDDTMR::has_depth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilPDDTMR::set_has_depth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilPDDTMR::clear_has_depth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilPDDTMR::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline float RT_MS_PencilPDDTMR::depth() const {
  return depth_;
}
inline void RT_MS_PencilPDDTMR::set_depth(float value) {
  set_has_depth();
  depth_ = value;
}

// optional float value = 3;
inline bool RT_MS_PencilPDDTMR::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PencilPDDTMR::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PencilPDDTMR::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PencilPDDTMR::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float RT_MS_PencilPDDTMR::value() const {
  return value_;
}
inline void RT_MS_PencilPDDTMR::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PencilBeamPhysicalWedgeField

// optional string wedgeType = 1;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_wedgetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_wedgetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_wedgetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_wedgetype() {
  if (wedgetype_ != &::google::protobuf::internal::kEmptyString) {
    wedgetype_->clear();
  }
  clear_has_wedgetype();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::wedgetype() const {
  return *wedgetype_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgetype(const ::std::string& value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgetype(const char* value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgetype(const char* value, size_t size) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_wedgetype() {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  return wedgetype_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_wedgetype() {
  clear_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgetype_;
    wedgetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeId = 2;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_wedgeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_wedgeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_wedgeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float mu = 3;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_mu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_mu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_mu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::mu() const {
  return mu_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_mu(float value) {
  set_has_mu();
  mu_ = value;
}

// optional float dmudx = 4;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_dmudx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_dmudx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_dmudx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_dmudx() {
  dmudx_ = 0;
  clear_has_dmudx();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::dmudx() const {
  return dmudx_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_dmudx(float value) {
  set_has_dmudx();
  dmudx_ = value;
}

// optional float dmudr = 5;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_dmudr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_dmudr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_dmudr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_dmudr() {
  dmudr_ = 0;
  clear_has_dmudr();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::dmudr() const {
  return dmudr_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_dmudr(float value) {
  set_has_dmudr();
  dmudr_ = value;
}

// optional float dmuda = 6;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_dmuda() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_dmuda() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_dmuda() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_dmuda() {
  dmuda_ = 0;
  clear_has_dmuda();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::dmuda() const {
  return dmuda_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_dmuda(float value) {
  set_has_dmuda();
  dmuda_ = value;
}

// optional float hvlSlope = 7;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_hvlslope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_hvlslope() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_hvlslope() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_hvlslope() {
  hvlslope_ = 0;
  clear_has_hvlslope();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::hvlslope() const {
  return hvlslope_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_hvlslope(float value) {
  set_has_hvlslope();
  hvlslope_ = value;
}

// optional float Carriermu = 8;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carriermu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carriermu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carriermu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carriermu() {
  carriermu_ = 0;
  clear_has_carriermu();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carriermu() const {
  return carriermu_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carriermu(float value) {
  set_has_carriermu();
  carriermu_ = value;
}

// optional float Carrierdmudx = 9;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrierdmudx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrierdmudx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrierdmudx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrierdmudx() {
  carrierdmudx_ = 0;
  clear_has_carrierdmudx();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carrierdmudx() const {
  return carrierdmudx_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrierdmudx(float value) {
  set_has_carrierdmudx();
  carrierdmudx_ = value;
}

// optional float Carrierdmudr = 10;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrierdmudr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrierdmudr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrierdmudr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrierdmudr() {
  carrierdmudr_ = 0;
  clear_has_carrierdmudr();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carrierdmudr() const {
  return carrierdmudr_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrierdmudr(float value) {
  set_has_carrierdmudr();
  carrierdmudr_ = value;
}

// optional float Carrierdmuda = 11;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrierdmuda() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrierdmuda() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrierdmuda() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrierdmuda() {
  carrierdmuda_ = 0;
  clear_has_carrierdmuda();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carrierdmuda() const {
  return carrierdmuda_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrierdmuda(float value) {
  set_has_carrierdmuda();
  carrierdmuda_ = value;
}

// optional float CarrierhvlSlope = 12;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrierhvlslope() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrierhvlslope() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrierhvlslope() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrierhvlslope() {
  carrierhvlslope_ = 0;
  clear_has_carrierhvlslope();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carrierhvlslope() const {
  return carrierhvlslope_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrierhvlslope(float value) {
  set_has_carrierhvlslope();
  carrierhvlslope_ = value;
}

// optional float wedgeThick = 13;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_wedgethick() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_wedgethick() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_wedgethick() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_wedgethick() {
  wedgethick_ = 0;
  clear_has_wedgethick();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::wedgethick() const {
  return wedgethick_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgethick(float value) {
  set_has_wedgethick();
  wedgethick_ = value;
}

// optional float carrierThick = 14;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrierthick() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrierthick() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrierthick() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrierthick() {
  carrierthick_ = 0;
  clear_has_carrierthick();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::carrierthick() const {
  return carrierthick_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrierthick(float value) {
  set_has_carrierthick();
  carrierthick_ = value;
}

// repeated .ms.proto.RT_MS_PencilContourVerter weightContourVerterList = 15;
inline int RT_MS_PencilBeamPhysicalWedgeField::weightcontourverterlist_size() const {
  return weightcontourverterlist_.size();
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_weightcontourverterlist() {
  weightcontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilContourVerter& RT_MS_PencilBeamPhysicalWedgeField::weightcontourverterlist(int index) const {
  return weightcontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilContourVerter* RT_MS_PencilBeamPhysicalWedgeField::mutable_weightcontourverterlist(int index) {
  return weightcontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilContourVerter* RT_MS_PencilBeamPhysicalWedgeField::add_weightcontourverterlist() {
  return weightcontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >&
RT_MS_PencilBeamPhysicalWedgeField::weightcontourverterlist() const {
  return weightcontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >*
RT_MS_PencilBeamPhysicalWedgeField::mutable_weightcontourverterlist() {
  return &weightcontourverterlist_;
}

// repeated .ms.proto.RT_MS_PencilContourVerter carrierContourVerterList = 16;
inline int RT_MS_PencilBeamPhysicalWedgeField::carriercontourverterlist_size() const {
  return carriercontourverterlist_.size();
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carriercontourverterlist() {
  carriercontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilContourVerter& RT_MS_PencilBeamPhysicalWedgeField::carriercontourverterlist(int index) const {
  return carriercontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilContourVerter* RT_MS_PencilBeamPhysicalWedgeField::mutable_carriercontourverterlist(int index) {
  return carriercontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilContourVerter* RT_MS_PencilBeamPhysicalWedgeField::add_carriercontourverterlist() {
  return carriercontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >&
RT_MS_PencilBeamPhysicalWedgeField::carriercontourverterlist() const {
  return carriercontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilContourVerter >*
RT_MS_PencilBeamPhysicalWedgeField::mutable_carriercontourverterlist() {
  return &carriercontourverterlist_;
}

// optional string wedgeUID = 17;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_wedgeuid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_wedgeuid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_wedgeuid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_wedgeuid() {
  if (wedgeuid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeuid_->clear();
  }
  clear_has_wedgeuid();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::wedgeuid() const {
  return *wedgeuid_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeuid(const ::std::string& value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeuid(const char* value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_wedgeuid(const char* value, size_t size) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_wedgeuid() {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  return wedgeuid_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_wedgeuid() {
  clear_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeuid_;
    wedgeuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string carrierUID = 18;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_carrieruid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_carrieruid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_carrieruid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_carrieruid() {
  if (carrieruid_ != &::google::protobuf::internal::kEmptyString) {
    carrieruid_->clear();
  }
  clear_has_carrieruid();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::carrieruid() const {
  return *carrieruid_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrieruid(const ::std::string& value) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrieruid(const char* value) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_carrieruid(const char* value, size_t size) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_carrieruid() {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  return carrieruid_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_carrieruid() {
  clear_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carrieruid_;
    carrieruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contourUID1 = 19;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_contouruid1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_contouruid1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_contouruid1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_contouruid1() {
  if (contouruid1_ != &::google::protobuf::internal::kEmptyString) {
    contouruid1_->clear();
  }
  clear_has_contouruid1();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::contouruid1() const {
  return *contouruid1_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid1(const ::std::string& value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid1(const char* value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid1(const char* value, size_t size) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_contouruid1() {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  return contouruid1_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_contouruid1() {
  clear_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid1_;
    contouruid1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contourUID2 = 20;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_contouruid2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_contouruid2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_contouruid2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_contouruid2() {
  if (contouruid2_ != &::google::protobuf::internal::kEmptyString) {
    contouruid2_->clear();
  }
  clear_has_contouruid2();
}
inline const ::std::string& RT_MS_PencilBeamPhysicalWedgeField::contouruid2() const {
  return *contouruid2_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid2(const ::std::string& value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid2(const char* value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_contouruid2(const char* value, size_t size) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::mutable_contouruid2() {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  return contouruid2_;
}
inline ::std::string* RT_MS_PencilBeamPhysicalWedgeField::release_contouruid2() {
  clear_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid2_;
    contouruid2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float density = 21;
inline bool RT_MS_PencilBeamPhysicalWedgeField::has_density() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_has_density() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_has_density() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::clear_density() {
  density_ = 0;
  clear_has_density();
}
inline float RT_MS_PencilBeamPhysicalWedgeField::density() const {
  return density_;
}
inline void RT_MS_PencilBeamPhysicalWedgeField::set_density(float value) {
  set_has_density();
  density_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PencilContourVerter

// optional string uid = 1;
inline bool RT_MS_PencilContourVerter::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilContourVerter::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilContourVerter::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilContourVerter::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_PencilContourVerter::uid() const {
  return *uid_;
}
inline void RT_MS_PencilContourVerter::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilContourVerter::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilContourVerter::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilContourVerter::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_PencilContourVerter::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float ContourVerterx = 2;
inline bool RT_MS_PencilContourVerter::has_contourverterx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilContourVerter::set_has_contourverterx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilContourVerter::clear_has_contourverterx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilContourVerter::clear_contourverterx() {
  contourverterx_ = 0;
  clear_has_contourverterx();
}
inline float RT_MS_PencilContourVerter::contourverterx() const {
  return contourverterx_;
}
inline void RT_MS_PencilContourVerter::set_contourverterx(float value) {
  set_has_contourverterx();
  contourverterx_ = value;
}

// optional float ContourVertery = 3;
inline bool RT_MS_PencilContourVerter::has_contourvertery() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PencilContourVerter::set_has_contourvertery() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PencilContourVerter::clear_has_contourvertery() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PencilContourVerter::clear_contourvertery() {
  contourvertery_ = 0;
  clear_has_contourvertery();
}
inline float RT_MS_PencilContourVerter::contourvertery() const {
  return contourvertery_;
}
inline void RT_MS_PencilContourVerter::set_contourvertery(float value) {
  set_has_contourvertery();
  contourvertery_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PencilBeamVirtualWedgeInfo

// optional string virtualUid = 1;
inline bool RT_MS_PencilBeamVirtualWedgeInfo::has_virtualuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_has_virtualuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::clear_has_virtualuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::clear_virtualuid() {
  if (virtualuid_ != &::google::protobuf::internal::kEmptyString) {
    virtualuid_->clear();
  }
  clear_has_virtualuid();
}
inline const ::std::string& RT_MS_PencilBeamVirtualWedgeInfo::virtualuid() const {
  return *virtualuid_;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_virtualuid(const ::std::string& value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_virtualuid(const char* value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_virtualuid(const char* value, size_t size) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamVirtualWedgeInfo::mutable_virtualuid() {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  return virtualuid_;
}
inline ::std::string* RT_MS_PencilBeamVirtualWedgeInfo::release_virtualuid() {
  clear_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = virtualuid_;
    virtualuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string goldenUID = 2;
inline bool RT_MS_PencilBeamVirtualWedgeInfo::has_goldenuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_has_goldenuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::clear_has_goldenuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::clear_goldenuid() {
  if (goldenuid_ != &::google::protobuf::internal::kEmptyString) {
    goldenuid_->clear();
  }
  clear_has_goldenuid();
}
inline const ::std::string& RT_MS_PencilBeamVirtualWedgeInfo::goldenuid() const {
  return *goldenuid_;
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_goldenuid(const ::std::string& value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_goldenuid(const char* value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::set_goldenuid(const char* value, size_t size) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilBeamVirtualWedgeInfo::mutable_goldenuid() {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  return goldenuid_;
}
inline ::std::string* RT_MS_PencilBeamVirtualWedgeInfo::release_goldenuid() {
  clear_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = goldenuid_;
    goldenuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ms.proto.RT_MS_PencilVirtualWedgeField virtualWedgeFieldList = 3;
inline int RT_MS_PencilBeamVirtualWedgeInfo::virtualwedgefieldlist_size() const {
  return virtualwedgefieldlist_.size();
}
inline void RT_MS_PencilBeamVirtualWedgeInfo::clear_virtualwedgefieldlist() {
  virtualwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_PencilVirtualWedgeField& RT_MS_PencilBeamVirtualWedgeInfo::virtualwedgefieldlist(int index) const {
  return virtualwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_PencilVirtualWedgeField* RT_MS_PencilBeamVirtualWedgeInfo::mutable_virtualwedgefieldlist(int index) {
  return virtualwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PencilVirtualWedgeField* RT_MS_PencilBeamVirtualWedgeInfo::add_virtualwedgefieldlist() {
  return virtualwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilVirtualWedgeField >&
RT_MS_PencilBeamVirtualWedgeInfo::virtualwedgefieldlist() const {
  return virtualwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PencilVirtualWedgeField >*
RT_MS_PencilBeamVirtualWedgeInfo::mutable_virtualwedgefieldlist() {
  return &virtualwedgefieldlist_;
}

// -------------------------------------------------------------------

// RT_MS_PencilVirtualWedgeField

// optional string uid = 1;
inline bool RT_MS_PencilVirtualWedgeField::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PencilVirtualWedgeField::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_PencilVirtualWedgeField::uid() const {
  return *uid_;
}
inline void RT_MS_PencilVirtualWedgeField::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilVirtualWedgeField::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_PencilVirtualWedgeField::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PencilVirtualWedgeField::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_PencilVirtualWedgeField::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float collimatorX1Position = 2;
inline bool RT_MS_PencilVirtualWedgeField::has_collimatorx1position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PencilVirtualWedgeField::set_has_collimatorx1position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_has_collimatorx1position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_collimatorx1position() {
  collimatorx1position_ = 0;
  clear_has_collimatorx1position();
}
inline float RT_MS_PencilVirtualWedgeField::collimatorx1position() const {
  return collimatorx1position_;
}
inline void RT_MS_PencilVirtualWedgeField::set_collimatorx1position(float value) {
  set_has_collimatorx1position();
  collimatorx1position_ = value;
}

// optional float collimatorX2Position = 3;
inline bool RT_MS_PencilVirtualWedgeField::has_collimatorx2position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PencilVirtualWedgeField::set_has_collimatorx2position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_has_collimatorx2position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_collimatorx2position() {
  collimatorx2position_ = 0;
  clear_has_collimatorx2position();
}
inline float RT_MS_PencilVirtualWedgeField::collimatorx2position() const {
  return collimatorx2position_;
}
inline void RT_MS_PencilVirtualWedgeField::set_collimatorx2position(float value) {
  set_has_collimatorx2position();
  collimatorx2position_ = value;
}

// optional float relativeMU = 4;
inline bool RT_MS_PencilVirtualWedgeField::has_relativemu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_PencilVirtualWedgeField::set_has_relativemu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_has_relativemu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_relativemu() {
  relativemu_ = 0;
  clear_has_relativemu();
}
inline float RT_MS_PencilVirtualWedgeField::relativemu() const {
  return relativemu_;
}
inline void RT_MS_PencilVirtualWedgeField::set_relativemu(float value) {
  set_has_relativemu();
  relativemu_ = value;
}

// optional float correctionFactor = 5;
inline bool RT_MS_PencilVirtualWedgeField::has_correctionfactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_PencilVirtualWedgeField::set_has_correctionfactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_has_correctionfactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_PencilVirtualWedgeField::clear_correctionfactor() {
  correctionfactor_ = 0;
  clear_has_correctionfactor();
}
inline float RT_MS_PencilVirtualWedgeField::correctionfactor() const {
  return correctionfactor_;
}
inline void RT_MS_PencilVirtualWedgeField::set_correctionfactor(float value) {
  set_has_correctionfactor();
  correctionfactor_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace ms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5fms_5fpencilbeam_2eproto__INCLUDED
