// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_proto_segment.proto

#ifndef PROTOBUF_rt_5ftps_5fproto_5fsegment_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fproto_5fsegment_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tps {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5ftps_5fproto_5fsegment_2eproto();
void protobuf_AssignDesc_rt_5ftps_5fproto_5fsegment_2eproto();
void protobuf_ShutdownFile_rt_5ftps_5fproto_5fsegment_2eproto();

class RtTpsProtoSegment;
class RtTpsProtoRepeatedSegment;
class RtTpsProtoJaw;
class RtTpsProtoMlcLeaf;

// ===================================================================

class RtTpsProtoSegment : public ::google::protobuf::Message {
 public:
  RtTpsProtoSegment();
  virtual ~RtTpsProtoSegment();
  
  RtTpsProtoSegment(const RtTpsProtoSegment& from);
  
  inline RtTpsProtoSegment& operator=(const RtTpsProtoSegment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoSegment& default_instance();
  
  void Swap(RtTpsProtoSegment* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoSegment& from);
  void MergeFrom(const RtTpsProtoSegment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string segmentUID = 1;
  inline bool has_segmentuid() const;
  inline void clear_segmentuid();
  static const int kSegmentUIDFieldNumber = 1;
  inline const ::std::string& segmentuid() const;
  inline void set_segmentuid(const ::std::string& value);
  inline void set_segmentuid(const char* value);
  inline void set_segmentuid(const char* value, size_t size);
  inline ::std::string* mutable_segmentuid();
  inline ::std::string* release_segmentuid();
  
  // optional float segmentWeight = 2;
  inline bool has_segmentweight() const;
  inline void clear_segmentweight();
  static const int kSegmentWeightFieldNumber = 2;
  inline float segmentweight() const;
  inline void set_segmentweight(float value);
  
  // optional float segmentMu = 3;
  inline bool has_segmentmu() const;
  inline void clear_segmentmu();
  static const int kSegmentMuFieldNumber = 3;
  inline float segmentmu() const;
  inline void set_segmentmu(float value);
  
  // optional string beamUID = 4;
  inline bool has_beamuid() const;
  inline void clear_beamuid();
  static const int kBeamUIDFieldNumber = 4;
  inline const ::std::string& beamuid() const;
  inline void set_beamuid(const ::std::string& value);
  inline void set_beamuid(const char* value);
  inline void set_beamuid(const char* value, size_t size);
  inline ::std::string* mutable_beamuid();
  inline ::std::string* release_beamuid();
  
  // optional int32 SequenceNumber = 5;
  inline bool has_sequencenumber() const;
  inline void clear_sequencenumber();
  static const int kSequenceNumberFieldNumber = 5;
  inline ::google::protobuf::int32 sequencenumber() const;
  inline void set_sequencenumber(::google::protobuf::int32 value);
  
  // optional .tps.proto.RtTpsProtoJaw startJaw = 6;
  inline bool has_startjaw() const;
  inline void clear_startjaw();
  static const int kStartJawFieldNumber = 6;
  inline const ::tps::proto::RtTpsProtoJaw& startjaw() const;
  inline ::tps::proto::RtTpsProtoJaw* mutable_startjaw();
  inline ::tps::proto::RtTpsProtoJaw* release_startjaw();
  
  // optional .tps.proto.RtTpsProtoJaw endJaw = 7;
  inline bool has_endjaw() const;
  inline void clear_endjaw();
  static const int kEndJawFieldNumber = 7;
  inline const ::tps::proto::RtTpsProtoJaw& endjaw() const;
  inline ::tps::proto::RtTpsProtoJaw* mutable_endjaw();
  inline ::tps::proto::RtTpsProtoJaw* release_endjaw();
  
  // repeated .tps.proto.RtTpsProtoMlcLeaf startMlcLeaves = 8;
  inline int startmlcleaves_size() const;
  inline void clear_startmlcleaves();
  static const int kStartMlcLeavesFieldNumber = 8;
  inline const ::tps::proto::RtTpsProtoMlcLeaf& startmlcleaves(int index) const;
  inline ::tps::proto::RtTpsProtoMlcLeaf* mutable_startmlcleaves(int index);
  inline ::tps::proto::RtTpsProtoMlcLeaf* add_startmlcleaves();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >&
      startmlcleaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >*
      mutable_startmlcleaves();
  
  // repeated .tps.proto.RtTpsProtoMlcLeaf endMlcLeaves = 9;
  inline int endmlcleaves_size() const;
  inline void clear_endmlcleaves();
  static const int kEndMlcLeavesFieldNumber = 9;
  inline const ::tps::proto::RtTpsProtoMlcLeaf& endmlcleaves(int index) const;
  inline ::tps::proto::RtTpsProtoMlcLeaf* mutable_endmlcleaves(int index);
  inline ::tps::proto::RtTpsProtoMlcLeaf* add_endmlcleaves();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >&
      endmlcleaves() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >*
      mutable_endmlcleaves();
  
  // optional double startgantryangle = 10;
  inline bool has_startgantryangle() const;
  inline void clear_startgantryangle();
  static const int kStartgantryangleFieldNumber = 10;
  inline double startgantryangle() const;
  inline void set_startgantryangle(double value);
  
  // optional double endgantryangle = 11;
  inline bool has_endgantryangle() const;
  inline void clear_endgantryangle();
  static const int kEndgantryangleFieldNumber = 11;
  inline double endgantryangle() const;
  inline void set_endgantryangle(double value);
  
  // optional double starttablerotationangle = 12;
  inline bool has_starttablerotationangle() const;
  inline void clear_starttablerotationangle();
  static const int kStarttablerotationangleFieldNumber = 12;
  inline double starttablerotationangle() const;
  inline void set_starttablerotationangle(double value);
  
  // optional double endtablerotationangle = 13;
  inline bool has_endtablerotationangle() const;
  inline void clear_endtablerotationangle();
  static const int kEndtablerotationangleFieldNumber = 13;
  inline double endtablerotationangle() const;
  inline void set_endtablerotationangle(double value);
  
  // optional double arclength = 14;
  inline bool has_arclength() const;
  inline void clear_arclength();
  static const int kArclengthFieldNumber = 14;
  inline double arclength() const;
  inline void set_arclength(double value);
  
  // optional float startssd = 15;
  inline bool has_startssd() const;
  inline void clear_startssd();
  static const int kStartssdFieldNumber = 15;
  inline float startssd() const;
  inline void set_startssd(float value);
  
  // optional float endssd = 16;
  inline bool has_endssd() const;
  inline void clear_endssd();
  static const int kEndssdFieldNumber = 16;
  inline float endssd() const;
  inline void set_endssd(float value);
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoSegment)
 private:
  inline void set_has_segmentuid();
  inline void clear_has_segmentuid();
  inline void set_has_segmentweight();
  inline void clear_has_segmentweight();
  inline void set_has_segmentmu();
  inline void clear_has_segmentmu();
  inline void set_has_beamuid();
  inline void clear_has_beamuid();
  inline void set_has_sequencenumber();
  inline void clear_has_sequencenumber();
  inline void set_has_startjaw();
  inline void clear_has_startjaw();
  inline void set_has_endjaw();
  inline void clear_has_endjaw();
  inline void set_has_startgantryangle();
  inline void clear_has_startgantryangle();
  inline void set_has_endgantryangle();
  inline void clear_has_endgantryangle();
  inline void set_has_starttablerotationangle();
  inline void clear_has_starttablerotationangle();
  inline void set_has_endtablerotationangle();
  inline void clear_has_endtablerotationangle();
  inline void set_has_arclength();
  inline void clear_has_arclength();
  inline void set_has_startssd();
  inline void clear_has_startssd();
  inline void set_has_endssd();
  inline void clear_has_endssd();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* segmentuid_;
  float segmentweight_;
  float segmentmu_;
  ::std::string* beamuid_;
  ::tps::proto::RtTpsProtoJaw* startjaw_;
  ::tps::proto::RtTpsProtoJaw* endjaw_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf > startmlcleaves_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf > endmlcleaves_;
  double startgantryangle_;
  ::google::protobuf::int32 sequencenumber_;
  float startssd_;
  double endgantryangle_;
  double starttablerotationangle_;
  double endtablerotationangle_;
  double arclength_;
  float endssd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fsegment_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoSegment* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoRepeatedSegment : public ::google::protobuf::Message {
 public:
  RtTpsProtoRepeatedSegment();
  virtual ~RtTpsProtoRepeatedSegment();
  
  RtTpsProtoRepeatedSegment(const RtTpsProtoRepeatedSegment& from);
  
  inline RtTpsProtoRepeatedSegment& operator=(const RtTpsProtoRepeatedSegment& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoRepeatedSegment& default_instance();
  
  void Swap(RtTpsProtoRepeatedSegment* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoRepeatedSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoRepeatedSegment& from);
  void MergeFrom(const RtTpsProtoRepeatedSegment& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tps.proto.RtTpsProtoSegment segmentList = 1;
  inline int segmentlist_size() const;
  inline void clear_segmentlist();
  static const int kSegmentListFieldNumber = 1;
  inline const ::tps::proto::RtTpsProtoSegment& segmentlist(int index) const;
  inline ::tps::proto::RtTpsProtoSegment* mutable_segmentlist(int index);
  inline ::tps::proto::RtTpsProtoSegment* add_segmentlist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSegment >&
      segmentlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSegment >*
      mutable_segmentlist();
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoRepeatedSegment)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSegment > segmentlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fsegment_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoRepeatedSegment* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoJaw : public ::google::protobuf::Message {
 public:
  RtTpsProtoJaw();
  virtual ~RtTpsProtoJaw();
  
  RtTpsProtoJaw(const RtTpsProtoJaw& from);
  
  inline RtTpsProtoJaw& operator=(const RtTpsProtoJaw& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoJaw& default_instance();
  
  void Swap(RtTpsProtoJaw* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoJaw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoJaw& from);
  void MergeFrom(const RtTpsProtoJaw& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float X1 = 1;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline float x1() const;
  inline void set_x1(float value);
  
  // optional float X2 = 2;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline float x2() const;
  inline void set_x2(float value);
  
  // optional float Y1 = 3;
  inline bool has_y1() const;
  inline void clear_y1();
  static const int kY1FieldNumber = 3;
  inline float y1() const;
  inline void set_y1(float value);
  
  // optional float Y2 = 4;
  inline bool has_y2() const;
  inline void clear_y2();
  static const int kY2FieldNumber = 4;
  inline float y2() const;
  inline void set_y2(float value);
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoJaw)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_y1();
  inline void clear_has_y1();
  inline void set_has_y2();
  inline void clear_has_y2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x1_;
  float x2_;
  float y1_;
  float y2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fsegment_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoJaw* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoMlcLeaf : public ::google::protobuf::Message {
 public:
  RtTpsProtoMlcLeaf();
  virtual ~RtTpsProtoMlcLeaf();
  
  RtTpsProtoMlcLeaf(const RtTpsProtoMlcLeaf& from);
  
  inline RtTpsProtoMlcLeaf& operator=(const RtTpsProtoMlcLeaf& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoMlcLeaf& default_instance();
  
  void Swap(RtTpsProtoMlcLeaf* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoMlcLeaf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoMlcLeaf& from);
  void MergeFrom(const RtTpsProtoMlcLeaf& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 SequenceNumber = 1;
  inline bool has_sequencenumber() const;
  inline void clear_sequencenumber();
  static const int kSequenceNumberFieldNumber = 1;
  inline ::google::protobuf::int32 sequencenumber() const;
  inline void set_sequencenumber(::google::protobuf::int32 value);
  
  // optional float X1 = 2;
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 2;
  inline float x1() const;
  inline void set_x1(float value);
  
  // optional float X2 = 3;
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 3;
  inline float x2() const;
  inline void set_x2(float value);
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoMlcLeaf)
 private:
  inline void set_has_sequencenumber();
  inline void clear_has_sequencenumber();
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_x2();
  inline void clear_has_x2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 sequencenumber_;
  float x1_;
  float x2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fsegment_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fsegment_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoMlcLeaf* default_instance_;
};
// ===================================================================


// ===================================================================

// RtTpsProtoSegment

// required string segmentUID = 1;
inline bool RtTpsProtoSegment::has_segmentuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoSegment::set_has_segmentuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoSegment::clear_has_segmentuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoSegment::clear_segmentuid() {
  if (segmentuid_ != &::google::protobuf::internal::kEmptyString) {
    segmentuid_->clear();
  }
  clear_has_segmentuid();
}
inline const ::std::string& RtTpsProtoSegment::segmentuid() const {
  return *segmentuid_;
}
inline void RtTpsProtoSegment::set_segmentuid(const ::std::string& value) {
  set_has_segmentuid();
  if (segmentuid_ == &::google::protobuf::internal::kEmptyString) {
    segmentuid_ = new ::std::string;
  }
  segmentuid_->assign(value);
}
inline void RtTpsProtoSegment::set_segmentuid(const char* value) {
  set_has_segmentuid();
  if (segmentuid_ == &::google::protobuf::internal::kEmptyString) {
    segmentuid_ = new ::std::string;
  }
  segmentuid_->assign(value);
}
inline void RtTpsProtoSegment::set_segmentuid(const char* value, size_t size) {
  set_has_segmentuid();
  if (segmentuid_ == &::google::protobuf::internal::kEmptyString) {
    segmentuid_ = new ::std::string;
  }
  segmentuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSegment::mutable_segmentuid() {
  set_has_segmentuid();
  if (segmentuid_ == &::google::protobuf::internal::kEmptyString) {
    segmentuid_ = new ::std::string;
  }
  return segmentuid_;
}
inline ::std::string* RtTpsProtoSegment::release_segmentuid() {
  clear_has_segmentuid();
  if (segmentuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = segmentuid_;
    segmentuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float segmentWeight = 2;
inline bool RtTpsProtoSegment::has_segmentweight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoSegment::set_has_segmentweight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoSegment::clear_has_segmentweight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoSegment::clear_segmentweight() {
  segmentweight_ = 0;
  clear_has_segmentweight();
}
inline float RtTpsProtoSegment::segmentweight() const {
  return segmentweight_;
}
inline void RtTpsProtoSegment::set_segmentweight(float value) {
  set_has_segmentweight();
  segmentweight_ = value;
}

// optional float segmentMu = 3;
inline bool RtTpsProtoSegment::has_segmentmu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoSegment::set_has_segmentmu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoSegment::clear_has_segmentmu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoSegment::clear_segmentmu() {
  segmentmu_ = 0;
  clear_has_segmentmu();
}
inline float RtTpsProtoSegment::segmentmu() const {
  return segmentmu_;
}
inline void RtTpsProtoSegment::set_segmentmu(float value) {
  set_has_segmentmu();
  segmentmu_ = value;
}

// optional string beamUID = 4;
inline bool RtTpsProtoSegment::has_beamuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoSegment::set_has_beamuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoSegment::clear_has_beamuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoSegment::clear_beamuid() {
  if (beamuid_ != &::google::protobuf::internal::kEmptyString) {
    beamuid_->clear();
  }
  clear_has_beamuid();
}
inline const ::std::string& RtTpsProtoSegment::beamuid() const {
  return *beamuid_;
}
inline void RtTpsProtoSegment::set_beamuid(const ::std::string& value) {
  set_has_beamuid();
  if (beamuid_ == &::google::protobuf::internal::kEmptyString) {
    beamuid_ = new ::std::string;
  }
  beamuid_->assign(value);
}
inline void RtTpsProtoSegment::set_beamuid(const char* value) {
  set_has_beamuid();
  if (beamuid_ == &::google::protobuf::internal::kEmptyString) {
    beamuid_ = new ::std::string;
  }
  beamuid_->assign(value);
}
inline void RtTpsProtoSegment::set_beamuid(const char* value, size_t size) {
  set_has_beamuid();
  if (beamuid_ == &::google::protobuf::internal::kEmptyString) {
    beamuid_ = new ::std::string;
  }
  beamuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSegment::mutable_beamuid() {
  set_has_beamuid();
  if (beamuid_ == &::google::protobuf::internal::kEmptyString) {
    beamuid_ = new ::std::string;
  }
  return beamuid_;
}
inline ::std::string* RtTpsProtoSegment::release_beamuid() {
  clear_has_beamuid();
  if (beamuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = beamuid_;
    beamuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 SequenceNumber = 5;
inline bool RtTpsProtoSegment::has_sequencenumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtTpsProtoSegment::set_has_sequencenumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtTpsProtoSegment::clear_has_sequencenumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtTpsProtoSegment::clear_sequencenumber() {
  sequencenumber_ = 0;
  clear_has_sequencenumber();
}
inline ::google::protobuf::int32 RtTpsProtoSegment::sequencenumber() const {
  return sequencenumber_;
}
inline void RtTpsProtoSegment::set_sequencenumber(::google::protobuf::int32 value) {
  set_has_sequencenumber();
  sequencenumber_ = value;
}

// optional .tps.proto.RtTpsProtoJaw startJaw = 6;
inline bool RtTpsProtoSegment::has_startjaw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtTpsProtoSegment::set_has_startjaw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtTpsProtoSegment::clear_has_startjaw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtTpsProtoSegment::clear_startjaw() {
  if (startjaw_ != NULL) startjaw_->::tps::proto::RtTpsProtoJaw::Clear();
  clear_has_startjaw();
}
inline const ::tps::proto::RtTpsProtoJaw& RtTpsProtoSegment::startjaw() const {
  return startjaw_ != NULL ? *startjaw_ : *default_instance_->startjaw_;
}
inline ::tps::proto::RtTpsProtoJaw* RtTpsProtoSegment::mutable_startjaw() {
  set_has_startjaw();
  if (startjaw_ == NULL) startjaw_ = new ::tps::proto::RtTpsProtoJaw;
  return startjaw_;
}
inline ::tps::proto::RtTpsProtoJaw* RtTpsProtoSegment::release_startjaw() {
  clear_has_startjaw();
  ::tps::proto::RtTpsProtoJaw* temp = startjaw_;
  startjaw_ = NULL;
  return temp;
}

// optional .tps.proto.RtTpsProtoJaw endJaw = 7;
inline bool RtTpsProtoSegment::has_endjaw() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtTpsProtoSegment::set_has_endjaw() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtTpsProtoSegment::clear_has_endjaw() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtTpsProtoSegment::clear_endjaw() {
  if (endjaw_ != NULL) endjaw_->::tps::proto::RtTpsProtoJaw::Clear();
  clear_has_endjaw();
}
inline const ::tps::proto::RtTpsProtoJaw& RtTpsProtoSegment::endjaw() const {
  return endjaw_ != NULL ? *endjaw_ : *default_instance_->endjaw_;
}
inline ::tps::proto::RtTpsProtoJaw* RtTpsProtoSegment::mutable_endjaw() {
  set_has_endjaw();
  if (endjaw_ == NULL) endjaw_ = new ::tps::proto::RtTpsProtoJaw;
  return endjaw_;
}
inline ::tps::proto::RtTpsProtoJaw* RtTpsProtoSegment::release_endjaw() {
  clear_has_endjaw();
  ::tps::proto::RtTpsProtoJaw* temp = endjaw_;
  endjaw_ = NULL;
  return temp;
}

// repeated .tps.proto.RtTpsProtoMlcLeaf startMlcLeaves = 8;
inline int RtTpsProtoSegment::startmlcleaves_size() const {
  return startmlcleaves_.size();
}
inline void RtTpsProtoSegment::clear_startmlcleaves() {
  startmlcleaves_.Clear();
}
inline const ::tps::proto::RtTpsProtoMlcLeaf& RtTpsProtoSegment::startmlcleaves(int index) const {
  return startmlcleaves_.Get(index);
}
inline ::tps::proto::RtTpsProtoMlcLeaf* RtTpsProtoSegment::mutable_startmlcleaves(int index) {
  return startmlcleaves_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoMlcLeaf* RtTpsProtoSegment::add_startmlcleaves() {
  return startmlcleaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >&
RtTpsProtoSegment::startmlcleaves() const {
  return startmlcleaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >*
RtTpsProtoSegment::mutable_startmlcleaves() {
  return &startmlcleaves_;
}

// repeated .tps.proto.RtTpsProtoMlcLeaf endMlcLeaves = 9;
inline int RtTpsProtoSegment::endmlcleaves_size() const {
  return endmlcleaves_.size();
}
inline void RtTpsProtoSegment::clear_endmlcleaves() {
  endmlcleaves_.Clear();
}
inline const ::tps::proto::RtTpsProtoMlcLeaf& RtTpsProtoSegment::endmlcleaves(int index) const {
  return endmlcleaves_.Get(index);
}
inline ::tps::proto::RtTpsProtoMlcLeaf* RtTpsProtoSegment::mutable_endmlcleaves(int index) {
  return endmlcleaves_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoMlcLeaf* RtTpsProtoSegment::add_endmlcleaves() {
  return endmlcleaves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >&
RtTpsProtoSegment::endmlcleaves() const {
  return endmlcleaves_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMlcLeaf >*
RtTpsProtoSegment::mutable_endmlcleaves() {
  return &endmlcleaves_;
}

// optional double startgantryangle = 10;
inline bool RtTpsProtoSegment::has_startgantryangle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtTpsProtoSegment::set_has_startgantryangle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtTpsProtoSegment::clear_has_startgantryangle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtTpsProtoSegment::clear_startgantryangle() {
  startgantryangle_ = 0;
  clear_has_startgantryangle();
}
inline double RtTpsProtoSegment::startgantryangle() const {
  return startgantryangle_;
}
inline void RtTpsProtoSegment::set_startgantryangle(double value) {
  set_has_startgantryangle();
  startgantryangle_ = value;
}

// optional double endgantryangle = 11;
inline bool RtTpsProtoSegment::has_endgantryangle() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RtTpsProtoSegment::set_has_endgantryangle() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RtTpsProtoSegment::clear_has_endgantryangle() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RtTpsProtoSegment::clear_endgantryangle() {
  endgantryangle_ = 0;
  clear_has_endgantryangle();
}
inline double RtTpsProtoSegment::endgantryangle() const {
  return endgantryangle_;
}
inline void RtTpsProtoSegment::set_endgantryangle(double value) {
  set_has_endgantryangle();
  endgantryangle_ = value;
}

// optional double starttablerotationangle = 12;
inline bool RtTpsProtoSegment::has_starttablerotationangle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RtTpsProtoSegment::set_has_starttablerotationangle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RtTpsProtoSegment::clear_has_starttablerotationangle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RtTpsProtoSegment::clear_starttablerotationangle() {
  starttablerotationangle_ = 0;
  clear_has_starttablerotationangle();
}
inline double RtTpsProtoSegment::starttablerotationangle() const {
  return starttablerotationangle_;
}
inline void RtTpsProtoSegment::set_starttablerotationangle(double value) {
  set_has_starttablerotationangle();
  starttablerotationangle_ = value;
}

// optional double endtablerotationangle = 13;
inline bool RtTpsProtoSegment::has_endtablerotationangle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RtTpsProtoSegment::set_has_endtablerotationangle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RtTpsProtoSegment::clear_has_endtablerotationangle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RtTpsProtoSegment::clear_endtablerotationangle() {
  endtablerotationangle_ = 0;
  clear_has_endtablerotationangle();
}
inline double RtTpsProtoSegment::endtablerotationangle() const {
  return endtablerotationangle_;
}
inline void RtTpsProtoSegment::set_endtablerotationangle(double value) {
  set_has_endtablerotationangle();
  endtablerotationangle_ = value;
}

// optional double arclength = 14;
inline bool RtTpsProtoSegment::has_arclength() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RtTpsProtoSegment::set_has_arclength() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RtTpsProtoSegment::clear_has_arclength() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RtTpsProtoSegment::clear_arclength() {
  arclength_ = 0;
  clear_has_arclength();
}
inline double RtTpsProtoSegment::arclength() const {
  return arclength_;
}
inline void RtTpsProtoSegment::set_arclength(double value) {
  set_has_arclength();
  arclength_ = value;
}

// optional float startssd = 15;
inline bool RtTpsProtoSegment::has_startssd() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RtTpsProtoSegment::set_has_startssd() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RtTpsProtoSegment::clear_has_startssd() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RtTpsProtoSegment::clear_startssd() {
  startssd_ = 0;
  clear_has_startssd();
}
inline float RtTpsProtoSegment::startssd() const {
  return startssd_;
}
inline void RtTpsProtoSegment::set_startssd(float value) {
  set_has_startssd();
  startssd_ = value;
}

// optional float endssd = 16;
inline bool RtTpsProtoSegment::has_endssd() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RtTpsProtoSegment::set_has_endssd() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RtTpsProtoSegment::clear_has_endssd() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RtTpsProtoSegment::clear_endssd() {
  endssd_ = 0;
  clear_has_endssd();
}
inline float RtTpsProtoSegment::endssd() const {
  return endssd_;
}
inline void RtTpsProtoSegment::set_endssd(float value) {
  set_has_endssd();
  endssd_ = value;
}

// -------------------------------------------------------------------

// RtTpsProtoRepeatedSegment

// repeated .tps.proto.RtTpsProtoSegment segmentList = 1;
inline int RtTpsProtoRepeatedSegment::segmentlist_size() const {
  return segmentlist_.size();
}
inline void RtTpsProtoRepeatedSegment::clear_segmentlist() {
  segmentlist_.Clear();
}
inline const ::tps::proto::RtTpsProtoSegment& RtTpsProtoRepeatedSegment::segmentlist(int index) const {
  return segmentlist_.Get(index);
}
inline ::tps::proto::RtTpsProtoSegment* RtTpsProtoRepeatedSegment::mutable_segmentlist(int index) {
  return segmentlist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoSegment* RtTpsProtoRepeatedSegment::add_segmentlist() {
  return segmentlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSegment >&
RtTpsProtoRepeatedSegment::segmentlist() const {
  return segmentlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSegment >*
RtTpsProtoRepeatedSegment::mutable_segmentlist() {
  return &segmentlist_;
}

// -------------------------------------------------------------------

// RtTpsProtoJaw

// optional float X1 = 1;
inline bool RtTpsProtoJaw::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoJaw::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoJaw::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoJaw::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline float RtTpsProtoJaw::x1() const {
  return x1_;
}
inline void RtTpsProtoJaw::set_x1(float value) {
  set_has_x1();
  x1_ = value;
}

// optional float X2 = 2;
inline bool RtTpsProtoJaw::has_x2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoJaw::set_has_x2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoJaw::clear_has_x2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoJaw::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline float RtTpsProtoJaw::x2() const {
  return x2_;
}
inline void RtTpsProtoJaw::set_x2(float value) {
  set_has_x2();
  x2_ = value;
}

// optional float Y1 = 3;
inline bool RtTpsProtoJaw::has_y1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoJaw::set_has_y1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoJaw::clear_has_y1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoJaw::clear_y1() {
  y1_ = 0;
  clear_has_y1();
}
inline float RtTpsProtoJaw::y1() const {
  return y1_;
}
inline void RtTpsProtoJaw::set_y1(float value) {
  set_has_y1();
  y1_ = value;
}

// optional float Y2 = 4;
inline bool RtTpsProtoJaw::has_y2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoJaw::set_has_y2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoJaw::clear_has_y2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoJaw::clear_y2() {
  y2_ = 0;
  clear_has_y2();
}
inline float RtTpsProtoJaw::y2() const {
  return y2_;
}
inline void RtTpsProtoJaw::set_y2(float value) {
  set_has_y2();
  y2_ = value;
}

// -------------------------------------------------------------------

// RtTpsProtoMlcLeaf

// optional int32 SequenceNumber = 1;
inline bool RtTpsProtoMlcLeaf::has_sequencenumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoMlcLeaf::set_has_sequencenumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoMlcLeaf::clear_has_sequencenumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoMlcLeaf::clear_sequencenumber() {
  sequencenumber_ = 0;
  clear_has_sequencenumber();
}
inline ::google::protobuf::int32 RtTpsProtoMlcLeaf::sequencenumber() const {
  return sequencenumber_;
}
inline void RtTpsProtoMlcLeaf::set_sequencenumber(::google::protobuf::int32 value) {
  set_has_sequencenumber();
  sequencenumber_ = value;
}

// optional float X1 = 2;
inline bool RtTpsProtoMlcLeaf::has_x1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoMlcLeaf::set_has_x1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoMlcLeaf::clear_has_x1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoMlcLeaf::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline float RtTpsProtoMlcLeaf::x1() const {
  return x1_;
}
inline void RtTpsProtoMlcLeaf::set_x1(float value) {
  set_has_x1();
  x1_ = value;
}

// optional float X2 = 3;
inline bool RtTpsProtoMlcLeaf::has_x2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoMlcLeaf::set_has_x2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoMlcLeaf::clear_has_x2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoMlcLeaf::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline float RtTpsProtoMlcLeaf::x2() const {
  return x2_;
}
inline void RtTpsProtoMlcLeaf::set_x2(float value) {
  set_has_x2();
  x2_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fproto_5fsegment_2eproto__INCLUDED
