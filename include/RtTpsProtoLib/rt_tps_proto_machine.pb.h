// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_proto_machine.proto

#ifndef PROTOBUF_rt_5ftps_5fproto_5fmachine_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fproto_5fmachine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tps {
    namespace proto {

        // Internal implementation detail -- do not call these.
        void  protobuf_AddDesc_rt_5ftps_5fproto_5fmachine_2eproto();
        void protobuf_AssignDesc_rt_5ftps_5fproto_5fmachine_2eproto();
        void protobuf_ShutdownFile_rt_5ftps_5fproto_5fmachine_2eproto();

        class RtTpsProtoMachine;
        class RtTpsMlcSetting;
        class RtTpsProtoRepeatedMachine;

        // ===================================================================

        class RtTpsProtoMachine : public ::google::protobuf::Message {
        public:
            RtTpsProtoMachine();
            virtual ~RtTpsProtoMachine();

            RtTpsProtoMachine(const RtTpsProtoMachine& from);

            inline RtTpsProtoMachine& operator=(const RtTpsProtoMachine& from) {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const RtTpsProtoMachine& default_instance();

            void Swap(RtTpsProtoMachine* other);

            // implements Message ----------------------------------------------

            RtTpsProtoMachine* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const RtTpsProtoMachine& from);
            void MergeFrom(const RtTpsProtoMachine& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // required string machineUID = 1;
            inline bool has_machineuid() const;
            inline void clear_machineuid();
            static const int kMachineUIDFieldNumber = 1;
            inline const ::std::string& machineuid() const;
            inline void set_machineuid(const ::std::string& value);
            inline void set_machineuid(const char* value);
            inline void set_machineuid(const char* value, size_t size);
            inline ::std::string* mutable_machineuid();
            inline ::std::string* release_machineuid();

            // optional string machineName = 2;
            inline bool has_machinename() const;
            inline void clear_machinename();
            static const int kMachineNameFieldNumber = 2;
            inline const ::std::string& machinename() const;
            inline void set_machinename(const ::std::string& value);
            inline void set_machinename(const char* value);
            inline void set_machinename(const char* value, size_t size);
            inline ::std::string* mutable_machinename();
            inline ::std::string* release_machinename();

            // optional double gantryMin = 3;
            inline bool has_gantrymin() const;
            inline void clear_gantrymin();
            static const int kGantryMinFieldNumber = 3;
            inline double gantrymin() const;
            inline void set_gantrymin(double value);

            // optional double gantryMax = 4;
            inline bool has_gantrymax() const;
            inline void clear_gantrymax();
            static const int kGantryMaxFieldNumber = 4;
            inline double gantrymax() const;
            inline void set_gantrymax(double value);

            // optional double tableMin = 5;
            inline bool has_tablemin() const;
            inline void clear_tablemin();
            static const int kTableMinFieldNumber = 5;
            inline double tablemin() const;
            inline void set_tablemin(double value);

            // optional double tableMax = 6;
            inline bool has_tablemax() const;
            inline void clear_tablemax();
            static const int kTableMaxFieldNumber = 6;
            inline double tablemax() const;
            inline void set_tablemax(double value);

            // optional double collimatorMin = 7;
            inline bool has_collimatormin() const;
            inline void clear_collimatormin();
            static const int kCollimatorMinFieldNumber = 7;
            inline double collimatormin() const;
            inline void set_collimatormin(double value);

            // optional double collimatorMax = 8;
            inline bool has_collimatormax() const;
            inline void clear_collimatormax();
            static const int kCollimatorMaxFieldNumber = 8;
            inline double collimatormax() const;
            inline void set_collimatormax(double value);

            // optional double gantryCWRange = 9;
            inline bool has_gantrycwrange() const;
            inline void clear_gantrycwrange();
            static const int kGantryCWRangeFieldNumber = 9;
            inline double gantrycwrange() const;
            inline void set_gantrycwrange(double value);

            // optional double gantryCCWRange = 10;
            inline bool has_gantryccwrange() const;
            inline void clear_gantryccwrange();
            static const int kGantryCCWRangeFieldNumber = 10;
            inline double gantryccwrange() const;
            inline void set_gantryccwrange(double value);

            // optional double jaw_x1_min = 11;
            inline bool has_jaw_x1_min() const;
            inline void clear_jaw_x1_min();
            static const int kJawX1MinFieldNumber = 11;
            inline double jaw_x1_min() const;
            inline void set_jaw_x1_min(double value);

            // optional double jaw_x1_max = 12;
            inline bool has_jaw_x1_max() const;
            inline void clear_jaw_x1_max();
            static const int kJawX1MaxFieldNumber = 12;
            inline double jaw_x1_max() const;
            inline void set_jaw_x1_max(double value);

            // optional double jaw_x2_min = 13;
            inline bool has_jaw_x2_min() const;
            inline void clear_jaw_x2_min();
            static const int kJawX2MinFieldNumber = 13;
            inline double jaw_x2_min() const;
            inline void set_jaw_x2_min(double value);

            // optional double jaw_x2_max = 14;
            inline bool has_jaw_x2_max() const;
            inline void clear_jaw_x2_max();
            static const int kJawX2MaxFieldNumber = 14;
            inline double jaw_x2_max() const;
            inline void set_jaw_x2_max(double value);

            // optional double jaw_y1_min = 15;
            inline bool has_jaw_y1_min() const;
            inline void clear_jaw_y1_min();
            static const int kJawY1MinFieldNumber = 15;
            inline double jaw_y1_min() const;
            inline void set_jaw_y1_min(double value);

            // optional double jaw_y1_max = 16;
            inline bool has_jaw_y1_max() const;
            inline void clear_jaw_y1_max();
            static const int kJawY1MaxFieldNumber = 16;
            inline double jaw_y1_max() const;
            inline void set_jaw_y1_max(double value);

            // optional double jaw_y2_min = 17;
            inline bool has_jaw_y2_min() const;
            inline void clear_jaw_y2_min();
            static const int kJawY2MinFieldNumber = 17;
            inline double jaw_y2_min() const;
            inline void set_jaw_y2_min(double value);

            // optional double jaw_y2_max = 18;
            inline bool has_jaw_y2_max() const;
            inline void clear_jaw_y2_max();
            static const int kJawY2MaxFieldNumber = 18;
            inline double jaw_y2_max() const;
            inline void set_jaw_y2_max(double value);

            // optional bool supported_apetureblock = 19;
            inline bool has_supported_apetureblock() const;
            inline void clear_supported_apetureblock();
            static const int kSupportedApetureblockFieldNumber = 19;
            inline bool supported_apetureblock() const;
            inline void set_supported_apetureblock(bool value);

            // optional bool supported_shieldblock = 20;
            inline bool has_supported_shieldblock() const;
            inline void clear_supported_shieldblock();
            static const int kSupportedShieldblockFieldNumber = 20;
            inline bool supported_shieldblock() const;
            inline void set_supported_shieldblock(bool value);

            // optional bool supported_xjaw = 21;
            inline bool has_supported_xjaw() const;
            inline void clear_supported_xjaw();
            static const int kSupportedXjawFieldNumber = 21;
            inline bool supported_xjaw() const;
            inline void set_supported_xjaw(bool value);

            // optional bool supported_yjaw = 22;
            inline bool has_supported_yjaw() const;
            inline void clear_supported_yjaw();
            static const int kSupportedYjawFieldNumber = 22;
            inline bool supported_yjaw() const;
            inline void set_supported_yjaw(bool value);

            // optional bool xjaw_issymmetry = 23;
            inline bool has_xjaw_issymmetry() const;
            inline void clear_xjaw_issymmetry();
            static const int kXjawIssymmetryFieldNumber = 23;
            inline bool xjaw_issymmetry() const;
            inline void set_xjaw_issymmetry(bool value);

            // optional bool yjaw_issymmetry = 24;
            inline bool has_yjaw_issymmetry() const;
            inline void clear_yjaw_issymmetry();
            static const int kYjawIssymmetryFieldNumber = 24;
            inline bool yjaw_issymmetry() const;
            inline void set_yjaw_issymmetry(bool value);

            // optional bool xjaw_tracking = 25;
            inline bool has_xjaw_tracking() const;
            inline void clear_xjaw_tracking();
            static const int kXjawTrackingFieldNumber = 25;
            inline bool xjaw_tracking() const;
            inline void set_xjaw_tracking(bool value);

            // optional bool yjaw_tracking = 26;
            inline bool has_yjaw_tracking() const;
            inline void clear_yjaw_tracking();
            static const int kYjawTrackingFieldNumber = 26;
            inline bool yjaw_tracking() const;
            inline void set_yjaw_tracking(bool value);

            // optional .tps.proto.RtTpsMlcSetting mlcsetting = 27;
            inline bool has_mlcsetting() const;
            inline void clear_mlcsetting();
            static const int kMlcsettingFieldNumber = 27;
            inline const ::tps::proto::RtTpsMlcSetting& mlcsetting() const;
            inline ::tps::proto::RtTpsMlcSetting* mutable_mlcsetting();
            inline ::tps::proto::RtTpsMlcSetting* release_mlcsetting();

            // optional float sourcetoblocktraydistance = 28;
            inline bool has_sourcetoblocktraydistance() const;
            inline void clear_sourcetoblocktraydistance();
            static const int kSourcetoblocktraydistanceFieldNumber = 28;
            inline float sourcetoblocktraydistance() const;
            inline void set_sourcetoblocktraydistance(float value);

            // optional bool isActive = 29;
            inline bool has_isactive() const;
            inline void clear_isactive();
            static const int kIsActiveFieldNumber = 29;
            inline bool isactive() const;
            inline void set_isactive(bool value);

            // optional bool isForceJawFollow = 30;
            inline bool has_isforcejawfollow() const;
            inline void clear_isforcejawfollow();
            static const int kIsForceJawFollowFieldNumber = 30;
            inline bool isforcejawfollow() const;
            inline void set_isforcejawfollow(bool value);

            // optional bool isCrcValid = 31;
            inline bool has_iscrcvalid() const;
            inline void clear_iscrcvalid();
            static const int kIsCrcValidFieldNumber = 31;
            inline bool iscrcvalid() const;
            inline void set_iscrcvalid(bool value);

            // optional double gantryMaxSpeed = 32;
            inline bool has_gantrymaxspeed() const;
            inline void clear_gantrymaxspeed();
            static const int kGantryMaxSpeedFieldNumber = 32;
            inline double gantrymaxspeed() const;
            inline void set_gantrymaxspeed(double value);

            // optional double blockHeight = 33;
            inline bool has_blockheight() const;
            inline void clear_blockheight();
            static const int kBlockHeightFieldNumber = 33;
            inline double blockheight() const;
            inline void set_blockheight(double value);

            // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoMachine)
        private:
            inline void set_has_machineuid();
            inline void clear_has_machineuid();
            inline void set_has_machinename();
            inline void clear_has_machinename();
            inline void set_has_gantrymin();
            inline void clear_has_gantrymin();
            inline void set_has_gantrymax();
            inline void clear_has_gantrymax();
            inline void set_has_tablemin();
            inline void clear_has_tablemin();
            inline void set_has_tablemax();
            inline void clear_has_tablemax();
            inline void set_has_collimatormin();
            inline void clear_has_collimatormin();
            inline void set_has_collimatormax();
            inline void clear_has_collimatormax();
            inline void set_has_gantrycwrange();
            inline void clear_has_gantrycwrange();
            inline void set_has_gantryccwrange();
            inline void clear_has_gantryccwrange();
            inline void set_has_jaw_x1_min();
            inline void clear_has_jaw_x1_min();
            inline void set_has_jaw_x1_max();
            inline void clear_has_jaw_x1_max();
            inline void set_has_jaw_x2_min();
            inline void clear_has_jaw_x2_min();
            inline void set_has_jaw_x2_max();
            inline void clear_has_jaw_x2_max();
            inline void set_has_jaw_y1_min();
            inline void clear_has_jaw_y1_min();
            inline void set_has_jaw_y1_max();
            inline void clear_has_jaw_y1_max();
            inline void set_has_jaw_y2_min();
            inline void clear_has_jaw_y2_min();
            inline void set_has_jaw_y2_max();
            inline void clear_has_jaw_y2_max();
            inline void set_has_supported_apetureblock();
            inline void clear_has_supported_apetureblock();
            inline void set_has_supported_shieldblock();
            inline void clear_has_supported_shieldblock();
            inline void set_has_supported_xjaw();
            inline void clear_has_supported_xjaw();
            inline void set_has_supported_yjaw();
            inline void clear_has_supported_yjaw();
            inline void set_has_xjaw_issymmetry();
            inline void clear_has_xjaw_issymmetry();
            inline void set_has_yjaw_issymmetry();
            inline void clear_has_yjaw_issymmetry();
            inline void set_has_xjaw_tracking();
            inline void clear_has_xjaw_tracking();
            inline void set_has_yjaw_tracking();
            inline void clear_has_yjaw_tracking();
            inline void set_has_mlcsetting();
            inline void clear_has_mlcsetting();
            inline void set_has_sourcetoblocktraydistance();
            inline void clear_has_sourcetoblocktraydistance();
            inline void set_has_isactive();
            inline void clear_has_isactive();
            inline void set_has_isforcejawfollow();
            inline void clear_has_isforcejawfollow();
            inline void set_has_iscrcvalid();
            inline void clear_has_iscrcvalid();
            inline void set_has_gantrymaxspeed();
            inline void clear_has_gantrymaxspeed();
            inline void set_has_blockheight();
            inline void clear_has_blockheight();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::std::string* machineuid_;
            ::std::string* machinename_;
            double gantrymin_;
            double gantrymax_;
            double tablemin_;
            double tablemax_;
            double collimatormin_;
            double collimatormax_;
            double gantrycwrange_;
            double gantryccwrange_;
            double jaw_x1_min_;
            double jaw_x1_max_;
            double jaw_x2_min_;
            double jaw_x2_max_;
            double jaw_y1_min_;
            double jaw_y1_max_;
            double jaw_y2_min_;
            double jaw_y2_max_;
            bool supported_apetureblock_;
            bool supported_shieldblock_;
            bool supported_xjaw_;
            bool supported_yjaw_;
            bool xjaw_issymmetry_;
            bool yjaw_issymmetry_;
            bool xjaw_tracking_;
            bool yjaw_tracking_;
            ::tps::proto::RtTpsMlcSetting* mlcsetting_;
            float sourcetoblocktraydistance_;
            bool isactive_;
            bool isforcejawfollow_;
            bool iscrcvalid_;
            double gantrymaxspeed_;
            double blockheight_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];

            friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fmachine_2eproto();

            void InitAsDefaultInstance();
            static RtTpsProtoMachine* default_instance_;
        };
        // -------------------------------------------------------------------

        class RtTpsMlcSetting : public ::google::protobuf::Message {
        public:
            RtTpsMlcSetting();
            virtual ~RtTpsMlcSetting();

            RtTpsMlcSetting(const RtTpsMlcSetting& from);

            inline RtTpsMlcSetting& operator=(const RtTpsMlcSetting& from) {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const RtTpsMlcSetting& default_instance();

            void Swap(RtTpsMlcSetting* other);

            // implements Message ----------------------------------------------

            RtTpsMlcSetting* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const RtTpsMlcSetting& from);
            void MergeFrom(const RtTpsMlcSetting& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional int32 numberOfPairs = 1;
            inline bool has_numberofpairs() const;
            inline void clear_numberofpairs();
            static const int kNumberOfPairsFieldNumber = 1;
            inline ::google::protobuf::int32 numberofpairs() const;
            inline void set_numberofpairs(::google::protobuf::int32 value);

            // optional double sourceToMLCtopDistance = 2;
            inline bool has_sourcetomlctopdistance() const;
            inline void clear_sourcetomlctopdistance();
            static const int kSourceToMLCtopDistanceFieldNumber = 2;
            inline double sourcetomlctopdistance() const;
            inline void set_sourcetomlctopdistance(double value);

            // optional double minLeafJawOverlap = 3;
            inline bool has_minleafjawoverlap() const;
            inline void clear_minleafjawoverlap();
            static const int kMinLeafJawOverlapFieldNumber = 3;
            inline double minleafjawoverlap() const;
            inline void set_minleafjawoverlap(double value);

            // optional double minGap = 4;
            inline bool has_mingap() const;
            inline void clear_mingap();
            static const int kMinGapFieldNumber = 4;
            inline double mingap() const;
            inline void set_mingap(double value);

            // optional double maxLeafSpeed = 5;
            inline bool has_maxleafspeed() const;
            inline void clear_maxleafspeed();
            static const int kMaxLeafSpeedFieldNumber = 5;
            inline double maxleafspeed() const;
            inline void set_maxleafspeed(double value);

            // optional double minTipPosition = 6;
            inline bool has_mintipposition() const;
            inline void clear_mintipposition();
            static const int kMinTipPositionFieldNumber = 6;
            inline double mintipposition() const;
            inline void set_mintipposition(double value);

            // optional double maxTipPosition = 7;
            inline bool has_maxtipposition() const;
            inline void clear_maxtipposition();
            static const int kMaxTipPositionFieldNumber = 7;
            inline double maxtipposition() const;
            inline void set_maxtipposition(double value);

            // optional bool leafInterdigitation = 8;
            inline bool has_leafinterdigitation() const;
            inline void clear_leafinterdigitation();
            static const int kLeafInterdigitationFieldNumber = 8;
            inline bool leafinterdigitation() const;
            inline void set_leafinterdigitation(bool value);

            // optional double maxLeafoutofCarriageDistance = 9;
            inline bool has_maxleafoutofcarriagedistance() const;
            inline void clear_maxleafoutofcarriagedistance();
            static const int kMaxLeafoutofCarriageDistanceFieldNumber = 9;
            inline double maxleafoutofcarriagedistance() const;
            inline void set_maxleafoutofcarriagedistance(double value);

            // optional int32 mlcDirection = 10;
            inline bool has_mlcdirection() const;
            inline void clear_mlcdirection();
            static const int kMlcDirectionFieldNumber = 10;
            inline ::google::protobuf::int32 mlcdirection() const;
            inline void set_mlcdirection(::google::protobuf::int32 value);

            // repeated double leafpairupperboundary = 11;
            inline int leafpairupperboundary_size() const;
            inline void clear_leafpairupperboundary();
            static const int kLeafpairupperboundaryFieldNumber = 11;
            inline double leafpairupperboundary(int index) const;
            inline void set_leafpairupperboundary(int index, double value);
            inline void add_leafpairupperboundary(double value);
            inline const ::google::protobuf::RepeatedField< double >&
                leafpairupperboundary() const;
            inline ::google::protobuf::RepeatedField< double >*
                mutable_leafpairupperboundary();

            // @@protoc_insertion_point(class_scope:tps.proto.RtTpsMlcSetting)
        private:
            inline void set_has_numberofpairs();
            inline void clear_has_numberofpairs();
            inline void set_has_sourcetomlctopdistance();
            inline void clear_has_sourcetomlctopdistance();
            inline void set_has_minleafjawoverlap();
            inline void clear_has_minleafjawoverlap();
            inline void set_has_mingap();
            inline void clear_has_mingap();
            inline void set_has_maxleafspeed();
            inline void clear_has_maxleafspeed();
            inline void set_has_mintipposition();
            inline void clear_has_mintipposition();
            inline void set_has_maxtipposition();
            inline void clear_has_maxtipposition();
            inline void set_has_leafinterdigitation();
            inline void clear_has_leafinterdigitation();
            inline void set_has_maxleafoutofcarriagedistance();
            inline void clear_has_maxleafoutofcarriagedistance();
            inline void set_has_mlcdirection();
            inline void clear_has_mlcdirection();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            double sourcetomlctopdistance_;
            double minleafjawoverlap_;
            double mingap_;
            ::google::protobuf::int32 numberofpairs_;
            bool leafinterdigitation_;
            double maxleafspeed_;
            double mintipposition_;
            double maxtipposition_;
            double maxleafoutofcarriagedistance_;
            ::google::protobuf::RepeatedField< double > leafpairupperboundary_;
            ::google::protobuf::int32 mlcdirection_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

            friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fmachine_2eproto();

            void InitAsDefaultInstance();
            static RtTpsMlcSetting* default_instance_;
        };
        // -------------------------------------------------------------------

        class RtTpsProtoRepeatedMachine : public ::google::protobuf::Message {
        public:
            RtTpsProtoRepeatedMachine();
            virtual ~RtTpsProtoRepeatedMachine();

            RtTpsProtoRepeatedMachine(const RtTpsProtoRepeatedMachine& from);

            inline RtTpsProtoRepeatedMachine& operator=(const RtTpsProtoRepeatedMachine& from) {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const RtTpsProtoRepeatedMachine& default_instance();

            void Swap(RtTpsProtoRepeatedMachine* other);

            // implements Message ----------------------------------------------

            RtTpsProtoRepeatedMachine* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const RtTpsProtoRepeatedMachine& from);
            void MergeFrom(const RtTpsProtoRepeatedMachine& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // repeated .tps.proto.RtTpsProtoMachine machineList = 1;
            inline int machinelist_size() const;
            inline void clear_machinelist();
            static const int kMachineListFieldNumber = 1;
            inline const ::tps::proto::RtTpsProtoMachine& machinelist(int index) const;
            inline ::tps::proto::RtTpsProtoMachine* mutable_machinelist(int index);
            inline ::tps::proto::RtTpsProtoMachine* add_machinelist();
            inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMachine >&
                machinelist() const;
            inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMachine >*
                mutable_machinelist();

            // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoRepeatedMachine)
        private:

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMachine > machinelist_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

            friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fmachine_2eproto();
            friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fmachine_2eproto();

            void InitAsDefaultInstance();
            static RtTpsProtoRepeatedMachine* default_instance_;
        };
        // ===================================================================


        // ===================================================================

        // RtTpsProtoMachine

        // required string machineUID = 1;
        inline bool RtTpsProtoMachine::has_machineuid() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_machineuid() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void RtTpsProtoMachine::clear_has_machineuid() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void RtTpsProtoMachine::clear_machineuid() {
            if (machineuid_ != &::google::protobuf::internal::kEmptyString) {
                machineuid_->clear();
            }
            clear_has_machineuid();
        }
        inline const ::std::string& RtTpsProtoMachine::machineuid() const {
            return *machineuid_;
        }
        inline void RtTpsProtoMachine::set_machineuid(const ::std::string& value) {
            set_has_machineuid();
            if (machineuid_ == &::google::protobuf::internal::kEmptyString) {
                machineuid_ = new ::std::string;
            }
            machineuid_->assign(value);
        }
        inline void RtTpsProtoMachine::set_machineuid(const char* value) {
            set_has_machineuid();
            if (machineuid_ == &::google::protobuf::internal::kEmptyString) {
                machineuid_ = new ::std::string;
            }
            machineuid_->assign(value);
        }
        inline void RtTpsProtoMachine::set_machineuid(const char* value, size_t size) {
            set_has_machineuid();
            if (machineuid_ == &::google::protobuf::internal::kEmptyString) {
                machineuid_ = new ::std::string;
            }
            machineuid_->assign(reinterpret_cast<const char*>(value), size);
        }
        inline ::std::string* RtTpsProtoMachine::mutable_machineuid() {
            set_has_machineuid();
            if (machineuid_ == &::google::protobuf::internal::kEmptyString) {
                machineuid_ = new ::std::string;
            }
            return machineuid_;
        }
        inline ::std::string* RtTpsProtoMachine::release_machineuid() {
            clear_has_machineuid();
            if (machineuid_ == &::google::protobuf::internal::kEmptyString) {
                return NULL;
            } else {
                ::std::string* temp = machineuid_;
                machineuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
                return temp;
            }
        }

        // optional string machineName = 2;
        inline bool RtTpsProtoMachine::has_machinename() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_machinename() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void RtTpsProtoMachine::clear_has_machinename() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void RtTpsProtoMachine::clear_machinename() {
            if (machinename_ != &::google::protobuf::internal::kEmptyString) {
                machinename_->clear();
            }
            clear_has_machinename();
        }
        inline const ::std::string& RtTpsProtoMachine::machinename() const {
            return *machinename_;
        }
        inline void RtTpsProtoMachine::set_machinename(const ::std::string& value) {
            set_has_machinename();
            if (machinename_ == &::google::protobuf::internal::kEmptyString) {
                machinename_ = new ::std::string;
            }
            machinename_->assign(value);
        }
        inline void RtTpsProtoMachine::set_machinename(const char* value) {
            set_has_machinename();
            if (machinename_ == &::google::protobuf::internal::kEmptyString) {
                machinename_ = new ::std::string;
            }
            machinename_->assign(value);
        }
        inline void RtTpsProtoMachine::set_machinename(const char* value, size_t size) {
            set_has_machinename();
            if (machinename_ == &::google::protobuf::internal::kEmptyString) {
                machinename_ = new ::std::string;
            }
            machinename_->assign(reinterpret_cast<const char*>(value), size);
        }
        inline ::std::string* RtTpsProtoMachine::mutable_machinename() {
            set_has_machinename();
            if (machinename_ == &::google::protobuf::internal::kEmptyString) {
                machinename_ = new ::std::string;
            }
            return machinename_;
        }
        inline ::std::string* RtTpsProtoMachine::release_machinename() {
            clear_has_machinename();
            if (machinename_ == &::google::protobuf::internal::kEmptyString) {
                return NULL;
            } else {
                ::std::string* temp = machinename_;
                machinename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
                return temp;
            }
        }

        // optional double gantryMin = 3;
        inline bool RtTpsProtoMachine::has_gantrymin() const {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_gantrymin() {
            _has_bits_[0] |= 0x00000004u;
        }
        inline void RtTpsProtoMachine::clear_has_gantrymin() {
            _has_bits_[0] &= ~0x00000004u;
        }
        inline void RtTpsProtoMachine::clear_gantrymin() {
            gantrymin_ = 0;
            clear_has_gantrymin();
        }
        inline double RtTpsProtoMachine::gantrymin() const {
            return gantrymin_;
        }
        inline void RtTpsProtoMachine::set_gantrymin(double value) {
            set_has_gantrymin();
            gantrymin_ = value;
        }

        // optional double gantryMax = 4;
        inline bool RtTpsProtoMachine::has_gantrymax() const {
            return (_has_bits_[0] & 0x00000008u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_gantrymax() {
            _has_bits_[0] |= 0x00000008u;
        }
        inline void RtTpsProtoMachine::clear_has_gantrymax() {
            _has_bits_[0] &= ~0x00000008u;
        }
        inline void RtTpsProtoMachine::clear_gantrymax() {
            gantrymax_ = 0;
            clear_has_gantrymax();
        }
        inline double RtTpsProtoMachine::gantrymax() const {
            return gantrymax_;
        }
        inline void RtTpsProtoMachine::set_gantrymax(double value) {
            set_has_gantrymax();
            gantrymax_ = value;
        }

        // optional double tableMin = 5;
        inline bool RtTpsProtoMachine::has_tablemin() const {
            return (_has_bits_[0] & 0x00000010u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_tablemin() {
            _has_bits_[0] |= 0x00000010u;
        }
        inline void RtTpsProtoMachine::clear_has_tablemin() {
            _has_bits_[0] &= ~0x00000010u;
        }
        inline void RtTpsProtoMachine::clear_tablemin() {
            tablemin_ = 0;
            clear_has_tablemin();
        }
        inline double RtTpsProtoMachine::tablemin() const {
            return tablemin_;
        }
        inline void RtTpsProtoMachine::set_tablemin(double value) {
            set_has_tablemin();
            tablemin_ = value;
        }

        // optional double tableMax = 6;
        inline bool RtTpsProtoMachine::has_tablemax() const {
            return (_has_bits_[0] & 0x00000020u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_tablemax() {
            _has_bits_[0] |= 0x00000020u;
        }
        inline void RtTpsProtoMachine::clear_has_tablemax() {
            _has_bits_[0] &= ~0x00000020u;
        }
        inline void RtTpsProtoMachine::clear_tablemax() {
            tablemax_ = 0;
            clear_has_tablemax();
        }
        inline double RtTpsProtoMachine::tablemax() const {
            return tablemax_;
        }
        inline void RtTpsProtoMachine::set_tablemax(double value) {
            set_has_tablemax();
            tablemax_ = value;
        }

        // optional double collimatorMin = 7;
        inline bool RtTpsProtoMachine::has_collimatormin() const {
            return (_has_bits_[0] & 0x00000040u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_collimatormin() {
            _has_bits_[0] |= 0x00000040u;
        }
        inline void RtTpsProtoMachine::clear_has_collimatormin() {
            _has_bits_[0] &= ~0x00000040u;
        }
        inline void RtTpsProtoMachine::clear_collimatormin() {
            collimatormin_ = 0;
            clear_has_collimatormin();
        }
        inline double RtTpsProtoMachine::collimatormin() const {
            return collimatormin_;
        }
        inline void RtTpsProtoMachine::set_collimatormin(double value) {
            set_has_collimatormin();
            collimatormin_ = value;
        }

        // optional double collimatorMax = 8;
        inline bool RtTpsProtoMachine::has_collimatormax() const {
            return (_has_bits_[0] & 0x00000080u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_collimatormax() {
            _has_bits_[0] |= 0x00000080u;
        }
        inline void RtTpsProtoMachine::clear_has_collimatormax() {
            _has_bits_[0] &= ~0x00000080u;
        }
        inline void RtTpsProtoMachine::clear_collimatormax() {
            collimatormax_ = 0;
            clear_has_collimatormax();
        }
        inline double RtTpsProtoMachine::collimatormax() const {
            return collimatormax_;
        }
        inline void RtTpsProtoMachine::set_collimatormax(double value) {
            set_has_collimatormax();
            collimatormax_ = value;
        }

        // optional double gantryCWRange = 9;
        inline bool RtTpsProtoMachine::has_gantrycwrange() const {
            return (_has_bits_[0] & 0x00000100u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_gantrycwrange() {
            _has_bits_[0] |= 0x00000100u;
        }
        inline void RtTpsProtoMachine::clear_has_gantrycwrange() {
            _has_bits_[0] &= ~0x00000100u;
        }
        inline void RtTpsProtoMachine::clear_gantrycwrange() {
            gantrycwrange_ = 0;
            clear_has_gantrycwrange();
        }
        inline double RtTpsProtoMachine::gantrycwrange() const {
            return gantrycwrange_;
        }
        inline void RtTpsProtoMachine::set_gantrycwrange(double value) {
            set_has_gantrycwrange();
            gantrycwrange_ = value;
        }

        // optional double gantryCCWRange = 10;
        inline bool RtTpsProtoMachine::has_gantryccwrange() const {
            return (_has_bits_[0] & 0x00000200u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_gantryccwrange() {
            _has_bits_[0] |= 0x00000200u;
        }
        inline void RtTpsProtoMachine::clear_has_gantryccwrange() {
            _has_bits_[0] &= ~0x00000200u;
        }
        inline void RtTpsProtoMachine::clear_gantryccwrange() {
            gantryccwrange_ = 0;
            clear_has_gantryccwrange();
        }
        inline double RtTpsProtoMachine::gantryccwrange() const {
            return gantryccwrange_;
        }
        inline void RtTpsProtoMachine::set_gantryccwrange(double value) {
            set_has_gantryccwrange();
            gantryccwrange_ = value;
        }

        // optional double jaw_x1_min = 11;
        inline bool RtTpsProtoMachine::has_jaw_x1_min() const {
            return (_has_bits_[0] & 0x00000400u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_x1_min() {
            _has_bits_[0] |= 0x00000400u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_x1_min() {
            _has_bits_[0] &= ~0x00000400u;
        }
        inline void RtTpsProtoMachine::clear_jaw_x1_min() {
            jaw_x1_min_ = 0;
            clear_has_jaw_x1_min();
        }
        inline double RtTpsProtoMachine::jaw_x1_min() const {
            return jaw_x1_min_;
        }
        inline void RtTpsProtoMachine::set_jaw_x1_min(double value) {
            set_has_jaw_x1_min();
            jaw_x1_min_ = value;
        }

        // optional double jaw_x1_max = 12;
        inline bool RtTpsProtoMachine::has_jaw_x1_max() const {
            return (_has_bits_[0] & 0x00000800u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_x1_max() {
            _has_bits_[0] |= 0x00000800u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_x1_max() {
            _has_bits_[0] &= ~0x00000800u;
        }
        inline void RtTpsProtoMachine::clear_jaw_x1_max() {
            jaw_x1_max_ = 0;
            clear_has_jaw_x1_max();
        }
        inline double RtTpsProtoMachine::jaw_x1_max() const {
            return jaw_x1_max_;
        }
        inline void RtTpsProtoMachine::set_jaw_x1_max(double value) {
            set_has_jaw_x1_max();
            jaw_x1_max_ = value;
        }

        // optional double jaw_x2_min = 13;
        inline bool RtTpsProtoMachine::has_jaw_x2_min() const {
            return (_has_bits_[0] & 0x00001000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_x2_min() {
            _has_bits_[0] |= 0x00001000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_x2_min() {
            _has_bits_[0] &= ~0x00001000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_x2_min() {
            jaw_x2_min_ = 0;
            clear_has_jaw_x2_min();
        }
        inline double RtTpsProtoMachine::jaw_x2_min() const {
            return jaw_x2_min_;
        }
        inline void RtTpsProtoMachine::set_jaw_x2_min(double value) {
            set_has_jaw_x2_min();
            jaw_x2_min_ = value;
        }

        // optional double jaw_x2_max = 14;
        inline bool RtTpsProtoMachine::has_jaw_x2_max() const {
            return (_has_bits_[0] & 0x00002000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_x2_max() {
            _has_bits_[0] |= 0x00002000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_x2_max() {
            _has_bits_[0] &= ~0x00002000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_x2_max() {
            jaw_x2_max_ = 0;
            clear_has_jaw_x2_max();
        }
        inline double RtTpsProtoMachine::jaw_x2_max() const {
            return jaw_x2_max_;
        }
        inline void RtTpsProtoMachine::set_jaw_x2_max(double value) {
            set_has_jaw_x2_max();
            jaw_x2_max_ = value;
        }

        // optional double jaw_y1_min = 15;
        inline bool RtTpsProtoMachine::has_jaw_y1_min() const {
            return (_has_bits_[0] & 0x00004000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_y1_min() {
            _has_bits_[0] |= 0x00004000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_y1_min() {
            _has_bits_[0] &= ~0x00004000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_y1_min() {
            jaw_y1_min_ = 0;
            clear_has_jaw_y1_min();
        }
        inline double RtTpsProtoMachine::jaw_y1_min() const {
            return jaw_y1_min_;
        }
        inline void RtTpsProtoMachine::set_jaw_y1_min(double value) {
            set_has_jaw_y1_min();
            jaw_y1_min_ = value;
        }

        // optional double jaw_y1_max = 16;
        inline bool RtTpsProtoMachine::has_jaw_y1_max() const {
            return (_has_bits_[0] & 0x00008000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_y1_max() {
            _has_bits_[0] |= 0x00008000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_y1_max() {
            _has_bits_[0] &= ~0x00008000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_y1_max() {
            jaw_y1_max_ = 0;
            clear_has_jaw_y1_max();
        }
        inline double RtTpsProtoMachine::jaw_y1_max() const {
            return jaw_y1_max_;
        }
        inline void RtTpsProtoMachine::set_jaw_y1_max(double value) {
            set_has_jaw_y1_max();
            jaw_y1_max_ = value;
        }

        // optional double jaw_y2_min = 17;
        inline bool RtTpsProtoMachine::has_jaw_y2_min() const {
            return (_has_bits_[0] & 0x00010000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_y2_min() {
            _has_bits_[0] |= 0x00010000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_y2_min() {
            _has_bits_[0] &= ~0x00010000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_y2_min() {
            jaw_y2_min_ = 0;
            clear_has_jaw_y2_min();
        }
        inline double RtTpsProtoMachine::jaw_y2_min() const {
            return jaw_y2_min_;
        }
        inline void RtTpsProtoMachine::set_jaw_y2_min(double value) {
            set_has_jaw_y2_min();
            jaw_y2_min_ = value;
        }

        // optional double jaw_y2_max = 18;
        inline bool RtTpsProtoMachine::has_jaw_y2_max() const {
            return (_has_bits_[0] & 0x00020000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_jaw_y2_max() {
            _has_bits_[0] |= 0x00020000u;
        }
        inline void RtTpsProtoMachine::clear_has_jaw_y2_max() {
            _has_bits_[0] &= ~0x00020000u;
        }
        inline void RtTpsProtoMachine::clear_jaw_y2_max() {
            jaw_y2_max_ = 0;
            clear_has_jaw_y2_max();
        }
        inline double RtTpsProtoMachine::jaw_y2_max() const {
            return jaw_y2_max_;
        }
        inline void RtTpsProtoMachine::set_jaw_y2_max(double value) {
            set_has_jaw_y2_max();
            jaw_y2_max_ = value;
        }

        // optional bool supported_apetureblock = 19;
        inline bool RtTpsProtoMachine::has_supported_apetureblock() const {
            return (_has_bits_[0] & 0x00040000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_supported_apetureblock() {
            _has_bits_[0] |= 0x00040000u;
        }
        inline void RtTpsProtoMachine::clear_has_supported_apetureblock() {
            _has_bits_[0] &= ~0x00040000u;
        }
        inline void RtTpsProtoMachine::clear_supported_apetureblock() {
            supported_apetureblock_ = false;
            clear_has_supported_apetureblock();
        }
        inline bool RtTpsProtoMachine::supported_apetureblock() const {
            return supported_apetureblock_;
        }
        inline void RtTpsProtoMachine::set_supported_apetureblock(bool value) {
            set_has_supported_apetureblock();
            supported_apetureblock_ = value;
        }

        // optional bool supported_shieldblock = 20;
        inline bool RtTpsProtoMachine::has_supported_shieldblock() const {
            return (_has_bits_[0] & 0x00080000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_supported_shieldblock() {
            _has_bits_[0] |= 0x00080000u;
        }
        inline void RtTpsProtoMachine::clear_has_supported_shieldblock() {
            _has_bits_[0] &= ~0x00080000u;
        }
        inline void RtTpsProtoMachine::clear_supported_shieldblock() {
            supported_shieldblock_ = false;
            clear_has_supported_shieldblock();
        }
        inline bool RtTpsProtoMachine::supported_shieldblock() const {
            return supported_shieldblock_;
        }
        inline void RtTpsProtoMachine::set_supported_shieldblock(bool value) {
            set_has_supported_shieldblock();
            supported_shieldblock_ = value;
        }

        // optional bool supported_xjaw = 21;
        inline bool RtTpsProtoMachine::has_supported_xjaw() const {
            return (_has_bits_[0] & 0x00100000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_supported_xjaw() {
            _has_bits_[0] |= 0x00100000u;
        }
        inline void RtTpsProtoMachine::clear_has_supported_xjaw() {
            _has_bits_[0] &= ~0x00100000u;
        }
        inline void RtTpsProtoMachine::clear_supported_xjaw() {
            supported_xjaw_ = false;
            clear_has_supported_xjaw();
        }
        inline bool RtTpsProtoMachine::supported_xjaw() const {
            return supported_xjaw_;
        }
        inline void RtTpsProtoMachine::set_supported_xjaw(bool value) {
            set_has_supported_xjaw();
            supported_xjaw_ = value;
        }

        // optional bool supported_yjaw = 22;
        inline bool RtTpsProtoMachine::has_supported_yjaw() const {
            return (_has_bits_[0] & 0x00200000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_supported_yjaw() {
            _has_bits_[0] |= 0x00200000u;
        }
        inline void RtTpsProtoMachine::clear_has_supported_yjaw() {
            _has_bits_[0] &= ~0x00200000u;
        }
        inline void RtTpsProtoMachine::clear_supported_yjaw() {
            supported_yjaw_ = false;
            clear_has_supported_yjaw();
        }
        inline bool RtTpsProtoMachine::supported_yjaw() const {
            return supported_yjaw_;
        }
        inline void RtTpsProtoMachine::set_supported_yjaw(bool value) {
            set_has_supported_yjaw();
            supported_yjaw_ = value;
        }

        // optional bool xjaw_issymmetry = 23;
        inline bool RtTpsProtoMachine::has_xjaw_issymmetry() const {
            return (_has_bits_[0] & 0x00400000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_xjaw_issymmetry() {
            _has_bits_[0] |= 0x00400000u;
        }
        inline void RtTpsProtoMachine::clear_has_xjaw_issymmetry() {
            _has_bits_[0] &= ~0x00400000u;
        }
        inline void RtTpsProtoMachine::clear_xjaw_issymmetry() {
            xjaw_issymmetry_ = false;
            clear_has_xjaw_issymmetry();
        }
        inline bool RtTpsProtoMachine::xjaw_issymmetry() const {
            return xjaw_issymmetry_;
        }
        inline void RtTpsProtoMachine::set_xjaw_issymmetry(bool value) {
            set_has_xjaw_issymmetry();
            xjaw_issymmetry_ = value;
        }

        // optional bool yjaw_issymmetry = 24;
        inline bool RtTpsProtoMachine::has_yjaw_issymmetry() const {
            return (_has_bits_[0] & 0x00800000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_yjaw_issymmetry() {
            _has_bits_[0] |= 0x00800000u;
        }
        inline void RtTpsProtoMachine::clear_has_yjaw_issymmetry() {
            _has_bits_[0] &= ~0x00800000u;
        }
        inline void RtTpsProtoMachine::clear_yjaw_issymmetry() {
            yjaw_issymmetry_ = false;
            clear_has_yjaw_issymmetry();
        }
        inline bool RtTpsProtoMachine::yjaw_issymmetry() const {
            return yjaw_issymmetry_;
        }
        inline void RtTpsProtoMachine::set_yjaw_issymmetry(bool value) {
            set_has_yjaw_issymmetry();
            yjaw_issymmetry_ = value;
        }

        // optional bool xjaw_tracking = 25;
        inline bool RtTpsProtoMachine::has_xjaw_tracking() const {
            return (_has_bits_[0] & 0x01000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_xjaw_tracking() {
            _has_bits_[0] |= 0x01000000u;
        }
        inline void RtTpsProtoMachine::clear_has_xjaw_tracking() {
            _has_bits_[0] &= ~0x01000000u;
        }
        inline void RtTpsProtoMachine::clear_xjaw_tracking() {
            xjaw_tracking_ = false;
            clear_has_xjaw_tracking();
        }
        inline bool RtTpsProtoMachine::xjaw_tracking() const {
            return xjaw_tracking_;
        }
        inline void RtTpsProtoMachine::set_xjaw_tracking(bool value) {
            set_has_xjaw_tracking();
            xjaw_tracking_ = value;
        }

        // optional bool yjaw_tracking = 26;
        inline bool RtTpsProtoMachine::has_yjaw_tracking() const {
            return (_has_bits_[0] & 0x02000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_yjaw_tracking() {
            _has_bits_[0] |= 0x02000000u;
        }
        inline void RtTpsProtoMachine::clear_has_yjaw_tracking() {
            _has_bits_[0] &= ~0x02000000u;
        }
        inline void RtTpsProtoMachine::clear_yjaw_tracking() {
            yjaw_tracking_ = false;
            clear_has_yjaw_tracking();
        }
        inline bool RtTpsProtoMachine::yjaw_tracking() const {
            return yjaw_tracking_;
        }
        inline void RtTpsProtoMachine::set_yjaw_tracking(bool value) {
            set_has_yjaw_tracking();
            yjaw_tracking_ = value;
        }

        // optional .tps.proto.RtTpsMlcSetting mlcsetting = 27;
        inline bool RtTpsProtoMachine::has_mlcsetting() const {
            return (_has_bits_[0] & 0x04000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_mlcsetting() {
            _has_bits_[0] |= 0x04000000u;
        }
        inline void RtTpsProtoMachine::clear_has_mlcsetting() {
            _has_bits_[0] &= ~0x04000000u;
        }
        inline void RtTpsProtoMachine::clear_mlcsetting() {
            if (mlcsetting_ != NULL) mlcsetting_->::tps::proto::RtTpsMlcSetting::Clear();
            clear_has_mlcsetting();
        }
        inline const ::tps::proto::RtTpsMlcSetting& RtTpsProtoMachine::mlcsetting() const {
            return mlcsetting_ != NULL ? *mlcsetting_ : *default_instance_->mlcsetting_;
        }
        inline ::tps::proto::RtTpsMlcSetting* RtTpsProtoMachine::mutable_mlcsetting() {
            set_has_mlcsetting();
            if (mlcsetting_ == NULL) mlcsetting_ = new ::tps::proto::RtTpsMlcSetting;
            return mlcsetting_;
        }
        inline ::tps::proto::RtTpsMlcSetting* RtTpsProtoMachine::release_mlcsetting() {
            clear_has_mlcsetting();
            ::tps::proto::RtTpsMlcSetting* temp = mlcsetting_;
            mlcsetting_ = NULL;
            return temp;
        }

        // optional float sourcetoblocktraydistance = 28;
        inline bool RtTpsProtoMachine::has_sourcetoblocktraydistance() const {
            return (_has_bits_[0] & 0x08000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_sourcetoblocktraydistance() {
            _has_bits_[0] |= 0x08000000u;
        }
        inline void RtTpsProtoMachine::clear_has_sourcetoblocktraydistance() {
            _has_bits_[0] &= ~0x08000000u;
        }
        inline void RtTpsProtoMachine::clear_sourcetoblocktraydistance() {
            sourcetoblocktraydistance_ = 0;
            clear_has_sourcetoblocktraydistance();
        }
        inline float RtTpsProtoMachine::sourcetoblocktraydistance() const {
            return sourcetoblocktraydistance_;
        }
        inline void RtTpsProtoMachine::set_sourcetoblocktraydistance(float value) {
            set_has_sourcetoblocktraydistance();
            sourcetoblocktraydistance_ = value;
        }

        // optional bool isActive = 29;
        inline bool RtTpsProtoMachine::has_isactive() const {
            return (_has_bits_[0] & 0x10000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_isactive() {
            _has_bits_[0] |= 0x10000000u;
        }
        inline void RtTpsProtoMachine::clear_has_isactive() {
            _has_bits_[0] &= ~0x10000000u;
        }
        inline void RtTpsProtoMachine::clear_isactive() {
            isactive_ = false;
            clear_has_isactive();
        }
        inline bool RtTpsProtoMachine::isactive() const {
            return isactive_;
        }
        inline void RtTpsProtoMachine::set_isactive(bool value) {
            set_has_isactive();
            isactive_ = value;
        }

        // optional bool isForceJawFollow = 30;
        inline bool RtTpsProtoMachine::has_isforcejawfollow() const {
            return (_has_bits_[0] & 0x20000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_isforcejawfollow() {
            _has_bits_[0] |= 0x20000000u;
        }
        inline void RtTpsProtoMachine::clear_has_isforcejawfollow() {
            _has_bits_[0] &= ~0x20000000u;
        }
        inline void RtTpsProtoMachine::clear_isforcejawfollow() {
            isforcejawfollow_ = false;
            clear_has_isforcejawfollow();
        }
        inline bool RtTpsProtoMachine::isforcejawfollow() const {
            return isforcejawfollow_;
        }
        inline void RtTpsProtoMachine::set_isforcejawfollow(bool value) {
            set_has_isforcejawfollow();
            isforcejawfollow_ = value;
        }

        // optional bool isCrcValid = 31;
        inline bool RtTpsProtoMachine::has_iscrcvalid() const {
            return (_has_bits_[0] & 0x40000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_iscrcvalid() {
            _has_bits_[0] |= 0x40000000u;
        }
        inline void RtTpsProtoMachine::clear_has_iscrcvalid() {
            _has_bits_[0] &= ~0x40000000u;
        }
        inline void RtTpsProtoMachine::clear_iscrcvalid() {
            iscrcvalid_ = false;
            clear_has_iscrcvalid();
        }
        inline bool RtTpsProtoMachine::iscrcvalid() const {
            return iscrcvalid_;
        }
        inline void RtTpsProtoMachine::set_iscrcvalid(bool value) {
            set_has_iscrcvalid();
            iscrcvalid_ = value;
        }

        // optional double gantryMaxSpeed = 32;
        inline bool RtTpsProtoMachine::has_gantrymaxspeed() const {
            return (_has_bits_[0] & 0x80000000u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_gantrymaxspeed() {
            _has_bits_[0] |= 0x80000000u;
        }
        inline void RtTpsProtoMachine::clear_has_gantrymaxspeed() {
            _has_bits_[0] &= ~0x80000000u;
        }
        inline void RtTpsProtoMachine::clear_gantrymaxspeed() {
            gantrymaxspeed_ = 0;
            clear_has_gantrymaxspeed();
        }
        inline double RtTpsProtoMachine::gantrymaxspeed() const {
            return gantrymaxspeed_;
        }
        inline void RtTpsProtoMachine::set_gantrymaxspeed(double value) {
            set_has_gantrymaxspeed();
            gantrymaxspeed_ = value;
        }

        // optional double blockHeight = 33;
        inline bool RtTpsProtoMachine::has_blockheight() const {
            return (_has_bits_[1] & 0x00000001u) != 0;
        }
        inline void RtTpsProtoMachine::set_has_blockheight() {
            _has_bits_[1] |= 0x00000001u;
        }
        inline void RtTpsProtoMachine::clear_has_blockheight() {
            _has_bits_[1] &= ~0x00000001u;
        }
        inline void RtTpsProtoMachine::clear_blockheight() {
            blockheight_ = 0;
            clear_has_blockheight();
        }
        inline double RtTpsProtoMachine::blockheight() const {
            return blockheight_;
        }
        inline void RtTpsProtoMachine::set_blockheight(double value) {
            set_has_blockheight();
            blockheight_ = value;
        }

        // -------------------------------------------------------------------

        // RtTpsMlcSetting

        // optional int32 numberOfPairs = 1;
        inline bool RtTpsMlcSetting::has_numberofpairs() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_numberofpairs() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void RtTpsMlcSetting::clear_has_numberofpairs() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void RtTpsMlcSetting::clear_numberofpairs() {
            numberofpairs_ = 0;
            clear_has_numberofpairs();
        }
        inline ::google::protobuf::int32 RtTpsMlcSetting::numberofpairs() const {
            return numberofpairs_;
        }
        inline void RtTpsMlcSetting::set_numberofpairs(::google::protobuf::int32 value) {
            set_has_numberofpairs();
            numberofpairs_ = value;
        }

        // optional double sourceToMLCtopDistance = 2;
        inline bool RtTpsMlcSetting::has_sourcetomlctopdistance() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_sourcetomlctopdistance() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void RtTpsMlcSetting::clear_has_sourcetomlctopdistance() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void RtTpsMlcSetting::clear_sourcetomlctopdistance() {
            sourcetomlctopdistance_ = 0;
            clear_has_sourcetomlctopdistance();
        }
        inline double RtTpsMlcSetting::sourcetomlctopdistance() const {
            return sourcetomlctopdistance_;
        }
        inline void RtTpsMlcSetting::set_sourcetomlctopdistance(double value) {
            set_has_sourcetomlctopdistance();
            sourcetomlctopdistance_ = value;
        }

        // optional double minLeafJawOverlap = 3;
        inline bool RtTpsMlcSetting::has_minleafjawoverlap() const {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_minleafjawoverlap() {
            _has_bits_[0] |= 0x00000004u;
        }
        inline void RtTpsMlcSetting::clear_has_minleafjawoverlap() {
            _has_bits_[0] &= ~0x00000004u;
        }
        inline void RtTpsMlcSetting::clear_minleafjawoverlap() {
            minleafjawoverlap_ = 0;
            clear_has_minleafjawoverlap();
        }
        inline double RtTpsMlcSetting::minleafjawoverlap() const {
            return minleafjawoverlap_;
        }
        inline void RtTpsMlcSetting::set_minleafjawoverlap(double value) {
            set_has_minleafjawoverlap();
            minleafjawoverlap_ = value;
        }

        // optional double minGap = 4;
        inline bool RtTpsMlcSetting::has_mingap() const {
            return (_has_bits_[0] & 0x00000008u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_mingap() {
            _has_bits_[0] |= 0x00000008u;
        }
        inline void RtTpsMlcSetting::clear_has_mingap() {
            _has_bits_[0] &= ~0x00000008u;
        }
        inline void RtTpsMlcSetting::clear_mingap() {
            mingap_ = 0;
            clear_has_mingap();
        }
        inline double RtTpsMlcSetting::mingap() const {
            return mingap_;
        }
        inline void RtTpsMlcSetting::set_mingap(double value) {
            set_has_mingap();
            mingap_ = value;
        }

        // optional double maxLeafSpeed = 5;
        inline bool RtTpsMlcSetting::has_maxleafspeed() const {
            return (_has_bits_[0] & 0x00000010u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_maxleafspeed() {
            _has_bits_[0] |= 0x00000010u;
        }
        inline void RtTpsMlcSetting::clear_has_maxleafspeed() {
            _has_bits_[0] &= ~0x00000010u;
        }
        inline void RtTpsMlcSetting::clear_maxleafspeed() {
            maxleafspeed_ = 0;
            clear_has_maxleafspeed();
        }
        inline double RtTpsMlcSetting::maxleafspeed() const {
            return maxleafspeed_;
        }
        inline void RtTpsMlcSetting::set_maxleafspeed(double value) {
            set_has_maxleafspeed();
            maxleafspeed_ = value;
        }

        // optional double minTipPosition = 6;
        inline bool RtTpsMlcSetting::has_mintipposition() const {
            return (_has_bits_[0] & 0x00000020u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_mintipposition() {
            _has_bits_[0] |= 0x00000020u;
        }
        inline void RtTpsMlcSetting::clear_has_mintipposition() {
            _has_bits_[0] &= ~0x00000020u;
        }
        inline void RtTpsMlcSetting::clear_mintipposition() {
            mintipposition_ = 0;
            clear_has_mintipposition();
        }
        inline double RtTpsMlcSetting::mintipposition() const {
            return mintipposition_;
        }
        inline void RtTpsMlcSetting::set_mintipposition(double value) {
            set_has_mintipposition();
            mintipposition_ = value;
        }

        // optional double maxTipPosition = 7;
        inline bool RtTpsMlcSetting::has_maxtipposition() const {
            return (_has_bits_[0] & 0x00000040u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_maxtipposition() {
            _has_bits_[0] |= 0x00000040u;
        }
        inline void RtTpsMlcSetting::clear_has_maxtipposition() {
            _has_bits_[0] &= ~0x00000040u;
        }
        inline void RtTpsMlcSetting::clear_maxtipposition() {
            maxtipposition_ = 0;
            clear_has_maxtipposition();
        }
        inline double RtTpsMlcSetting::maxtipposition() const {
            return maxtipposition_;
        }
        inline void RtTpsMlcSetting::set_maxtipposition(double value) {
            set_has_maxtipposition();
            maxtipposition_ = value;
        }

        // optional bool leafInterdigitation = 8;
        inline bool RtTpsMlcSetting::has_leafinterdigitation() const {
            return (_has_bits_[0] & 0x00000080u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_leafinterdigitation() {
            _has_bits_[0] |= 0x00000080u;
        }
        inline void RtTpsMlcSetting::clear_has_leafinterdigitation() {
            _has_bits_[0] &= ~0x00000080u;
        }
        inline void RtTpsMlcSetting::clear_leafinterdigitation() {
            leafinterdigitation_ = false;
            clear_has_leafinterdigitation();
        }
        inline bool RtTpsMlcSetting::leafinterdigitation() const {
            return leafinterdigitation_;
        }
        inline void RtTpsMlcSetting::set_leafinterdigitation(bool value) {
            set_has_leafinterdigitation();
            leafinterdigitation_ = value;
        }

        // optional double maxLeafoutofCarriageDistance = 9;
        inline bool RtTpsMlcSetting::has_maxleafoutofcarriagedistance() const {
            return (_has_bits_[0] & 0x00000100u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_maxleafoutofcarriagedistance() {
            _has_bits_[0] |= 0x00000100u;
        }
        inline void RtTpsMlcSetting::clear_has_maxleafoutofcarriagedistance() {
            _has_bits_[0] &= ~0x00000100u;
        }
        inline void RtTpsMlcSetting::clear_maxleafoutofcarriagedistance() {
            maxleafoutofcarriagedistance_ = 0;
            clear_has_maxleafoutofcarriagedistance();
        }
        inline double RtTpsMlcSetting::maxleafoutofcarriagedistance() const {
            return maxleafoutofcarriagedistance_;
        }
        inline void RtTpsMlcSetting::set_maxleafoutofcarriagedistance(double value) {
            set_has_maxleafoutofcarriagedistance();
            maxleafoutofcarriagedistance_ = value;
        }

        // optional int32 mlcDirection = 10;
        inline bool RtTpsMlcSetting::has_mlcdirection() const {
            return (_has_bits_[0] & 0x00000200u) != 0;
        }
        inline void RtTpsMlcSetting::set_has_mlcdirection() {
            _has_bits_[0] |= 0x00000200u;
        }
        inline void RtTpsMlcSetting::clear_has_mlcdirection() {
            _has_bits_[0] &= ~0x00000200u;
        }
        inline void RtTpsMlcSetting::clear_mlcdirection() {
            mlcdirection_ = 0;
            clear_has_mlcdirection();
        }
        inline ::google::protobuf::int32 RtTpsMlcSetting::mlcdirection() const {
            return mlcdirection_;
        }
        inline void RtTpsMlcSetting::set_mlcdirection(::google::protobuf::int32 value) {
            set_has_mlcdirection();
            mlcdirection_ = value;
        }

        // repeated double leafpairupperboundary = 11;
        inline int RtTpsMlcSetting::leafpairupperboundary_size() const {
            return leafpairupperboundary_.size();
        }
        inline void RtTpsMlcSetting::clear_leafpairupperboundary() {
            leafpairupperboundary_.Clear();
        }
        inline double RtTpsMlcSetting::leafpairupperboundary(int index) const {
            return leafpairupperboundary_.Get(index);
        }
        inline void RtTpsMlcSetting::set_leafpairupperboundary(int index, double value) {
            leafpairupperboundary_.Set(index, value);
        }
        inline void RtTpsMlcSetting::add_leafpairupperboundary(double value) {
            leafpairupperboundary_.Add(value);
        }
        inline const ::google::protobuf::RepeatedField< double >&
            RtTpsMlcSetting::leafpairupperboundary() const {
                return leafpairupperboundary_;
        }
        inline ::google::protobuf::RepeatedField< double >*
            RtTpsMlcSetting::mutable_leafpairupperboundary() {
                return &leafpairupperboundary_;
        }

        // -------------------------------------------------------------------

        // RtTpsProtoRepeatedMachine

        // repeated .tps.proto.RtTpsProtoMachine machineList = 1;
        inline int RtTpsProtoRepeatedMachine::machinelist_size() const {
            return machinelist_.size();
        }
        inline void RtTpsProtoRepeatedMachine::clear_machinelist() {
            machinelist_.Clear();
        }
        inline const ::tps::proto::RtTpsProtoMachine& RtTpsProtoRepeatedMachine::machinelist(int index) const {
            return machinelist_.Get(index);
        }
        inline ::tps::proto::RtTpsProtoMachine* RtTpsProtoRepeatedMachine::mutable_machinelist(int index) {
            return machinelist_.Mutable(index);
        }
        inline ::tps::proto::RtTpsProtoMachine* RtTpsProtoRepeatedMachine::add_machinelist() {
            return machinelist_.Add();
        }
        inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMachine >&
            RtTpsProtoRepeatedMachine::machinelist() const {
                return machinelist_;
        }
        inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoMachine >*
            RtTpsProtoRepeatedMachine::mutable_machinelist() {
                return &machinelist_;
        }


        // @@protoc_insertion_point(namespace_scope)

    }  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
    namespace protobuf {


    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fproto_5fmachine_2eproto__INCLUDED
