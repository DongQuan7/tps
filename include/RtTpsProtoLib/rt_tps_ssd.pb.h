// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_ssd.proto

#ifndef PROTOBUF_rt_5ftps_5fssd_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fssd_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace tps {
    namespace proto {

        // Internal implementation detail -- do not call these.
        void  protobuf_AddDesc_rt_5ftps_5fssd_2eproto();
        void protobuf_AssignDesc_rt_5ftps_5fssd_2eproto();
        void protobuf_ShutdownFile_rt_5ftps_5fssd_2eproto();

        class RT_TPS_SSD;

        // ===================================================================

        class RT_TPS_SSD : public ::google::protobuf::Message {
        public:
            RT_TPS_SSD();
            virtual ~RT_TPS_SSD();

            RT_TPS_SSD(const RT_TPS_SSD& from);

            inline RT_TPS_SSD& operator=(const RT_TPS_SSD& from) {
                CopyFrom(from);
                return *this;
            }

            inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
                return _unknown_fields_;
            }

            inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
                return &_unknown_fields_;
            }

            static const ::google::protobuf::Descriptor* descriptor();
            static const RT_TPS_SSD& default_instance();

            void Swap(RT_TPS_SSD* other);

            // implements Message ----------------------------------------------

            RT_TPS_SSD* New() const;
            void CopyFrom(const ::google::protobuf::Message& from);
            void MergeFrom(const ::google::protobuf::Message& from);
            void CopyFrom(const RT_TPS_SSD& from);
            void MergeFrom(const RT_TPS_SSD& from);
            void Clear();
            bool IsInitialized() const;

            int ByteSize() const;
            bool MergePartialFromCodedStream(
                ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                ::google::protobuf::io::CodedOutputStream* output) const;
            ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:

            ::google::protobuf::Metadata GetMetadata() const;

            // nested types ----------------------------------------------------

            // accessors -------------------------------------------------------

            // optional float ssd = 1;
            inline bool has_ssd() const;
            inline void clear_ssd();
            static const int kSsdFieldNumber = 1;
            inline float ssd() const;
            inline void set_ssd(float value);

            // optional float ssdRangeMin = 2;
            inline bool has_ssdrangemin() const;
            inline void clear_ssdrangemin();
            static const int kSsdRangeMinFieldNumber = 2;
            inline float ssdrangemin() const;
            inline void set_ssdrangemin(float value);

            // optional float ssdRangeMax = 3;
            inline bool has_ssdrangemax() const;
            inline void clear_ssdrangemax();
            static const int kSsdRangeMaxFieldNumber = 3;
            inline float ssdrangemax() const;
            inline void set_ssdrangemax(float value);

            // optional float originalx = 4;
            inline bool has_originalx() const;
            inline void clear_originalx();
            static const int kOriginalxFieldNumber = 4;
            inline float originalx() const;
            inline void set_originalx(float value);

            // optional float originaly = 5;
            inline bool has_originaly() const;
            inline void clear_originaly();
            static const int kOriginalyFieldNumber = 5;
            inline float originaly() const;
            inline void set_originaly(float value);

            // optional float originalz = 6;
            inline bool has_originalz() const;
            inline void clear_originalz();
            static const int kOriginalzFieldNumber = 6;
            inline float originalz() const;
            inline void set_originalz(float value);

            // @@protoc_insertion_point(class_scope:tps.proto.RT_TPS_SSD)
        private:
            inline void set_has_ssd();
            inline void clear_has_ssd();
            inline void set_has_ssdrangemin();
            inline void clear_has_ssdrangemin();
            inline void set_has_ssdrangemax();
            inline void clear_has_ssdrangemax();
            inline void set_has_originalx();
            inline void clear_has_originalx();
            inline void set_has_originaly();
            inline void clear_has_originaly();
            inline void set_has_originalz();
            inline void clear_has_originalz();

            ::google::protobuf::UnknownFieldSet _unknown_fields_;

            float ssd_;
            float ssdrangemin_;
            float ssdrangemax_;
            float originalx_;
            float originaly_;
            float originalz_;

            mutable int _cached_size_;
            ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

            friend void  protobuf_AddDesc_rt_5ftps_5fssd_2eproto();
            friend void protobuf_AssignDesc_rt_5ftps_5fssd_2eproto();
            friend void protobuf_ShutdownFile_rt_5ftps_5fssd_2eproto();

            void InitAsDefaultInstance();
            static RT_TPS_SSD* default_instance_;
        };
        // ===================================================================


        // ===================================================================

        // RT_TPS_SSD

        // optional float ssd = 1;
        inline bool RT_TPS_SSD::has_ssd() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void RT_TPS_SSD::set_has_ssd() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void RT_TPS_SSD::clear_has_ssd() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void RT_TPS_SSD::clear_ssd() {
            ssd_ = 0;
            clear_has_ssd();
        }
        inline float RT_TPS_SSD::ssd() const {
            return ssd_;
        }
        inline void RT_TPS_SSD::set_ssd(float value) {
            set_has_ssd();
            ssd_ = value;
        }

        // optional float ssdRangeMin = 2;
        inline bool RT_TPS_SSD::has_ssdrangemin() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void RT_TPS_SSD::set_has_ssdrangemin() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void RT_TPS_SSD::clear_has_ssdrangemin() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void RT_TPS_SSD::clear_ssdrangemin() {
            ssdrangemin_ = 0;
            clear_has_ssdrangemin();
        }
        inline float RT_TPS_SSD::ssdrangemin() const {
            return ssdrangemin_;
        }
        inline void RT_TPS_SSD::set_ssdrangemin(float value) {
            set_has_ssdrangemin();
            ssdrangemin_ = value;
        }

        // optional float ssdRangeMax = 3;
        inline bool RT_TPS_SSD::has_ssdrangemax() const {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        inline void RT_TPS_SSD::set_has_ssdrangemax() {
            _has_bits_[0] |= 0x00000004u;
        }
        inline void RT_TPS_SSD::clear_has_ssdrangemax() {
            _has_bits_[0] &= ~0x00000004u;
        }
        inline void RT_TPS_SSD::clear_ssdrangemax() {
            ssdrangemax_ = 0;
            clear_has_ssdrangemax();
        }
        inline float RT_TPS_SSD::ssdrangemax() const {
            return ssdrangemax_;
        }
        inline void RT_TPS_SSD::set_ssdrangemax(float value) {
            set_has_ssdrangemax();
            ssdrangemax_ = value;
        }

        // optional float originalx = 4;
        inline bool RT_TPS_SSD::has_originalx() const {
            return (_has_bits_[0] & 0x00000008u) != 0;
        }
        inline void RT_TPS_SSD::set_has_originalx() {
            _has_bits_[0] |= 0x00000008u;
        }
        inline void RT_TPS_SSD::clear_has_originalx() {
            _has_bits_[0] &= ~0x00000008u;
        }
        inline void RT_TPS_SSD::clear_originalx() {
            originalx_ = 0;
            clear_has_originalx();
        }
        inline float RT_TPS_SSD::originalx() const {
            return originalx_;
        }
        inline void RT_TPS_SSD::set_originalx(float value) {
            set_has_originalx();
            originalx_ = value;
        }

        // optional float originaly = 5;
        inline bool RT_TPS_SSD::has_originaly() const {
            return (_has_bits_[0] & 0x00000010u) != 0;
        }
        inline void RT_TPS_SSD::set_has_originaly() {
            _has_bits_[0] |= 0x00000010u;
        }
        inline void RT_TPS_SSD::clear_has_originaly() {
            _has_bits_[0] &= ~0x00000010u;
        }
        inline void RT_TPS_SSD::clear_originaly() {
            originaly_ = 0;
            clear_has_originaly();
        }
        inline float RT_TPS_SSD::originaly() const {
            return originaly_;
        }
        inline void RT_TPS_SSD::set_originaly(float value) {
            set_has_originaly();
            originaly_ = value;
        }

        // optional float originalz = 6;
        inline bool RT_TPS_SSD::has_originalz() const {
            return (_has_bits_[0] & 0x00000020u) != 0;
        }
        inline void RT_TPS_SSD::set_has_originalz() {
            _has_bits_[0] |= 0x00000020u;
        }
        inline void RT_TPS_SSD::clear_has_originalz() {
            _has_bits_[0] &= ~0x00000020u;
        }
        inline void RT_TPS_SSD::clear_originalz() {
            originalz_ = 0;
            clear_has_originalz();
        }
        inline float RT_TPS_SSD::originalz() const {
            return originalz_;
        }
        inline void RT_TPS_SSD::set_originalz(float value) {
            set_has_originalz();
            originalz_ = value;
        }


        // @@protoc_insertion_point(namespace_scope)

    }  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
    namespace protobuf {


    }  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fssd_2eproto__INCLUDED
