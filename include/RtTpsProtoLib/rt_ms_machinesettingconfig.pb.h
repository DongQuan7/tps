// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_ms_machinesettingconfig.proto

#ifndef PROTOBUF_rt_5fms_5fmachinesettingconfig_2eproto__INCLUDED
#define PROTOBUF_rt_5fms_5fmachinesettingconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "rt_ms_photonsmontecarlo.pb.h"
// @@protoc_insertion_point(includes)

namespace ms {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();

class RT_MS_MachineSettingInfoList;
class RT_MS_CommissionList;
class RT_MS_MachineConfigInfo;
class RT_MS_MachineGeneral;
class RT_MS_MachineGeometry;
class RT_MS_MachineJaw;
class RT_MS_PairInfo;
class RT_MS_MachineMLC;
class RT_MS_CommissionInfo;
class RT_MS_MachineBeamModeDoseRate;
class RT_MS_MachineTray;
class RT_MS_MachineAccessories;
class RT_MS_MachineElectronApplicator;
class RT_MS_MachineMotorizedWedge;
class RT_MS_MachineWedge;

// ===================================================================

class RT_MS_MachineSettingInfoList : public ::google::protobuf::Message {
 public:
  RT_MS_MachineSettingInfoList();
  virtual ~RT_MS_MachineSettingInfoList();
  
  RT_MS_MachineSettingInfoList(const RT_MS_MachineSettingInfoList& from);
  
  inline RT_MS_MachineSettingInfoList& operator=(const RT_MS_MachineSettingInfoList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineSettingInfoList& default_instance();
  
  void Swap(RT_MS_MachineSettingInfoList* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineSettingInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineSettingInfoList& from);
  void MergeFrom(const RT_MS_MachineSettingInfoList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ms.proto.RT_MS_MachineConfigInfo machineSettingList = 1;
  inline int machinesettinglist_size() const;
  inline void clear_machinesettinglist();
  static const int kMachineSettingListFieldNumber = 1;
  inline const ::ms::proto::RT_MS_MachineConfigInfo& machinesettinglist(int index) const;
  inline ::ms::proto::RT_MS_MachineConfigInfo* mutable_machinesettinglist(int index);
  inline ::ms::proto::RT_MS_MachineConfigInfo* add_machinesettinglist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineConfigInfo >&
      machinesettinglist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineConfigInfo >*
      mutable_machinesettinglist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineSettingInfoList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineConfigInfo > machinesettinglist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineSettingInfoList* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_CommissionList : public ::google::protobuf::Message {
 public:
  RT_MS_CommissionList();
  virtual ~RT_MS_CommissionList();
  
  RT_MS_CommissionList(const RT_MS_CommissionList& from);
  
  inline RT_MS_CommissionList& operator=(const RT_MS_CommissionList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_CommissionList& default_instance();
  
  void Swap(RT_MS_CommissionList* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_CommissionList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_CommissionList& from);
  void MergeFrom(const RT_MS_CommissionList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .ms.proto.RT_MS_CommissionInfo machineCommissionInfo = 1;
  inline int machinecommissioninfo_size() const;
  inline void clear_machinecommissioninfo();
  static const int kMachineCommissionInfoFieldNumber = 1;
  inline const ::ms::proto::RT_MS_CommissionInfo& machinecommissioninfo(int index) const;
  inline ::ms::proto::RT_MS_CommissionInfo* mutable_machinecommissioninfo(int index);
  inline ::ms::proto::RT_MS_CommissionInfo* add_machinecommissioninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >&
      machinecommissioninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >*
      mutable_machinecommissioninfo();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_CommissionList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo > machinecommissioninfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_CommissionList* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineConfigInfo : public ::google::protobuf::Message {
 public:
  RT_MS_MachineConfigInfo();
  virtual ~RT_MS_MachineConfigInfo();
  
  RT_MS_MachineConfigInfo(const RT_MS_MachineConfigInfo& from);
  
  inline RT_MS_MachineConfigInfo& operator=(const RT_MS_MachineConfigInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineConfigInfo& default_instance();
  
  void Swap(RT_MS_MachineConfigInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineConfigInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineConfigInfo& from);
  void MergeFrom(const RT_MS_MachineConfigInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ms.proto.RT_MS_MachineGeneral machineGeneralInfo = 1;
  inline bool has_machinegeneralinfo() const;
  inline void clear_machinegeneralinfo();
  static const int kMachineGeneralInfoFieldNumber = 1;
  inline const ::ms::proto::RT_MS_MachineGeneral& machinegeneralinfo() const;
  inline ::ms::proto::RT_MS_MachineGeneral* mutable_machinegeneralinfo();
  inline ::ms::proto::RT_MS_MachineGeneral* release_machinegeneralinfo();
  
  // optional .ms.proto.RT_MS_MachineGeometry machineGeometry = 2;
  inline bool has_machinegeometry() const;
  inline void clear_machinegeometry();
  static const int kMachineGeometryFieldNumber = 2;
  inline const ::ms::proto::RT_MS_MachineGeometry& machinegeometry() const;
  inline ::ms::proto::RT_MS_MachineGeometry* mutable_machinegeometry();
  inline ::ms::proto::RT_MS_MachineGeometry* release_machinegeometry();
  
  // optional .ms.proto.RT_MS_MachineJaw machineJaw = 3;
  inline bool has_machinejaw() const;
  inline void clear_machinejaw();
  static const int kMachineJawFieldNumber = 3;
  inline const ::ms::proto::RT_MS_MachineJaw& machinejaw() const;
  inline ::ms::proto::RT_MS_MachineJaw* mutable_machinejaw();
  inline ::ms::proto::RT_MS_MachineJaw* release_machinejaw();
  
  // optional .ms.proto.RT_MS_MachineMLC machineMLC = 4;
  inline bool has_machinemlc() const;
  inline void clear_machinemlc();
  static const int kMachineMLCFieldNumber = 4;
  inline const ::ms::proto::RT_MS_MachineMLC& machinemlc() const;
  inline ::ms::proto::RT_MS_MachineMLC* mutable_machinemlc();
  inline ::ms::proto::RT_MS_MachineMLC* release_machinemlc();
  
  // optional .ms.proto.RT_MS_MachineAccessories machineAccessories = 5;
  inline bool has_machineaccessories() const;
  inline void clear_machineaccessories();
  static const int kMachineAccessoriesFieldNumber = 5;
  inline const ::ms::proto::RT_MS_MachineAccessories& machineaccessories() const;
  inline ::ms::proto::RT_MS_MachineAccessories* mutable_machineaccessories();
  inline ::ms::proto::RT_MS_MachineAccessories* release_machineaccessories();
  
  // optional bool isApprove = 6;
  inline bool has_isapprove() const;
  inline void clear_isapprove();
  static const int kIsApproveFieldNumber = 6;
  inline bool isapprove() const;
  inline void set_isapprove(bool value);
  
  // optional bool isActive = 7;
  inline bool has_isactive() const;
  inline void clear_isactive();
  static const int kIsActiveFieldNumber = 7;
  inline bool isactive() const;
  inline void set_isactive(bool value);
  
  // repeated .ms.proto.RT_MS_CommissionInfo machineCommissionInfo = 8;
  inline int machinecommissioninfo_size() const;
  inline void clear_machinecommissioninfo();
  static const int kMachineCommissionInfoFieldNumber = 8;
  inline const ::ms::proto::RT_MS_CommissionInfo& machinecommissioninfo(int index) const;
  inline ::ms::proto::RT_MS_CommissionInfo* mutable_machinecommissioninfo(int index);
  inline ::ms::proto::RT_MS_CommissionInfo* add_machinecommissioninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >&
      machinecommissioninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >*
      mutable_machinecommissioninfo();
  
  // optional bool isCrcValid = 9;
  inline bool has_iscrcvalid() const;
  inline void clear_iscrcvalid();
  static const int kIsCrcValidFieldNumber = 9;
  inline bool iscrcvalid() const;
  inline void set_iscrcvalid(bool value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineConfigInfo)
 private:
  inline void set_has_machinegeneralinfo();
  inline void clear_has_machinegeneralinfo();
  inline void set_has_machinegeometry();
  inline void clear_has_machinegeometry();
  inline void set_has_machinejaw();
  inline void clear_has_machinejaw();
  inline void set_has_machinemlc();
  inline void clear_has_machinemlc();
  inline void set_has_machineaccessories();
  inline void clear_has_machineaccessories();
  inline void set_has_isapprove();
  inline void clear_has_isapprove();
  inline void set_has_isactive();
  inline void clear_has_isactive();
  inline void set_has_iscrcvalid();
  inline void clear_has_iscrcvalid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ms::proto::RT_MS_MachineGeneral* machinegeneralinfo_;
  ::ms::proto::RT_MS_MachineGeometry* machinegeometry_;
  ::ms::proto::RT_MS_MachineJaw* machinejaw_;
  ::ms::proto::RT_MS_MachineMLC* machinemlc_;
  ::ms::proto::RT_MS_MachineAccessories* machineaccessories_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo > machinecommissioninfo_;
  bool isapprove_;
  bool isactive_;
  bool iscrcvalid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineConfigInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineGeneral : public ::google::protobuf::Message {
 public:
  RT_MS_MachineGeneral();
  virtual ~RT_MS_MachineGeneral();
  
  RT_MS_MachineGeneral(const RT_MS_MachineGeneral& from);
  
  inline RT_MS_MachineGeneral& operator=(const RT_MS_MachineGeneral& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineGeneral& default_instance();
  
  void Swap(RT_MS_MachineGeneral* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineGeneral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineGeneral& from);
  void MergeFrom(const RT_MS_MachineGeneral& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string machineName = 1;
  inline bool has_machinename() const;
  inline void clear_machinename();
  static const int kMachineNameFieldNumber = 1;
  inline const ::std::string& machinename() const;
  inline void set_machinename(const ::std::string& value);
  inline void set_machinename(const char* value);
  inline void set_machinename(const char* value, size_t size);
  inline ::std::string* mutable_machinename();
  inline ::std::string* release_machinename();
  
  // optional string manufactory = 2;
  inline bool has_manufactory() const;
  inline void clear_manufactory();
  static const int kManufactoryFieldNumber = 2;
  inline const ::std::string& manufactory() const;
  inline void set_manufactory(const ::std::string& value);
  inline void set_manufactory(const char* value);
  inline void set_manufactory(const char* value, size_t size);
  inline ::std::string* mutable_manufactory();
  inline ::std::string* release_manufactory();
  
  // optional string DeviceID = 3;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIDFieldNumber = 3;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  
  // optional string coordinationSystem = 4;
  inline bool has_coordinationsystem() const;
  inline void clear_coordinationsystem();
  static const int kCoordinationSystemFieldNumber = 4;
  inline const ::std::string& coordinationsystem() const;
  inline void set_coordinationsystem(const ::std::string& value);
  inline void set_coordinationsystem(const char* value);
  inline void set_coordinationsystem(const char* value, size_t size);
  inline ::std::string* mutable_coordinationsystem();
  inline ::std::string* release_coordinationsystem();
  
  // optional string date = 5;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 5;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // optional string time = 6;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 6;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  
  // optional string byWho = 7;
  inline bool has_bywho() const;
  inline void clear_bywho();
  static const int kByWhoFieldNumber = 7;
  inline const ::std::string& bywho() const;
  inline void set_bywho(const ::std::string& value);
  inline void set_bywho(const char* value);
  inline void set_bywho(const char* value, size_t size);
  inline ::std::string* mutable_bywho();
  inline ::std::string* release_bywho();
  
  // optional string comments = 8;
  inline bool has_comments() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 8;
  inline const ::std::string& comments() const;
  inline void set_comments(const ::std::string& value);
  inline void set_comments(const char* value);
  inline void set_comments(const char* value, size_t size);
  inline ::std::string* mutable_comments();
  inline ::std::string* release_comments();
  
  // optional string uid = 9;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 9;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineGeneral)
 private:
  inline void set_has_machinename();
  inline void clear_has_machinename();
  inline void set_has_manufactory();
  inline void clear_has_manufactory();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_coordinationsystem();
  inline void clear_has_coordinationsystem();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_bywho();
  inline void clear_has_bywho();
  inline void set_has_comments();
  inline void clear_has_comments();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* machinename_;
  ::std::string* manufactory_;
  ::std::string* deviceid_;
  ::std::string* coordinationsystem_;
  ::std::string* date_;
  ::std::string* time_;
  ::std::string* bywho_;
  ::std::string* comments_;
  ::std::string* uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineGeneral* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineGeometry : public ::google::protobuf::Message {
 public:
  RT_MS_MachineGeometry();
  virtual ~RT_MS_MachineGeometry();
  
  RT_MS_MachineGeometry(const RT_MS_MachineGeometry& from);
  
  inline RT_MS_MachineGeometry& operator=(const RT_MS_MachineGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineGeometry& default_instance();
  
  void Swap(RT_MS_MachineGeometry* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineGeometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineGeometry& from);
  void MergeFrom(const RT_MS_MachineGeometry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float gantryAngleMin = 1;
  inline bool has_gantryanglemin() const;
  inline void clear_gantryanglemin();
  static const int kGantryAngleMinFieldNumber = 1;
  inline float gantryanglemin() const;
  inline void set_gantryanglemin(float value);
  
  // optional float gantryAngleMax = 2;
  inline bool has_gantryanglemax() const;
  inline void clear_gantryanglemax();
  static const int kGantryAngleMaxFieldNumber = 2;
  inline float gantryanglemax() const;
  inline void set_gantryanglemax(float value);
  
  // optional float maxSpeedLimit = 3;
  inline bool has_maxspeedlimit() const;
  inline void clear_maxspeedlimit();
  static const int kMaxSpeedLimitFieldNumber = 3;
  inline float maxspeedlimit() const;
  inline void set_maxspeedlimit(float value);
  
  // optional float sad = 4;
  inline bool has_sad() const;
  inline void clear_sad();
  static const int kSadFieldNumber = 4;
  inline float sad() const;
  inline void set_sad(float value);
  
  // optional float cwLimit = 5;
  inline bool has_cwlimit() const;
  inline void clear_cwlimit();
  static const int kCwLimitFieldNumber = 5;
  inline float cwlimit() const;
  inline void set_cwlimit(float value);
  
  // optional float ccwLimit = 6;
  inline bool has_ccwlimit() const;
  inline void clear_ccwlimit();
  static const int kCcwLimitFieldNumber = 6;
  inline float ccwlimit() const;
  inline void set_ccwlimit(float value);
  
  // optional float collimatorLow = 7;
  inline bool has_collimatorlow() const;
  inline void clear_collimatorlow();
  static const int kCollimatorLowFieldNumber = 7;
  inline float collimatorlow() const;
  inline void set_collimatorlow(float value);
  
  // optional float collimatorHigh = 8;
  inline bool has_collimatorhigh() const;
  inline void clear_collimatorhigh();
  static const int kCollimatorHighFieldNumber = 8;
  inline float collimatorhigh() const;
  inline void set_collimatorhigh(float value);
  
  // optional float lateralMotionMax = 9;
  inline bool has_lateralmotionmax() const;
  inline void clear_lateralmotionmax();
  static const int kLateralMotionMaxFieldNumber = 9;
  inline float lateralmotionmax() const;
  inline void set_lateralmotionmax(float value);
  
  // optional float lateralMotionMin = 10;
  inline bool has_lateralmotionmin() const;
  inline void clear_lateralmotionmin();
  static const int kLateralMotionMinFieldNumber = 10;
  inline float lateralmotionmin() const;
  inline void set_lateralmotionmin(float value);
  
  // optional float longitudeMotionMin = 11;
  inline bool has_longitudemotionmin() const;
  inline void clear_longitudemotionmin();
  static const int kLongitudeMotionMinFieldNumber = 11;
  inline float longitudemotionmin() const;
  inline void set_longitudemotionmin(float value);
  
  // optional float longitudeMotionMax = 12;
  inline bool has_longitudemotionmax() const;
  inline void clear_longitudemotionmax();
  static const int kLongitudeMotionMaxFieldNumber = 12;
  inline float longitudemotionmax() const;
  inline void set_longitudemotionmax(float value);
  
  // optional float verticalMotionMax = 13;
  inline bool has_verticalmotionmax() const;
  inline void clear_verticalmotionmax();
  static const int kVerticalMotionMaxFieldNumber = 13;
  inline float verticalmotionmax() const;
  inline void set_verticalmotionmax(float value);
  
  // optional float verticalMotionMin = 14;
  inline bool has_verticalmotionmin() const;
  inline void clear_verticalmotionmin();
  static const int kVerticalMotionMinFieldNumber = 14;
  inline float verticalmotionmin() const;
  inline void set_verticalmotionmin(float value);
  
  // optional float rTNMax = 15;
  inline bool has_rtnmax() const;
  inline void clear_rtnmax();
  static const int kRTNMaxFieldNumber = 15;
  inline float rtnmax() const;
  inline void set_rtnmax(float value);
  
  // optional float rTNMIN = 16;
  inline bool has_rtnmin() const;
  inline void clear_rtnmin();
  static const int kRTNMINFieldNumber = 16;
  inline float rtnmin() const;
  inline void set_rtnmin(float value);
  
  // optional float minGantrySpeed_DegreeperSecond = 17;
  inline bool has_mingantryspeed_degreepersecond() const;
  inline void clear_mingantryspeed_degreepersecond();
  static const int kMinGantrySpeedDegreeperSecondFieldNumber = 17;
  inline float mingantryspeed_degreepersecond() const;
  inline void set_mingantryspeed_degreepersecond(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineGeometry)
 private:
  inline void set_has_gantryanglemin();
  inline void clear_has_gantryanglemin();
  inline void set_has_gantryanglemax();
  inline void clear_has_gantryanglemax();
  inline void set_has_maxspeedlimit();
  inline void clear_has_maxspeedlimit();
  inline void set_has_sad();
  inline void clear_has_sad();
  inline void set_has_cwlimit();
  inline void clear_has_cwlimit();
  inline void set_has_ccwlimit();
  inline void clear_has_ccwlimit();
  inline void set_has_collimatorlow();
  inline void clear_has_collimatorlow();
  inline void set_has_collimatorhigh();
  inline void clear_has_collimatorhigh();
  inline void set_has_lateralmotionmax();
  inline void clear_has_lateralmotionmax();
  inline void set_has_lateralmotionmin();
  inline void clear_has_lateralmotionmin();
  inline void set_has_longitudemotionmin();
  inline void clear_has_longitudemotionmin();
  inline void set_has_longitudemotionmax();
  inline void clear_has_longitudemotionmax();
  inline void set_has_verticalmotionmax();
  inline void clear_has_verticalmotionmax();
  inline void set_has_verticalmotionmin();
  inline void clear_has_verticalmotionmin();
  inline void set_has_rtnmax();
  inline void clear_has_rtnmax();
  inline void set_has_rtnmin();
  inline void clear_has_rtnmin();
  inline void set_has_mingantryspeed_degreepersecond();
  inline void clear_has_mingantryspeed_degreepersecond();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float gantryanglemin_;
  float gantryanglemax_;
  float maxspeedlimit_;
  float sad_;
  float cwlimit_;
  float ccwlimit_;
  float collimatorlow_;
  float collimatorhigh_;
  float lateralmotionmax_;
  float lateralmotionmin_;
  float longitudemotionmin_;
  float longitudemotionmax_;
  float verticalmotionmax_;
  float verticalmotionmin_;
  float rtnmax_;
  float rtnmin_;
  float mingantryspeed_degreepersecond_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineGeometry* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineJaw : public ::google::protobuf::Message {
 public:
  RT_MS_MachineJaw();
  virtual ~RT_MS_MachineJaw();
  
  RT_MS_MachineJaw(const RT_MS_MachineJaw& from);
  
  inline RT_MS_MachineJaw& operator=(const RT_MS_MachineJaw& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineJaw& default_instance();
  
  void Swap(RT_MS_MachineJaw* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineJaw* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineJaw& from);
  void MergeFrom(const RT_MS_MachineJaw& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool isXjaw = 1;
  inline bool has_isxjaw() const;
  inline void clear_isxjaw();
  static const int kIsXjawFieldNumber = 1;
  inline bool isxjaw() const;
  inline void set_isxjaw(bool value);
  
  // optional bool isYjaw = 2;
  inline bool has_isyjaw() const;
  inline void clear_isyjaw();
  static const int kIsYjawFieldNumber = 2;
  inline bool isyjaw() const;
  inline void set_isyjaw(bool value);
  
  // optional bool isXasym = 3;
  inline bool has_isxasym() const;
  inline void clear_isxasym();
  static const int kIsXasymFieldNumber = 3;
  inline bool isxasym() const;
  inline void set_isxasym(bool value);
  
  // optional bool isYasym = 4;
  inline bool has_isyasym() const;
  inline void clear_isyasym();
  static const int kIsYasymFieldNumber = 4;
  inline bool isyasym() const;
  inline void set_isyasym(bool value);
  
  // optional string leftJawLabel = 5;
  inline bool has_leftjawlabel() const;
  inline void clear_leftjawlabel();
  static const int kLeftJawLabelFieldNumber = 5;
  inline const ::std::string& leftjawlabel() const;
  inline void set_leftjawlabel(const ::std::string& value);
  inline void set_leftjawlabel(const char* value);
  inline void set_leftjawlabel(const char* value, size_t size);
  inline ::std::string* mutable_leftjawlabel();
  inline ::std::string* release_leftjawlabel();
  
  // optional string rightJawLabel = 6;
  inline bool has_rightjawlabel() const;
  inline void clear_rightjawlabel();
  static const int kRightJawLabelFieldNumber = 6;
  inline const ::std::string& rightjawlabel() const;
  inline void set_rightjawlabel(const ::std::string& value);
  inline void set_rightjawlabel(const char* value);
  inline void set_rightjawlabel(const char* value, size_t size);
  inline ::std::string* mutable_rightjawlabel();
  inline ::std::string* release_rightjawlabel();
  
  // optional float maxLeftJawPosition = 7;
  inline bool has_maxleftjawposition() const;
  inline void clear_maxleftjawposition();
  static const int kMaxLeftJawPositionFieldNumber = 7;
  inline float maxleftjawposition() const;
  inline void set_maxleftjawposition(float value);
  
  // optional float minLeftJawPosition = 8;
  inline bool has_minleftjawposition() const;
  inline void clear_minleftjawposition();
  static const int kMinLeftJawPositionFieldNumber = 8;
  inline float minleftjawposition() const;
  inline void set_minleftjawposition(float value);
  
  // optional float maxRightJawPosition = 9;
  inline bool has_maxrightjawposition() const;
  inline void clear_maxrightjawposition();
  static const int kMaxRightJawPositionFieldNumber = 9;
  inline float maxrightjawposition() const;
  inline void set_maxrightjawposition(float value);
  
  // optional float minRightJawPosition = 10;
  inline bool has_minrightjawposition() const;
  inline void clear_minrightjawposition();
  static const int kMinRightJawPositionFieldNumber = 10;
  inline float minrightjawposition() const;
  inline void set_minrightjawposition(float value);
  
  // optional float lateralJawOutsideEdge = 11;
  inline bool has_lateraljawoutsideedge() const;
  inline void clear_lateraljawoutsideedge();
  static const int kLateralJawOutsideEdgeFieldNumber = 11;
  inline float lateraljawoutsideedge() const;
  inline void set_lateraljawoutsideedge(float value);
  
  // optional float lateralInsideJawEdge = 12;
  inline bool has_lateralinsidejawedge() const;
  inline void clear_lateralinsidejawedge();
  static const int kLateralInsideJawEdgeFieldNumber = 12;
  inline float lateralinsidejawedge() const;
  inline void set_lateralinsidejawedge(float value);
  
  // optional float sourceLateralJawDistance = 13;
  inline bool has_sourcelateraljawdistance() const;
  inline void clear_sourcelateraljawdistance();
  static const int kSourceLateralJawDistanceFieldNumber = 13;
  inline float sourcelateraljawdistance() const;
  inline void set_sourcelateraljawdistance(float value);
  
  // optional float jawGap = 14;
  inline bool has_jawgap() const;
  inline void clear_jawgap();
  static const int kJawGapFieldNumber = 14;
  inline float jawgap() const;
  inline void set_jawgap(float value);
  
  // optional float MaxJawSpeed = 15;
  inline bool has_maxjawspeed() const;
  inline void clear_maxjawspeed();
  static const int kMaxJawSpeedFieldNumber = 15;
  inline float maxjawspeed() const;
  inline void set_maxjawspeed(float value);
  
  // optional string topJawLabel = 16;
  inline bool has_topjawlabel() const;
  inline void clear_topjawlabel();
  static const int kTopJawLabelFieldNumber = 16;
  inline const ::std::string& topjawlabel() const;
  inline void set_topjawlabel(const ::std::string& value);
  inline void set_topjawlabel(const char* value);
  inline void set_topjawlabel(const char* value, size_t size);
  inline ::std::string* mutable_topjawlabel();
  inline ::std::string* release_topjawlabel();
  
  // optional string bottomJawLabel = 17;
  inline bool has_bottomjawlabel() const;
  inline void clear_bottomjawlabel();
  static const int kBottomJawLabelFieldNumber = 17;
  inline const ::std::string& bottomjawlabel() const;
  inline void set_bottomjawlabel(const ::std::string& value);
  inline void set_bottomjawlabel(const char* value);
  inline void set_bottomjawlabel(const char* value, size_t size);
  inline ::std::string* mutable_bottomjawlabel();
  inline ::std::string* release_bottomjawlabel();
  
  // optional float maxTopJawPosition = 18;
  inline bool has_maxtopjawposition() const;
  inline void clear_maxtopjawposition();
  static const int kMaxTopJawPositionFieldNumber = 18;
  inline float maxtopjawposition() const;
  inline void set_maxtopjawposition(float value);
  
  // optional float minTopJawPosition = 19;
  inline bool has_mintopjawposition() const;
  inline void clear_mintopjawposition();
  static const int kMinTopJawPositionFieldNumber = 19;
  inline float mintopjawposition() const;
  inline void set_mintopjawposition(float value);
  
  // optional float maxBottomJawPosition = 20;
  inline bool has_maxbottomjawposition() const;
  inline void clear_maxbottomjawposition();
  static const int kMaxBottomJawPositionFieldNumber = 20;
  inline float maxbottomjawposition() const;
  inline void set_maxbottomjawposition(float value);
  
  // optional float minBottomJawPosition = 21;
  inline bool has_minbottomjawposition() const;
  inline void clear_minbottomjawposition();
  static const int kMinBottomJawPositionFieldNumber = 21;
  inline float minbottomjawposition() const;
  inline void set_minbottomjawposition(float value);
  
  // optional float longitudeJawOutsideEdge = 22;
  inline bool has_longitudejawoutsideedge() const;
  inline void clear_longitudejawoutsideedge();
  static const int kLongitudeJawOutsideEdgeFieldNumber = 22;
  inline float longitudejawoutsideedge() const;
  inline void set_longitudejawoutsideedge(float value);
  
  // optional float longitudeJawInsideEdge = 23;
  inline bool has_longitudejawinsideedge() const;
  inline void clear_longitudejawinsideedge();
  static const int kLongitudeJawInsideEdgeFieldNumber = 23;
  inline float longitudejawinsideedge() const;
  inline void set_longitudejawinsideedge(float value);
  
  // optional float sourceLongitudeJawDistance = 24;
  inline bool has_sourcelongitudejawdistance() const;
  inline void clear_sourcelongitudejawdistance();
  static const int kSourceLongitudeJawDistanceFieldNumber = 24;
  inline float sourcelongitudejawdistance() const;
  inline void set_sourcelongitudejawdistance(float value);
  
  // optional bool lateralTracking = 25;
  inline bool has_lateraltracking() const;
  inline void clear_lateraltracking();
  static const int kLateralTrackingFieldNumber = 25;
  inline bool lateraltracking() const;
  inline void set_lateraltracking(bool value);
  
  // optional bool longitudinalTranking = 26;
  inline bool has_longitudinaltranking() const;
  inline void clear_longitudinaltranking();
  static const int kLongitudinalTrankingFieldNumber = 26;
  inline bool longitudinaltranking() const;
  inline void set_longitudinaltranking(bool value);
  
  // optional string note = 27;
  inline bool has_note() const;
  inline void clear_note();
  static const int kNoteFieldNumber = 27;
  inline const ::std::string& note() const;
  inline void set_note(const ::std::string& value);
  inline void set_note(const char* value);
  inline void set_note(const char* value, size_t size);
  inline ::std::string* mutable_note();
  inline ::std::string* release_note();
  
  // optional bool isForceJawFollow = 28;
  inline bool has_isforcejawfollow() const;
  inline void clear_isforcejawfollow();
  static const int kIsForceJawFollowFieldNumber = 28;
  inline bool isforcejawfollow() const;
  inline void set_isforcejawfollow(bool value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineJaw)
 private:
  inline void set_has_isxjaw();
  inline void clear_has_isxjaw();
  inline void set_has_isyjaw();
  inline void clear_has_isyjaw();
  inline void set_has_isxasym();
  inline void clear_has_isxasym();
  inline void set_has_isyasym();
  inline void clear_has_isyasym();
  inline void set_has_leftjawlabel();
  inline void clear_has_leftjawlabel();
  inline void set_has_rightjawlabel();
  inline void clear_has_rightjawlabel();
  inline void set_has_maxleftjawposition();
  inline void clear_has_maxleftjawposition();
  inline void set_has_minleftjawposition();
  inline void clear_has_minleftjawposition();
  inline void set_has_maxrightjawposition();
  inline void clear_has_maxrightjawposition();
  inline void set_has_minrightjawposition();
  inline void clear_has_minrightjawposition();
  inline void set_has_lateraljawoutsideedge();
  inline void clear_has_lateraljawoutsideedge();
  inline void set_has_lateralinsidejawedge();
  inline void clear_has_lateralinsidejawedge();
  inline void set_has_sourcelateraljawdistance();
  inline void clear_has_sourcelateraljawdistance();
  inline void set_has_jawgap();
  inline void clear_has_jawgap();
  inline void set_has_maxjawspeed();
  inline void clear_has_maxjawspeed();
  inline void set_has_topjawlabel();
  inline void clear_has_topjawlabel();
  inline void set_has_bottomjawlabel();
  inline void clear_has_bottomjawlabel();
  inline void set_has_maxtopjawposition();
  inline void clear_has_maxtopjawposition();
  inline void set_has_mintopjawposition();
  inline void clear_has_mintopjawposition();
  inline void set_has_maxbottomjawposition();
  inline void clear_has_maxbottomjawposition();
  inline void set_has_minbottomjawposition();
  inline void clear_has_minbottomjawposition();
  inline void set_has_longitudejawoutsideedge();
  inline void clear_has_longitudejawoutsideedge();
  inline void set_has_longitudejawinsideedge();
  inline void clear_has_longitudejawinsideedge();
  inline void set_has_sourcelongitudejawdistance();
  inline void clear_has_sourcelongitudejawdistance();
  inline void set_has_lateraltracking();
  inline void clear_has_lateraltracking();
  inline void set_has_longitudinaltranking();
  inline void clear_has_longitudinaltranking();
  inline void set_has_note();
  inline void clear_has_note();
  inline void set_has_isforcejawfollow();
  inline void clear_has_isforcejawfollow();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool isxjaw_;
  bool isyjaw_;
  bool isxasym_;
  bool isyasym_;
  float maxleftjawposition_;
  ::std::string* leftjawlabel_;
  ::std::string* rightjawlabel_;
  float minleftjawposition_;
  float maxrightjawposition_;
  float minrightjawposition_;
  float lateraljawoutsideedge_;
  float lateralinsidejawedge_;
  float sourcelateraljawdistance_;
  float jawgap_;
  float maxjawspeed_;
  ::std::string* topjawlabel_;
  ::std::string* bottomjawlabel_;
  float maxtopjawposition_;
  float mintopjawposition_;
  float maxbottomjawposition_;
  float minbottomjawposition_;
  float longitudejawoutsideedge_;
  float longitudejawinsideedge_;
  float sourcelongitudejawdistance_;
  bool lateraltracking_;
  bool longitudinaltranking_;
  bool isforcejawfollow_;
  ::std::string* note_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineJaw* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_PairInfo : public ::google::protobuf::Message {
 public:
  RT_MS_PairInfo();
  virtual ~RT_MS_PairInfo();
  
  RT_MS_PairInfo(const RT_MS_PairInfo& from);
  
  inline RT_MS_PairInfo& operator=(const RT_MS_PairInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_PairInfo& default_instance();
  
  void Swap(RT_MS_PairInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_PairInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_PairInfo& from);
  void MergeFrom(const RT_MS_PairInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string pairUID = 1;
  inline bool has_pairuid() const;
  inline void clear_pairuid();
  static const int kPairUIDFieldNumber = 1;
  inline const ::std::string& pairuid() const;
  inline void set_pairuid(const ::std::string& value);
  inline void set_pairuid(const char* value);
  inline void set_pairuid(const char* value, size_t size);
  inline ::std::string* mutable_pairuid();
  inline ::std::string* release_pairuid();
  
  // optional int32 pair = 2;
  inline bool has_pair() const;
  inline void clear_pair();
  static const int kPairFieldNumber = 2;
  inline ::google::protobuf::int32 pair() const;
  inline void set_pair(::google::protobuf::int32 value);
  
  // optional double leafPairs = 3;
  inline bool has_leafpairs() const;
  inline void clear_leafpairs();
  static const int kLeafPairsFieldNumber = 3;
  inline double leafpairs() const;
  inline void set_leafpairs(double value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_PairInfo)
 private:
  inline void set_has_pairuid();
  inline void clear_has_pairuid();
  inline void set_has_pair();
  inline void clear_has_pair();
  inline void set_has_leafpairs();
  inline void clear_has_leafpairs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* pairuid_;
  double leafpairs_;
  ::google::protobuf::int32 pair_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_PairInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineMLC : public ::google::protobuf::Message {
 public:
  RT_MS_MachineMLC();
  virtual ~RT_MS_MachineMLC();
  
  RT_MS_MachineMLC(const RT_MS_MachineMLC& from);
  
  inline RT_MS_MachineMLC& operator=(const RT_MS_MachineMLC& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineMLC& default_instance();
  
  void Swap(RT_MS_MachineMLC* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineMLC* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineMLC& from);
  void MergeFrom(const RT_MS_MachineMLC& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float sourceToMLCtopDistance = 1;
  inline bool has_sourcetomlctopdistance() const;
  inline void clear_sourcetomlctopdistance();
  static const int kSourceToMLCtopDistanceFieldNumber = 1;
  inline float sourcetomlctopdistance() const;
  inline void set_sourcetomlctopdistance(float value);
  
  // optional float minLeafJawOverlap = 2;
  inline bool has_minleafjawoverlap() const;
  inline void clear_minleafjawoverlap();
  static const int kMinLeafJawOverlapFieldNumber = 2;
  inline float minleafjawoverlap() const;
  inline void set_minleafjawoverlap(float value);
  
  // optional float minGap = 3;
  inline bool has_mingap() const;
  inline void clear_mingap();
  static const int kMinGapFieldNumber = 3;
  inline float mingap() const;
  inline void set_mingap(float value);
  
  // optional float maxLeafSpeed = 4;
  inline bool has_maxleafspeed() const;
  inline void clear_maxleafspeed();
  static const int kMaxLeafSpeedFieldNumber = 4;
  inline float maxleafspeed() const;
  inline void set_maxleafspeed(float value);
  
  // optional float minTipPosition = 5;
  inline bool has_mintipposition() const;
  inline void clear_mintipposition();
  static const int kMinTipPositionFieldNumber = 5;
  inline float mintipposition() const;
  inline void set_mintipposition(float value);
  
  // optional float maxTipPosition = 6;
  inline bool has_maxtipposition() const;
  inline void clear_maxtipposition();
  static const int kMaxTipPositionFieldNumber = 6;
  inline float maxtipposition() const;
  inline void set_maxtipposition(float value);
  
  // optional bool leafInterdigitation = 7;
  inline bool has_leafinterdigitation() const;
  inline void clear_leafinterdigitation();
  static const int kLeafInterdigitationFieldNumber = 7;
  inline bool leafinterdigitation() const;
  inline void set_leafinterdigitation(bool value);
  
  // optional float maxLeafoutofCarriageDistance = 8;
  inline bool has_maxleafoutofcarriagedistance() const;
  inline void clear_maxleafoutofcarriagedistance();
  static const int kMaxLeafoutofCarriageDistanceFieldNumber = 8;
  inline float maxleafoutofcarriagedistance() const;
  inline void set_maxleafoutofcarriagedistance(float value);
  
  // optional int32 mlcDirection = 9;
  inline bool has_mlcdirection() const;
  inline void clear_mlcdirection();
  static const int kMlcDirectionFieldNumber = 9;
  inline ::google::protobuf::int32 mlcdirection() const;
  inline void set_mlcdirection(::google::protobuf::int32 value);
  
  // optional int32 pairs = 10;
  inline bool has_pairs() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 10;
  inline ::google::protobuf::int32 pairs() const;
  inline void set_pairs(::google::protobuf::int32 value);
  
  // repeated .ms.proto.RT_MS_PairInfo pairInfoList = 11;
  inline int pairinfolist_size() const;
  inline void clear_pairinfolist();
  static const int kPairInfoListFieldNumber = 11;
  inline const ::ms::proto::RT_MS_PairInfo& pairinfolist(int index) const;
  inline ::ms::proto::RT_MS_PairInfo* mutable_pairinfolist(int index);
  inline ::ms::proto::RT_MS_PairInfo* add_pairinfolist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PairInfo >&
      pairinfolist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PairInfo >*
      mutable_pairinfolist();
  
  // optional int32 maxLeafAcc_mmPerSec2 = 12;
  inline bool has_maxleafacc_mmpersec2() const;
  inline void clear_maxleafacc_mmpersec2();
  static const int kMaxLeafAccMmPerSec2FieldNumber = 12;
  inline ::google::protobuf::int32 maxleafacc_mmpersec2() const;
  inline void set_maxleafacc_mmpersec2(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineMLC)
 private:
  inline void set_has_sourcetomlctopdistance();
  inline void clear_has_sourcetomlctopdistance();
  inline void set_has_minleafjawoverlap();
  inline void clear_has_minleafjawoverlap();
  inline void set_has_mingap();
  inline void clear_has_mingap();
  inline void set_has_maxleafspeed();
  inline void clear_has_maxleafspeed();
  inline void set_has_mintipposition();
  inline void clear_has_mintipposition();
  inline void set_has_maxtipposition();
  inline void clear_has_maxtipposition();
  inline void set_has_leafinterdigitation();
  inline void clear_has_leafinterdigitation();
  inline void set_has_maxleafoutofcarriagedistance();
  inline void clear_has_maxleafoutofcarriagedistance();
  inline void set_has_mlcdirection();
  inline void clear_has_mlcdirection();
  inline void set_has_pairs();
  inline void clear_has_pairs();
  inline void set_has_maxleafacc_mmpersec2();
  inline void clear_has_maxleafacc_mmpersec2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float sourcetomlctopdistance_;
  float minleafjawoverlap_;
  float mingap_;
  float maxleafspeed_;
  float mintipposition_;
  float maxtipposition_;
  bool leafinterdigitation_;
  float maxleafoutofcarriagedistance_;
  ::google::protobuf::int32 mlcdirection_;
  ::google::protobuf::int32 pairs_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PairInfo > pairinfolist_;
  ::google::protobuf::int32 maxleafacc_mmpersec2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineMLC* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_CommissionInfo : public ::google::protobuf::Message {
 public:
  RT_MS_CommissionInfo();
  virtual ~RT_MS_CommissionInfo();
  
  RT_MS_CommissionInfo(const RT_MS_CommissionInfo& from);
  
  inline RT_MS_CommissionInfo& operator=(const RT_MS_CommissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_CommissionInfo& default_instance();
  
  void Swap(RT_MS_CommissionInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_CommissionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_CommissionInfo& from);
  void MergeFrom(const RT_MS_CommissionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 radiationType = 1;
  inline bool has_radiationtype() const;
  inline void clear_radiationtype();
  static const int kRadiationTypeFieldNumber = 1;
  inline ::google::protobuf::int32 radiationtype() const;
  inline void set_radiationtype(::google::protobuf::int32 value);
  
  // optional float energy = 2;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 2;
  inline float energy() const;
  inline void set_energy(float value);
  
  // optional int32 flatteningFilterType = 3;
  inline bool has_flatteningfiltertype() const;
  inline void clear_flatteningfiltertype();
  static const int kFlatteningFilterTypeFieldNumber = 3;
  inline ::google::protobuf::int32 flatteningfiltertype() const;
  inline void set_flatteningfiltertype(::google::protobuf::int32 value);
  
  // optional bool isConvolution = 4;
  inline bool has_isconvolution() const;
  inline void clear_isconvolution();
  static const int kIsConvolutionFieldNumber = 4;
  inline bool isconvolution() const;
  inline void set_isconvolution(bool value);
  
  // optional bool isPencilBeam = 5;
  inline bool has_ispencilbeam() const;
  inline void clear_ispencilbeam();
  static const int kIsPencilBeamFieldNumber = 5;
  inline bool ispencilbeam() const;
  inline void set_ispencilbeam(bool value);
  
  // optional bool isMonteCarlo = 6;
  inline bool has_ismontecarlo() const;
  inline void clear_ismontecarlo();
  static const int kIsMonteCarloFieldNumber = 6;
  inline bool ismontecarlo() const;
  inline void set_ismontecarlo(bool value);
  
  // optional bool isDoseRateVarSupport = 7;
  inline bool has_isdoseratevarsupport() const;
  inline void clear_isdoseratevarsupport();
  static const int kIsDoseRateVarSupportFieldNumber = 7;
  inline bool isdoseratevarsupport() const;
  inline void set_isdoseratevarsupport(bool value);
  
  // optional bool isPlan2D = 8;
  inline bool has_isplan2d() const;
  inline void clear_isplan2d();
  static const int kIsPlan2DFieldNumber = 8;
  inline bool isplan2d() const;
  inline void set_isplan2d(bool value);
  
  // optional bool isPlan3D = 9;
  inline bool has_isplan3d() const;
  inline void clear_isplan3d();
  static const int kIsPlan3DFieldNumber = 9;
  inline bool isplan3d() const;
  inline void set_isplan3d(bool value);
  
  // optional bool isPlanStepShoot = 10;
  inline bool has_isplanstepshoot() const;
  inline void clear_isplanstepshoot();
  static const int kIsPlanStepShootFieldNumber = 10;
  inline bool isplanstepshoot() const;
  inline void set_isplanstepshoot(bool value);
  
  // optional bool isPlanSlidingWindow = 11;
  inline bool has_isplanslidingwindow() const;
  inline void clear_isplanslidingwindow();
  static const int kIsPlanSlidingWindowFieldNumber = 11;
  inline bool isplanslidingwindow() const;
  inline void set_isplanslidingwindow(bool value);
  
  // optional bool isPlanSimpleArc = 12;
  inline bool has_isplansimplearc() const;
  inline void clear_isplansimplearc();
  static const int kIsPlanSimpleArcFieldNumber = 12;
  inline bool isplansimplearc() const;
  inline void set_isplansimplearc(bool value);
  
  // optional bool isPlanConformalArc = 13;
  inline bool has_isplanconformalarc() const;
  inline void clear_isplanconformalarc();
  static const int kIsPlanConformalArcFieldNumber = 13;
  inline bool isplanconformalarc() const;
  inline void set_isplanconformalarc(bool value);
  
  // optional bool isPlanVMATArc = 14;
  inline bool has_isplanvmatarc() const;
  inline void clear_isplanvmatarc();
  static const int kIsPlanVMATArcFieldNumber = 14;
  inline bool isplanvmatarc() const;
  inline void set_isplanvmatarc(bool value);
  
  // optional bool isPlanBurstArc = 15;
  inline bool has_isplanburstarc() const;
  inline void clear_isplanburstarc();
  static const int kIsPlanBurstArcFieldNumber = 15;
  inline bool isplanburstarc() const;
  inline void set_isplanburstarc(bool value);
  
  // optional bool electornType = 16;
  inline bool has_electorntype() const;
  inline void clear_electorntype();
  static const int kElectornTypeFieldNumber = 16;
  inline bool electorntype() const;
  inline void set_electorntype(bool value);
  
  // repeated .ms.proto.RT_MS_MachineBeamModeDoseRate doseRateListInfo = 17;
  inline int doseratelistinfo_size() const;
  inline void clear_doseratelistinfo();
  static const int kDoseRateListInfoFieldNumber = 17;
  inline const ::ms::proto::RT_MS_MachineBeamModeDoseRate& doseratelistinfo(int index) const;
  inline ::ms::proto::RT_MS_MachineBeamModeDoseRate* mutable_doseratelistinfo(int index);
  inline ::ms::proto::RT_MS_MachineBeamModeDoseRate* add_doseratelistinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineBeamModeDoseRate >&
      doseratelistinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineBeamModeDoseRate >*
      mutable_doseratelistinfo();
  
  // optional bool isCheckedHalfProfile = 18;
  inline bool has_ischeckedhalfprofile() const;
  inline void clear_ischeckedhalfprofile();
  static const int kIsCheckedHalfProfileFieldNumber = 18;
  inline bool ischeckedhalfprofile() const;
  inline void set_ischeckedhalfprofile(bool value);
  
  // optional string commissionUID = 19;
  inline bool has_commissionuid() const;
  inline void clear_commissionuid();
  static const int kCommissionUIDFieldNumber = 19;
  inline const ::std::string& commissionuid() const;
  inline void set_commissionuid(const ::std::string& value);
  inline void set_commissionuid(const char* value);
  inline void set_commissionuid(const char* value, size_t size);
  inline ::std::string* mutable_commissionuid();
  inline ::std::string* release_commissionuid();
  
  // optional string commissionName = 20;
  inline bool has_commissionname() const;
  inline void clear_commissionname();
  static const int kCommissionNameFieldNumber = 20;
  inline const ::std::string& commissionname() const;
  inline void set_commissionname(const ::std::string& value);
  inline void set_commissionname(const char* value);
  inline void set_commissionname(const char* value, size_t size);
  inline ::std::string* mutable_commissionname();
  inline ::std::string* release_commissionname();
  
  // optional bool isApprove = 21;
  inline bool has_isapprove() const;
  inline void clear_isapprove();
  static const int kIsApproveFieldNumber = 21;
  inline bool isapprove() const;
  inline void set_isapprove(bool value);
  
  // optional float calibrationFieldSizeX = 22;
  inline bool has_calibrationfieldsizex() const;
  inline void clear_calibrationfieldsizex();
  static const int kCalibrationFieldSizeXFieldNumber = 22;
  inline float calibrationfieldsizex() const;
  inline void set_calibrationfieldsizex(float value);
  
  // optional float calibrationFieldSizeY = 23;
  inline bool has_calibrationfieldsizey() const;
  inline void clear_calibrationfieldsizey();
  static const int kCalibrationFieldSizeYFieldNumber = 23;
  inline float calibrationfieldsizey() const;
  inline void set_calibrationfieldsizey(float value);
  
  // optional float calibrationDmax = 24;
  inline bool has_calibrationdmax() const;
  inline void clear_calibrationdmax();
  static const int kCalibrationDmaxFieldNumber = 24;
  inline float calibrationdmax() const;
  inline void set_calibrationdmax(float value);
  
  // optional float sSD = 25;
  inline bool has_ssd() const;
  inline void clear_ssd();
  static const int kSSDFieldNumber = 25;
  inline float ssd() const;
  inline void set_ssd(float value);
  
  // optional float lateral = 26;
  inline bool has_lateral() const;
  inline void clear_lateral();
  static const int kLateralFieldNumber = 26;
  inline float lateral() const;
  inline void set_lateral(float value);
  
  // optional float depth = 27;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 27;
  inline float depth() const;
  inline void set_depth(float value);
  
  // optional string date = 28;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 28;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  
  // optional string time = 29;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 29;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  
  // optional string who = 30;
  inline bool has_who() const;
  inline void clear_who();
  static const int kWhoFieldNumber = 30;
  inline const ::std::string& who() const;
  inline void set_who(const ::std::string& value);
  inline void set_who(const char* value);
  inline void set_who(const char* value, size_t size);
  inline ::std::string* mutable_who();
  inline ::std::string* release_who();
  
  // optional string uid = 31;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 31;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string ParentUID = 32;
  inline bool has_parentuid() const;
  inline void clear_parentuid();
  static const int kParentUIDFieldNumber = 32;
  inline const ::std::string& parentuid() const;
  inline void set_parentuid(const ::std::string& value);
  inline void set_parentuid(const char* value);
  inline void set_parentuid(const char* value, size_t size);
  inline ::std::string* mutable_parentuid();
  inline ::std::string* release_parentuid();
  
  // optional float penumbra = 33;
  inline bool has_penumbra() const;
  inline void clear_penumbra();
  static const int kPenumbraFieldNumber = 33;
  inline float penumbra() const;
  inline void set_penumbra(float value);
  
  // optional float blockattenuationfactor = 34;
  inline bool has_blockattenuationfactor() const;
  inline void clear_blockattenuationfactor();
  static const int kBlockattenuationfactorFieldNumber = 34;
  inline float blockattenuationfactor() const;
  inline void set_blockattenuationfactor(float value);
  
  // repeated float trayFactorList = 35;
  inline int trayfactorlist_size() const;
  inline void clear_trayfactorlist();
  static const int kTrayFactorListFieldNumber = 35;
  inline float trayfactorlist(int index) const;
  inline void set_trayfactorlist(int index, float value);
  inline void add_trayfactorlist(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      trayfactorlist() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_trayfactorlist();
  
  // optional string phoCommissionUID = 36;
  inline bool has_phocommissionuid() const;
  inline void clear_phocommissionuid();
  static const int kPhoCommissionUIDFieldNumber = 36;
  inline const ::std::string& phocommissionuid() const;
  inline void set_phocommissionuid(const ::std::string& value);
  inline void set_phocommissionuid(const char* value);
  inline void set_phocommissionuid(const char* value, size_t size);
  inline ::std::string* mutable_phocommissionuid();
  inline ::std::string* release_phocommissionuid();
  
  // optional float norDepth = 37;
  inline bool has_nordepth() const;
  inline void clear_nordepth();
  static const int kNorDepthFieldNumber = 37;
  inline float nordepth() const;
  inline void set_nordepth(float value);
  
  // optional float mlcFactor = 38;
  inline bool has_mlcfactor() const;
  inline void clear_mlcfactor();
  static const int kMlcFactorFieldNumber = 38;
  inline float mlcfactor() const;
  inline void set_mlcfactor(float value);
  
  // optional float xJawFactor = 39;
  inline bool has_xjawfactor() const;
  inline void clear_xjawfactor();
  static const int kXJawFactorFieldNumber = 39;
  inline float xjawfactor() const;
  inline void set_xjawfactor(float value);
  
  // optional float yJawFactor = 40;
  inline bool has_yjawfactor() const;
  inline void clear_yjawfactor();
  static const int kYJawFactorFieldNumber = 40;
  inline float yjawfactor() const;
  inline void set_yjawfactor(float value);
  
  // optional .ms.proto.RT_MS_PhotonMonteCarloInformation PhotonMonteCarloInfo = 41;
  inline bool has_photonmontecarloinfo() const;
  inline void clear_photonmontecarloinfo();
  static const int kPhotonMonteCarloInfoFieldNumber = 41;
  inline const ::ms::proto::RT_MS_PhotonMonteCarloInformation& photonmontecarloinfo() const;
  inline ::ms::proto::RT_MS_PhotonMonteCarloInformation* mutable_photonmontecarloinfo();
  inline ::ms::proto::RT_MS_PhotonMonteCarloInformation* release_photonmontecarloinfo();
  
  // optional int32 mindoserate_mupermin = 42;
  inline bool has_mindoserate_mupermin() const;
  inline void clear_mindoserate_mupermin();
  static const int kMindoserateMuperminFieldNumber = 42;
  inline ::google::protobuf::int32 mindoserate_mupermin() const;
  inline void set_mindoserate_mupermin(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_CommissionInfo)
 private:
  inline void set_has_radiationtype();
  inline void clear_has_radiationtype();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_flatteningfiltertype();
  inline void clear_has_flatteningfiltertype();
  inline void set_has_isconvolution();
  inline void clear_has_isconvolution();
  inline void set_has_ispencilbeam();
  inline void clear_has_ispencilbeam();
  inline void set_has_ismontecarlo();
  inline void clear_has_ismontecarlo();
  inline void set_has_isdoseratevarsupport();
  inline void clear_has_isdoseratevarsupport();
  inline void set_has_isplan2d();
  inline void clear_has_isplan2d();
  inline void set_has_isplan3d();
  inline void clear_has_isplan3d();
  inline void set_has_isplanstepshoot();
  inline void clear_has_isplanstepshoot();
  inline void set_has_isplanslidingwindow();
  inline void clear_has_isplanslidingwindow();
  inline void set_has_isplansimplearc();
  inline void clear_has_isplansimplearc();
  inline void set_has_isplanconformalarc();
  inline void clear_has_isplanconformalarc();
  inline void set_has_isplanvmatarc();
  inline void clear_has_isplanvmatarc();
  inline void set_has_isplanburstarc();
  inline void clear_has_isplanburstarc();
  inline void set_has_electorntype();
  inline void clear_has_electorntype();
  inline void set_has_ischeckedhalfprofile();
  inline void clear_has_ischeckedhalfprofile();
  inline void set_has_commissionuid();
  inline void clear_has_commissionuid();
  inline void set_has_commissionname();
  inline void clear_has_commissionname();
  inline void set_has_isapprove();
  inline void clear_has_isapprove();
  inline void set_has_calibrationfieldsizex();
  inline void clear_has_calibrationfieldsizex();
  inline void set_has_calibrationfieldsizey();
  inline void clear_has_calibrationfieldsizey();
  inline void set_has_calibrationdmax();
  inline void clear_has_calibrationdmax();
  inline void set_has_ssd();
  inline void clear_has_ssd();
  inline void set_has_lateral();
  inline void clear_has_lateral();
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_who();
  inline void clear_has_who();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_parentuid();
  inline void clear_has_parentuid();
  inline void set_has_penumbra();
  inline void clear_has_penumbra();
  inline void set_has_blockattenuationfactor();
  inline void clear_has_blockattenuationfactor();
  inline void set_has_phocommissionuid();
  inline void clear_has_phocommissionuid();
  inline void set_has_nordepth();
  inline void clear_has_nordepth();
  inline void set_has_mlcfactor();
  inline void clear_has_mlcfactor();
  inline void set_has_xjawfactor();
  inline void clear_has_xjawfactor();
  inline void set_has_yjawfactor();
  inline void clear_has_yjawfactor();
  inline void set_has_photonmontecarloinfo();
  inline void clear_has_photonmontecarloinfo();
  inline void set_has_mindoserate_mupermin();
  inline void clear_has_mindoserate_mupermin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 radiationtype_;
  float energy_;
  ::google::protobuf::int32 flatteningfiltertype_;
  bool isconvolution_;
  bool ispencilbeam_;
  bool ismontecarlo_;
  bool isdoseratevarsupport_;
  bool isplan2d_;
  bool isplan3d_;
  bool isplanstepshoot_;
  bool isplanslidingwindow_;
  bool isplansimplearc_;
  bool isplanconformalarc_;
  bool isplanvmatarc_;
  bool isplanburstarc_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineBeamModeDoseRate > doseratelistinfo_;
  ::std::string* commissionuid_;
  bool electorntype_;
  bool ischeckedhalfprofile_;
  bool isapprove_;
  float calibrationfieldsizex_;
  ::std::string* commissionname_;
  float calibrationfieldsizey_;
  float calibrationdmax_;
  float ssd_;
  float lateral_;
  ::std::string* date_;
  ::std::string* time_;
  ::std::string* who_;
  float depth_;
  float penumbra_;
  ::std::string* uid_;
  ::std::string* parentuid_;
  ::google::protobuf::RepeatedField< float > trayfactorlist_;
  float blockattenuationfactor_;
  float nordepth_;
  ::std::string* phocommissionuid_;
  float mlcfactor_;
  float xjawfactor_;
  ::ms::proto::RT_MS_PhotonMonteCarloInformation* photonmontecarloinfo_;
  float yjawfactor_;
  ::google::protobuf::int32 mindoserate_mupermin_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_CommissionInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineBeamModeDoseRate : public ::google::protobuf::Message {
 public:
  RT_MS_MachineBeamModeDoseRate();
  virtual ~RT_MS_MachineBeamModeDoseRate();
  
  RT_MS_MachineBeamModeDoseRate(const RT_MS_MachineBeamModeDoseRate& from);
  
  inline RT_MS_MachineBeamModeDoseRate& operator=(const RT_MS_MachineBeamModeDoseRate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineBeamModeDoseRate& default_instance();
  
  void Swap(RT_MS_MachineBeamModeDoseRate* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineBeamModeDoseRate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineBeamModeDoseRate& from);
  void MergeFrom(const RT_MS_MachineBeamModeDoseRate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string doseRateUID = 1;
  inline bool has_doserateuid() const;
  inline void clear_doserateuid();
  static const int kDoseRateUIDFieldNumber = 1;
  inline const ::std::string& doserateuid() const;
  inline void set_doserateuid(const ::std::string& value);
  inline void set_doserateuid(const char* value);
  inline void set_doserateuid(const char* value, size_t size);
  inline ::std::string* mutable_doserateuid();
  inline ::std::string* release_doserateuid();
  
  // optional int32 doseRate = 2;
  inline bool has_doserate() const;
  inline void clear_doserate();
  static const int kDoseRateFieldNumber = 2;
  inline ::google::protobuf::int32 doserate() const;
  inline void set_doserate(::google::protobuf::int32 value);
  
  // optional bool isDoseRateDefault = 3;
  inline bool has_isdoseratedefault() const;
  inline void clear_isdoseratedefault();
  static const int kIsDoseRateDefaultFieldNumber = 3;
  inline bool isdoseratedefault() const;
  inline void set_isdoseratedefault(bool value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineBeamModeDoseRate)
 private:
  inline void set_has_doserateuid();
  inline void clear_has_doserateuid();
  inline void set_has_doserate();
  inline void clear_has_doserate();
  inline void set_has_isdoseratedefault();
  inline void clear_has_isdoseratedefault();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* doserateuid_;
  ::google::protobuf::int32 doserate_;
  bool isdoseratedefault_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineBeamModeDoseRate* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineTray : public ::google::protobuf::Message {
 public:
  RT_MS_MachineTray();
  virtual ~RT_MS_MachineTray();
  
  RT_MS_MachineTray(const RT_MS_MachineTray& from);
  
  inline RT_MS_MachineTray& operator=(const RT_MS_MachineTray& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineTray& default_instance();
  
  void Swap(RT_MS_MachineTray* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineTray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineTray& from);
  void MergeFrom(const RT_MS_MachineTray& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string trayUID = 1;
  inline bool has_trayuid() const;
  inline void clear_trayuid();
  static const int kTrayUIDFieldNumber = 1;
  inline const ::std::string& trayuid() const;
  inline void set_trayuid(const ::std::string& value);
  inline void set_trayuid(const char* value);
  inline void set_trayuid(const char* value, size_t size);
  inline ::std::string* mutable_trayuid();
  inline ::std::string* release_trayuid();
  
  // optional string trayid = 2;
  inline bool has_trayid() const;
  inline void clear_trayid();
  static const int kTrayidFieldNumber = 2;
  inline const ::std::string& trayid() const;
  inline void set_trayid(const ::std::string& value);
  inline void set_trayid(const char* value);
  inline void set_trayid(const char* value, size_t size);
  inline ::std::string* mutable_trayid();
  inline ::std::string* release_trayid();
  
  // optional string trayCode = 3;
  inline bool has_traycode() const;
  inline void clear_traycode();
  static const int kTrayCodeFieldNumber = 3;
  inline const ::std::string& traycode() const;
  inline void set_traycode(const ::std::string& value);
  inline void set_traycode(const char* value);
  inline void set_traycode(const char* value, size_t size);
  inline ::std::string* mutable_traycode();
  inline ::std::string* release_traycode();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineTray)
 private:
  inline void set_has_trayuid();
  inline void clear_has_trayuid();
  inline void set_has_trayid();
  inline void clear_has_trayid();
  inline void set_has_traycode();
  inline void clear_has_traycode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* trayuid_;
  ::std::string* trayid_;
  ::std::string* traycode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineTray* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineAccessories : public ::google::protobuf::Message {
 public:
  RT_MS_MachineAccessories();
  virtual ~RT_MS_MachineAccessories();
  
  RT_MS_MachineAccessories(const RT_MS_MachineAccessories& from);
  
  inline RT_MS_MachineAccessories& operator=(const RT_MS_MachineAccessories& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineAccessories& default_instance();
  
  void Swap(RT_MS_MachineAccessories* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineAccessories* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineAccessories& from);
  void MergeFrom(const RT_MS_MachineAccessories& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool isApertureBlock = 1;
  inline bool has_isapertureblock() const;
  inline void clear_isapertureblock();
  static const int kIsApertureBlockFieldNumber = 1;
  inline bool isapertureblock() const;
  inline void set_isapertureblock(bool value);
  
  // optional bool isShieldBlock = 2;
  inline bool has_isshieldblock() const;
  inline void clear_isshieldblock();
  static const int kIsShieldBlockFieldNumber = 2;
  inline bool isshieldblock() const;
  inline void set_isshieldblock(bool value);
  
  // optional float sourceToBlockTryDistance = 3;
  inline bool has_sourcetoblocktrydistance() const;
  inline void clear_sourcetoblocktrydistance();
  static const int kSourceToBlockTryDistanceFieldNumber = 3;
  inline float sourcetoblocktrydistance() const;
  inline void set_sourcetoblocktrydistance(float value);
  
  // optional float height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline float height() const;
  inline void set_height(float value);
  
  // optional float sourceToApplicatorLowDistance = 5;
  inline bool has_sourcetoapplicatorlowdistance() const;
  inline void clear_sourcetoapplicatorlowdistance();
  static const int kSourceToApplicatorLowDistanceFieldNumber = 5;
  inline float sourcetoapplicatorlowdistance() const;
  inline void set_sourcetoapplicatorlowdistance(float value);
  
  // optional float sourceToWedgeDistance = 6;
  inline bool has_sourcetowedgedistance() const;
  inline void clear_sourcetowedgedistance();
  static const int kSourceToWedgeDistanceFieldNumber = 6;
  inline float sourcetowedgedistance() const;
  inline void set_sourcetowedgedistance(float value);
  
  // repeated .ms.proto.RT_MS_MachineElectronApplicator electronApplicatorListInfo = 7;
  inline int electronapplicatorlistinfo_size() const;
  inline void clear_electronapplicatorlistinfo();
  static const int kElectronApplicatorListInfoFieldNumber = 7;
  inline const ::ms::proto::RT_MS_MachineElectronApplicator& electronapplicatorlistinfo(int index) const;
  inline ::ms::proto::RT_MS_MachineElectronApplicator* mutable_electronapplicatorlistinfo(int index);
  inline ::ms::proto::RT_MS_MachineElectronApplicator* add_electronapplicatorlistinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineElectronApplicator >&
      electronapplicatorlistinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineElectronApplicator >*
      mutable_electronapplicatorlistinfo();
  
  // repeated .ms.proto.RT_MS_MachineWedge machineWedgeListInfo = 8;
  inline int machinewedgelistinfo_size() const;
  inline void clear_machinewedgelistinfo();
  static const int kMachineWedgeListInfoFieldNumber = 8;
  inline const ::ms::proto::RT_MS_MachineWedge& machinewedgelistinfo(int index) const;
  inline ::ms::proto::RT_MS_MachineWedge* mutable_machinewedgelistinfo(int index);
  inline ::ms::proto::RT_MS_MachineWedge* add_machinewedgelistinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineWedge >&
      machinewedgelistinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineWedge >*
      mutable_machinewedgelistinfo();
  
  // optional .ms.proto.RT_MS_MachineMotorizedWedge motorizedWedge = 9;
  inline bool has_motorizedwedge() const;
  inline void clear_motorizedwedge();
  static const int kMotorizedWedgeFieldNumber = 9;
  inline const ::ms::proto::RT_MS_MachineMotorizedWedge& motorizedwedge() const;
  inline ::ms::proto::RT_MS_MachineMotorizedWedge* mutable_motorizedwedge();
  inline ::ms::proto::RT_MS_MachineMotorizedWedge* release_motorizedwedge();
  
  // repeated string trayUIDList = 10;
  inline int trayuidlist_size() const;
  inline void clear_trayuidlist();
  static const int kTrayUIDListFieldNumber = 10;
  inline const ::std::string& trayuidlist(int index) const;
  inline ::std::string* mutable_trayuidlist(int index);
  inline void set_trayuidlist(int index, const ::std::string& value);
  inline void set_trayuidlist(int index, const char* value);
  inline void set_trayuidlist(int index, const char* value, size_t size);
  inline ::std::string* add_trayuidlist();
  inline void add_trayuidlist(const ::std::string& value);
  inline void add_trayuidlist(const char* value);
  inline void add_trayuidlist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& trayuidlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trayuidlist();
  
  // optional string UID = 11;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUIDFieldNumber = 11;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // repeated string trayACCcode = 12;
  inline int trayacccode_size() const;
  inline void clear_trayacccode();
  static const int kTrayACCcodeFieldNumber = 12;
  inline const ::std::string& trayacccode(int index) const;
  inline ::std::string* mutable_trayacccode(int index);
  inline void set_trayacccode(int index, const ::std::string& value);
  inline void set_trayacccode(int index, const char* value);
  inline void set_trayacccode(int index, const char* value, size_t size);
  inline ::std::string* add_trayacccode();
  inline void add_trayacccode(const ::std::string& value);
  inline void add_trayacccode(const char* value);
  inline void add_trayacccode(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& trayacccode() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trayacccode();
  
  // repeated .ms.proto.RT_MS_MachineTray trayList = 13;
  inline int traylist_size() const;
  inline void clear_traylist();
  static const int kTrayListFieldNumber = 13;
  inline const ::ms::proto::RT_MS_MachineTray& traylist(int index) const;
  inline ::ms::proto::RT_MS_MachineTray* mutable_traylist(int index);
  inline ::ms::proto::RT_MS_MachineTray* add_traylist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineTray >&
      traylist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineTray >*
      mutable_traylist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineAccessories)
 private:
  inline void set_has_isapertureblock();
  inline void clear_has_isapertureblock();
  inline void set_has_isshieldblock();
  inline void clear_has_isshieldblock();
  inline void set_has_sourcetoblocktrydistance();
  inline void clear_has_sourcetoblocktrydistance();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_sourcetoapplicatorlowdistance();
  inline void clear_has_sourcetoapplicatorlowdistance();
  inline void set_has_sourcetowedgedistance();
  inline void clear_has_sourcetowedgedistance();
  inline void set_has_motorizedwedge();
  inline void clear_has_motorizedwedge();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool isapertureblock_;
  bool isshieldblock_;
  float sourcetoblocktrydistance_;
  float height_;
  float sourcetoapplicatorlowdistance_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineElectronApplicator > electronapplicatorlistinfo_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineWedge > machinewedgelistinfo_;
  ::ms::proto::RT_MS_MachineMotorizedWedge* motorizedwedge_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trayuidlist_;
  ::std::string* uid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trayacccode_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineTray > traylist_;
  float sourcetowedgedistance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineAccessories* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineElectronApplicator : public ::google::protobuf::Message {
 public:
  RT_MS_MachineElectronApplicator();
  virtual ~RT_MS_MachineElectronApplicator();
  
  RT_MS_MachineElectronApplicator(const RT_MS_MachineElectronApplicator& from);
  
  inline RT_MS_MachineElectronApplicator& operator=(const RT_MS_MachineElectronApplicator& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineElectronApplicator& default_instance();
  
  void Swap(RT_MS_MachineElectronApplicator* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineElectronApplicator* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineElectronApplicator& from);
  void MergeFrom(const RT_MS_MachineElectronApplicator& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string applicatorACCID = 1;
  inline bool has_applicatoraccid() const;
  inline void clear_applicatoraccid();
  static const int kApplicatorACCIDFieldNumber = 1;
  inline const ::std::string& applicatoraccid() const;
  inline void set_applicatoraccid(const ::std::string& value);
  inline void set_applicatoraccid(const char* value);
  inline void set_applicatoraccid(const char* value, size_t size);
  inline ::std::string* mutable_applicatoraccid();
  inline ::std::string* release_applicatoraccid();
  
  // optional float sizeX = 2;
  inline bool has_sizex() const;
  inline void clear_sizex();
  static const int kSizeXFieldNumber = 2;
  inline float sizex() const;
  inline void set_sizex(float value);
  
  // optional float sizeY = 3;
  inline bool has_sizey() const;
  inline void clear_sizey();
  static const int kSizeYFieldNumber = 3;
  inline float sizey() const;
  inline void set_sizey(float value);
  
  // optional string applicatorUID = 4;
  inline bool has_applicatoruid() const;
  inline void clear_applicatoruid();
  static const int kApplicatorUIDFieldNumber = 4;
  inline const ::std::string& applicatoruid() const;
  inline void set_applicatoruid(const ::std::string& value);
  inline void set_applicatoruid(const char* value);
  inline void set_applicatoruid(const char* value, size_t size);
  inline ::std::string* mutable_applicatoruid();
  inline ::std::string* release_applicatoruid();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineElectronApplicator)
 private:
  inline void set_has_applicatoraccid();
  inline void clear_has_applicatoraccid();
  inline void set_has_sizex();
  inline void clear_has_sizex();
  inline void set_has_sizey();
  inline void clear_has_sizey();
  inline void set_has_applicatoruid();
  inline void clear_has_applicatoruid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* applicatoraccid_;
  float sizex_;
  float sizey_;
  ::std::string* applicatoruid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineElectronApplicator* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineMotorizedWedge : public ::google::protobuf::Message {
 public:
  RT_MS_MachineMotorizedWedge();
  virtual ~RT_MS_MachineMotorizedWedge();
  
  RT_MS_MachineMotorizedWedge(const RT_MS_MachineMotorizedWedge& from);
  
  inline RT_MS_MachineMotorizedWedge& operator=(const RT_MS_MachineMotorizedWedge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineMotorizedWedge& default_instance();
  
  void Swap(RT_MS_MachineMotorizedWedge* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineMotorizedWedge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineMotorizedWedge& from);
  void MergeFrom(const RT_MS_MachineMotorizedWedge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 motorizedWedgeOrientation = 1;
  inline bool has_motorizedwedgeorientation() const;
  inline void clear_motorizedwedgeorientation();
  static const int kMotorizedWedgeOrientationFieldNumber = 1;
  inline ::google::protobuf::int32 motorizedwedgeorientation() const;
  inline void set_motorizedwedgeorientation(::google::protobuf::int32 value);
  
  // optional float motorizedFieldSizeLimitX = 2;
  inline bool has_motorizedfieldsizelimitx() const;
  inline void clear_motorizedfieldsizelimitx();
  static const int kMotorizedFieldSizeLimitXFieldNumber = 2;
  inline float motorizedfieldsizelimitx() const;
  inline void set_motorizedfieldsizelimitx(float value);
  
  // optional float motorizedfieldSizeLimitY = 3;
  inline bool has_motorizedfieldsizelimity() const;
  inline void clear_motorizedfieldsizelimity();
  static const int kMotorizedfieldSizeLimitYFieldNumber = 3;
  inline float motorizedfieldsizelimity() const;
  inline void set_motorizedfieldsizelimity(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineMotorizedWedge)
 private:
  inline void set_has_motorizedwedgeorientation();
  inline void clear_has_motorizedwedgeorientation();
  inline void set_has_motorizedfieldsizelimitx();
  inline void clear_has_motorizedfieldsizelimitx();
  inline void set_has_motorizedfieldsizelimity();
  inline void clear_has_motorizedfieldsizelimity();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 motorizedwedgeorientation_;
  float motorizedfieldsizelimitx_;
  float motorizedfieldsizelimity_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineMotorizedWedge* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MachineWedge : public ::google::protobuf::Message {
 public:
  RT_MS_MachineWedge();
  virtual ~RT_MS_MachineWedge();
  
  RT_MS_MachineWedge(const RT_MS_MachineWedge& from);
  
  inline RT_MS_MachineWedge& operator=(const RT_MS_MachineWedge& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MachineWedge& default_instance();
  
  void Swap(RT_MS_MachineWedge* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MachineWedge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MachineWedge& from);
  void MergeFrom(const RT_MS_MachineWedge& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string wedgeACCID = 1;
  inline bool has_wedgeaccid() const;
  inline void clear_wedgeaccid();
  static const int kWedgeACCIDFieldNumber = 1;
  inline const ::std::string& wedgeaccid() const;
  inline void set_wedgeaccid(const ::std::string& value);
  inline void set_wedgeaccid(const char* value);
  inline void set_wedgeaccid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeaccid();
  inline ::std::string* release_wedgeaccid();
  
  // optional float degree = 2;
  inline bool has_degree() const;
  inline void clear_degree();
  static const int kDegreeFieldNumber = 2;
  inline float degree() const;
  inline void set_degree(float value);
  
  // optional float leftMin = 3;
  inline bool has_leftmin() const;
  inline void clear_leftmin();
  static const int kLeftMinFieldNumber = 3;
  inline float leftmin() const;
  inline void set_leftmin(float value);
  
  // optional float leftMax = 4;
  inline bool has_leftmax() const;
  inline void clear_leftmax();
  static const int kLeftMaxFieldNumber = 4;
  inline float leftmax() const;
  inline void set_leftmax(float value);
  
  // optional float rightMin = 5;
  inline bool has_rightmin() const;
  inline void clear_rightmin();
  static const int kRightMinFieldNumber = 5;
  inline float rightmin() const;
  inline void set_rightmin(float value);
  
  // optional float rightMax = 6;
  inline bool has_rightmax() const;
  inline void clear_rightmax();
  static const int kRightMaxFieldNumber = 6;
  inline float rightmax() const;
  inline void set_rightmax(float value);
  
  // optional float topMin = 7;
  inline bool has_topmin() const;
  inline void clear_topmin();
  static const int kTopMinFieldNumber = 7;
  inline float topmin() const;
  inline void set_topmin(float value);
  
  // optional float topMax = 8;
  inline bool has_topmax() const;
  inline void clear_topmax();
  static const int kTopMaxFieldNumber = 8;
  inline float topmax() const;
  inline void set_topmax(float value);
  
  // optional float bottomMin = 9;
  inline bool has_bottommin() const;
  inline void clear_bottommin();
  static const int kBottomMinFieldNumber = 9;
  inline float bottommin() const;
  inline void set_bottommin(float value);
  
  // optional float bottomMax = 10;
  inline bool has_bottommax() const;
  inline void clear_bottommax();
  static const int kBottomMaxFieldNumber = 10;
  inline float bottommax() const;
  inline void set_bottommax(float value);
  
  // optional string orientationType = 11;
  inline bool has_orientationtype() const;
  inline void clear_orientationtype();
  static const int kOrientationTypeFieldNumber = 11;
  inline const ::std::string& orientationtype() const;
  inline void set_orientationtype(const ::std::string& value);
  inline void set_orientationtype(const char* value);
  inline void set_orientationtype(const char* value, size_t size);
  inline ::std::string* mutable_orientationtype();
  inline ::std::string* release_orientationtype();
  
  // optional string wedgeUID = 12;
  inline bool has_wedgeuid() const;
  inline void clear_wedgeuid();
  static const int kWedgeUIDFieldNumber = 12;
  inline const ::std::string& wedgeuid() const;
  inline void set_wedgeuid(const ::std::string& value);
  inline void set_wedgeuid(const char* value);
  inline void set_wedgeuid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeuid();
  inline ::std::string* release_wedgeuid();
  
  // optional int32 wedgeType = 13;
  inline bool has_wedgetype() const;
  inline void clear_wedgetype();
  static const int kWedgeTypeFieldNumber = 13;
  inline ::google::protobuf::int32 wedgetype() const;
  inline void set_wedgetype(::google::protobuf::int32 value);
  
  // optional string accCode = 14;
  inline bool has_acccode() const;
  inline void clear_acccode();
  static const int kAccCodeFieldNumber = 14;
  inline const ::std::string& acccode() const;
  inline void set_acccode(const ::std::string& value);
  inline void set_acccode(const char* value);
  inline void set_acccode(const char* value, size_t size);
  inline ::std::string* mutable_acccode();
  inline ::std::string* release_acccode();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MachineWedge)
 private:
  inline void set_has_wedgeaccid();
  inline void clear_has_wedgeaccid();
  inline void set_has_degree();
  inline void clear_has_degree();
  inline void set_has_leftmin();
  inline void clear_has_leftmin();
  inline void set_has_leftmax();
  inline void clear_has_leftmax();
  inline void set_has_rightmin();
  inline void clear_has_rightmin();
  inline void set_has_rightmax();
  inline void clear_has_rightmax();
  inline void set_has_topmin();
  inline void clear_has_topmin();
  inline void set_has_topmax();
  inline void clear_has_topmax();
  inline void set_has_bottommin();
  inline void clear_has_bottommin();
  inline void set_has_bottommax();
  inline void clear_has_bottommax();
  inline void set_has_orientationtype();
  inline void clear_has_orientationtype();
  inline void set_has_wedgeuid();
  inline void clear_has_wedgeuid();
  inline void set_has_wedgetype();
  inline void clear_has_wedgetype();
  inline void set_has_acccode();
  inline void clear_has_acccode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* wedgeaccid_;
  float degree_;
  float leftmin_;
  float leftmax_;
  float rightmin_;
  float rightmax_;
  float topmin_;
  float topmax_;
  float bottommin_;
  ::std::string* orientationtype_;
  float bottommax_;
  ::google::protobuf::int32 wedgetype_;
  ::std::string* wedgeuid_;
  ::std::string* acccode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmachinesettingconfig_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmachinesettingconfig_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MachineWedge* default_instance_;
};
// ===================================================================


// ===================================================================

// RT_MS_MachineSettingInfoList

// repeated .ms.proto.RT_MS_MachineConfigInfo machineSettingList = 1;
inline int RT_MS_MachineSettingInfoList::machinesettinglist_size() const {
  return machinesettinglist_.size();
}
inline void RT_MS_MachineSettingInfoList::clear_machinesettinglist() {
  machinesettinglist_.Clear();
}
inline const ::ms::proto::RT_MS_MachineConfigInfo& RT_MS_MachineSettingInfoList::machinesettinglist(int index) const {
  return machinesettinglist_.Get(index);
}
inline ::ms::proto::RT_MS_MachineConfigInfo* RT_MS_MachineSettingInfoList::mutable_machinesettinglist(int index) {
  return machinesettinglist_.Mutable(index);
}
inline ::ms::proto::RT_MS_MachineConfigInfo* RT_MS_MachineSettingInfoList::add_machinesettinglist() {
  return machinesettinglist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineConfigInfo >&
RT_MS_MachineSettingInfoList::machinesettinglist() const {
  return machinesettinglist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineConfigInfo >*
RT_MS_MachineSettingInfoList::mutable_machinesettinglist() {
  return &machinesettinglist_;
}

// -------------------------------------------------------------------

// RT_MS_CommissionList

// repeated .ms.proto.RT_MS_CommissionInfo machineCommissionInfo = 1;
inline int RT_MS_CommissionList::machinecommissioninfo_size() const {
  return machinecommissioninfo_.size();
}
inline void RT_MS_CommissionList::clear_machinecommissioninfo() {
  machinecommissioninfo_.Clear();
}
inline const ::ms::proto::RT_MS_CommissionInfo& RT_MS_CommissionList::machinecommissioninfo(int index) const {
  return machinecommissioninfo_.Get(index);
}
inline ::ms::proto::RT_MS_CommissionInfo* RT_MS_CommissionList::mutable_machinecommissioninfo(int index) {
  return machinecommissioninfo_.Mutable(index);
}
inline ::ms::proto::RT_MS_CommissionInfo* RT_MS_CommissionList::add_machinecommissioninfo() {
  return machinecommissioninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >&
RT_MS_CommissionList::machinecommissioninfo() const {
  return machinecommissioninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >*
RT_MS_CommissionList::mutable_machinecommissioninfo() {
  return &machinecommissioninfo_;
}

// -------------------------------------------------------------------

// RT_MS_MachineConfigInfo

// optional .ms.proto.RT_MS_MachineGeneral machineGeneralInfo = 1;
inline bool RT_MS_MachineConfigInfo::has_machinegeneralinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_machinegeneralinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineConfigInfo::clear_has_machinegeneralinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineConfigInfo::clear_machinegeneralinfo() {
  if (machinegeneralinfo_ != NULL) machinegeneralinfo_->::ms::proto::RT_MS_MachineGeneral::Clear();
  clear_has_machinegeneralinfo();
}
inline const ::ms::proto::RT_MS_MachineGeneral& RT_MS_MachineConfigInfo::machinegeneralinfo() const {
  return machinegeneralinfo_ != NULL ? *machinegeneralinfo_ : *default_instance_->machinegeneralinfo_;
}
inline ::ms::proto::RT_MS_MachineGeneral* RT_MS_MachineConfigInfo::mutable_machinegeneralinfo() {
  set_has_machinegeneralinfo();
  if (machinegeneralinfo_ == NULL) machinegeneralinfo_ = new ::ms::proto::RT_MS_MachineGeneral;
  return machinegeneralinfo_;
}
inline ::ms::proto::RT_MS_MachineGeneral* RT_MS_MachineConfigInfo::release_machinegeneralinfo() {
  clear_has_machinegeneralinfo();
  ::ms::proto::RT_MS_MachineGeneral* temp = machinegeneralinfo_;
  machinegeneralinfo_ = NULL;
  return temp;
}

// optional .ms.proto.RT_MS_MachineGeometry machineGeometry = 2;
inline bool RT_MS_MachineConfigInfo::has_machinegeometry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_machinegeometry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineConfigInfo::clear_has_machinegeometry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineConfigInfo::clear_machinegeometry() {
  if (machinegeometry_ != NULL) machinegeometry_->::ms::proto::RT_MS_MachineGeometry::Clear();
  clear_has_machinegeometry();
}
inline const ::ms::proto::RT_MS_MachineGeometry& RT_MS_MachineConfigInfo::machinegeometry() const {
  return machinegeometry_ != NULL ? *machinegeometry_ : *default_instance_->machinegeometry_;
}
inline ::ms::proto::RT_MS_MachineGeometry* RT_MS_MachineConfigInfo::mutable_machinegeometry() {
  set_has_machinegeometry();
  if (machinegeometry_ == NULL) machinegeometry_ = new ::ms::proto::RT_MS_MachineGeometry;
  return machinegeometry_;
}
inline ::ms::proto::RT_MS_MachineGeometry* RT_MS_MachineConfigInfo::release_machinegeometry() {
  clear_has_machinegeometry();
  ::ms::proto::RT_MS_MachineGeometry* temp = machinegeometry_;
  machinegeometry_ = NULL;
  return temp;
}

// optional .ms.proto.RT_MS_MachineJaw machineJaw = 3;
inline bool RT_MS_MachineConfigInfo::has_machinejaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_machinejaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineConfigInfo::clear_has_machinejaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineConfigInfo::clear_machinejaw() {
  if (machinejaw_ != NULL) machinejaw_->::ms::proto::RT_MS_MachineJaw::Clear();
  clear_has_machinejaw();
}
inline const ::ms::proto::RT_MS_MachineJaw& RT_MS_MachineConfigInfo::machinejaw() const {
  return machinejaw_ != NULL ? *machinejaw_ : *default_instance_->machinejaw_;
}
inline ::ms::proto::RT_MS_MachineJaw* RT_MS_MachineConfigInfo::mutable_machinejaw() {
  set_has_machinejaw();
  if (machinejaw_ == NULL) machinejaw_ = new ::ms::proto::RT_MS_MachineJaw;
  return machinejaw_;
}
inline ::ms::proto::RT_MS_MachineJaw* RT_MS_MachineConfigInfo::release_machinejaw() {
  clear_has_machinejaw();
  ::ms::proto::RT_MS_MachineJaw* temp = machinejaw_;
  machinejaw_ = NULL;
  return temp;
}

// optional .ms.proto.RT_MS_MachineMLC machineMLC = 4;
inline bool RT_MS_MachineConfigInfo::has_machinemlc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_machinemlc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineConfigInfo::clear_has_machinemlc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineConfigInfo::clear_machinemlc() {
  if (machinemlc_ != NULL) machinemlc_->::ms::proto::RT_MS_MachineMLC::Clear();
  clear_has_machinemlc();
}
inline const ::ms::proto::RT_MS_MachineMLC& RT_MS_MachineConfigInfo::machinemlc() const {
  return machinemlc_ != NULL ? *machinemlc_ : *default_instance_->machinemlc_;
}
inline ::ms::proto::RT_MS_MachineMLC* RT_MS_MachineConfigInfo::mutable_machinemlc() {
  set_has_machinemlc();
  if (machinemlc_ == NULL) machinemlc_ = new ::ms::proto::RT_MS_MachineMLC;
  return machinemlc_;
}
inline ::ms::proto::RT_MS_MachineMLC* RT_MS_MachineConfigInfo::release_machinemlc() {
  clear_has_machinemlc();
  ::ms::proto::RT_MS_MachineMLC* temp = machinemlc_;
  machinemlc_ = NULL;
  return temp;
}

// optional .ms.proto.RT_MS_MachineAccessories machineAccessories = 5;
inline bool RT_MS_MachineConfigInfo::has_machineaccessories() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_machineaccessories() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineConfigInfo::clear_has_machineaccessories() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineConfigInfo::clear_machineaccessories() {
  if (machineaccessories_ != NULL) machineaccessories_->::ms::proto::RT_MS_MachineAccessories::Clear();
  clear_has_machineaccessories();
}
inline const ::ms::proto::RT_MS_MachineAccessories& RT_MS_MachineConfigInfo::machineaccessories() const {
  return machineaccessories_ != NULL ? *machineaccessories_ : *default_instance_->machineaccessories_;
}
inline ::ms::proto::RT_MS_MachineAccessories* RT_MS_MachineConfigInfo::mutable_machineaccessories() {
  set_has_machineaccessories();
  if (machineaccessories_ == NULL) machineaccessories_ = new ::ms::proto::RT_MS_MachineAccessories;
  return machineaccessories_;
}
inline ::ms::proto::RT_MS_MachineAccessories* RT_MS_MachineConfigInfo::release_machineaccessories() {
  clear_has_machineaccessories();
  ::ms::proto::RT_MS_MachineAccessories* temp = machineaccessories_;
  machineaccessories_ = NULL;
  return temp;
}

// optional bool isApprove = 6;
inline bool RT_MS_MachineConfigInfo::has_isapprove() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_isapprove() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineConfigInfo::clear_has_isapprove() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineConfigInfo::clear_isapprove() {
  isapprove_ = false;
  clear_has_isapprove();
}
inline bool RT_MS_MachineConfigInfo::isapprove() const {
  return isapprove_;
}
inline void RT_MS_MachineConfigInfo::set_isapprove(bool value) {
  set_has_isapprove();
  isapprove_ = value;
}

// optional bool isActive = 7;
inline bool RT_MS_MachineConfigInfo::has_isactive() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_isactive() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineConfigInfo::clear_has_isactive() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineConfigInfo::clear_isactive() {
  isactive_ = false;
  clear_has_isactive();
}
inline bool RT_MS_MachineConfigInfo::isactive() const {
  return isactive_;
}
inline void RT_MS_MachineConfigInfo::set_isactive(bool value) {
  set_has_isactive();
  isactive_ = value;
}

// repeated .ms.proto.RT_MS_CommissionInfo machineCommissionInfo = 8;
inline int RT_MS_MachineConfigInfo::machinecommissioninfo_size() const {
  return machinecommissioninfo_.size();
}
inline void RT_MS_MachineConfigInfo::clear_machinecommissioninfo() {
  machinecommissioninfo_.Clear();
}
inline const ::ms::proto::RT_MS_CommissionInfo& RT_MS_MachineConfigInfo::machinecommissioninfo(int index) const {
  return machinecommissioninfo_.Get(index);
}
inline ::ms::proto::RT_MS_CommissionInfo* RT_MS_MachineConfigInfo::mutable_machinecommissioninfo(int index) {
  return machinecommissioninfo_.Mutable(index);
}
inline ::ms::proto::RT_MS_CommissionInfo* RT_MS_MachineConfigInfo::add_machinecommissioninfo() {
  return machinecommissioninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >&
RT_MS_MachineConfigInfo::machinecommissioninfo() const {
  return machinecommissioninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_CommissionInfo >*
RT_MS_MachineConfigInfo::mutable_machinecommissioninfo() {
  return &machinecommissioninfo_;
}

// optional bool isCrcValid = 9;
inline bool RT_MS_MachineConfigInfo::has_iscrcvalid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineConfigInfo::set_has_iscrcvalid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineConfigInfo::clear_has_iscrcvalid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineConfigInfo::clear_iscrcvalid() {
  iscrcvalid_ = false;
  clear_has_iscrcvalid();
}
inline bool RT_MS_MachineConfigInfo::iscrcvalid() const {
  return iscrcvalid_;
}
inline void RT_MS_MachineConfigInfo::set_iscrcvalid(bool value) {
  set_has_iscrcvalid();
  iscrcvalid_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineGeneral

// optional string machineName = 1;
inline bool RT_MS_MachineGeneral::has_machinename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_machinename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineGeneral::clear_has_machinename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineGeneral::clear_machinename() {
  if (machinename_ != &::google::protobuf::internal::kEmptyString) {
    machinename_->clear();
  }
  clear_has_machinename();
}
inline const ::std::string& RT_MS_MachineGeneral::machinename() const {
  return *machinename_;
}
inline void RT_MS_MachineGeneral::set_machinename(const ::std::string& value) {
  set_has_machinename();
  if (machinename_ == &::google::protobuf::internal::kEmptyString) {
    machinename_ = new ::std::string;
  }
  machinename_->assign(value);
}
inline void RT_MS_MachineGeneral::set_machinename(const char* value) {
  set_has_machinename();
  if (machinename_ == &::google::protobuf::internal::kEmptyString) {
    machinename_ = new ::std::string;
  }
  machinename_->assign(value);
}
inline void RT_MS_MachineGeneral::set_machinename(const char* value, size_t size) {
  set_has_machinename();
  if (machinename_ == &::google::protobuf::internal::kEmptyString) {
    machinename_ = new ::std::string;
  }
  machinename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_machinename() {
  set_has_machinename();
  if (machinename_ == &::google::protobuf::internal::kEmptyString) {
    machinename_ = new ::std::string;
  }
  return machinename_;
}
inline ::std::string* RT_MS_MachineGeneral::release_machinename() {
  clear_has_machinename();
  if (machinename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = machinename_;
    machinename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string manufactory = 2;
inline bool RT_MS_MachineGeneral::has_manufactory() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_manufactory() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineGeneral::clear_has_manufactory() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineGeneral::clear_manufactory() {
  if (manufactory_ != &::google::protobuf::internal::kEmptyString) {
    manufactory_->clear();
  }
  clear_has_manufactory();
}
inline const ::std::string& RT_MS_MachineGeneral::manufactory() const {
  return *manufactory_;
}
inline void RT_MS_MachineGeneral::set_manufactory(const ::std::string& value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::kEmptyString) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
}
inline void RT_MS_MachineGeneral::set_manufactory(const char* value) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::kEmptyString) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(value);
}
inline void RT_MS_MachineGeneral::set_manufactory(const char* value, size_t size) {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::kEmptyString) {
    manufactory_ = new ::std::string;
  }
  manufactory_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_manufactory() {
  set_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::kEmptyString) {
    manufactory_ = new ::std::string;
  }
  return manufactory_;
}
inline ::std::string* RT_MS_MachineGeneral::release_manufactory() {
  clear_has_manufactory();
  if (manufactory_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufactory_;
    manufactory_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string DeviceID = 3;
inline bool RT_MS_MachineGeneral::has_deviceid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_deviceid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineGeneral::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineGeneral::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& RT_MS_MachineGeneral::deviceid() const {
  return *deviceid_;
}
inline void RT_MS_MachineGeneral::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void RT_MS_MachineGeneral::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void RT_MS_MachineGeneral::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* RT_MS_MachineGeneral::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string coordinationSystem = 4;
inline bool RT_MS_MachineGeneral::has_coordinationsystem() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_coordinationsystem() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineGeneral::clear_has_coordinationsystem() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineGeneral::clear_coordinationsystem() {
  if (coordinationsystem_ != &::google::protobuf::internal::kEmptyString) {
    coordinationsystem_->clear();
  }
  clear_has_coordinationsystem();
}
inline const ::std::string& RT_MS_MachineGeneral::coordinationsystem() const {
  return *coordinationsystem_;
}
inline void RT_MS_MachineGeneral::set_coordinationsystem(const ::std::string& value) {
  set_has_coordinationsystem();
  if (coordinationsystem_ == &::google::protobuf::internal::kEmptyString) {
    coordinationsystem_ = new ::std::string;
  }
  coordinationsystem_->assign(value);
}
inline void RT_MS_MachineGeneral::set_coordinationsystem(const char* value) {
  set_has_coordinationsystem();
  if (coordinationsystem_ == &::google::protobuf::internal::kEmptyString) {
    coordinationsystem_ = new ::std::string;
  }
  coordinationsystem_->assign(value);
}
inline void RT_MS_MachineGeneral::set_coordinationsystem(const char* value, size_t size) {
  set_has_coordinationsystem();
  if (coordinationsystem_ == &::google::protobuf::internal::kEmptyString) {
    coordinationsystem_ = new ::std::string;
  }
  coordinationsystem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_coordinationsystem() {
  set_has_coordinationsystem();
  if (coordinationsystem_ == &::google::protobuf::internal::kEmptyString) {
    coordinationsystem_ = new ::std::string;
  }
  return coordinationsystem_;
}
inline ::std::string* RT_MS_MachineGeneral::release_coordinationsystem() {
  clear_has_coordinationsystem();
  if (coordinationsystem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coordinationsystem_;
    coordinationsystem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string date = 5;
inline bool RT_MS_MachineGeneral::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineGeneral::clear_has_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineGeneral::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& RT_MS_MachineGeneral::date() const {
  return *date_;
}
inline void RT_MS_MachineGeneral::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void RT_MS_MachineGeneral::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void RT_MS_MachineGeneral::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* RT_MS_MachineGeneral::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string time = 6;
inline bool RT_MS_MachineGeneral::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineGeneral::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineGeneral::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& RT_MS_MachineGeneral::time() const {
  return *time_;
}
inline void RT_MS_MachineGeneral::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void RT_MS_MachineGeneral::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void RT_MS_MachineGeneral::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* RT_MS_MachineGeneral::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string byWho = 7;
inline bool RT_MS_MachineGeneral::has_bywho() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_bywho() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineGeneral::clear_has_bywho() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineGeneral::clear_bywho() {
  if (bywho_ != &::google::protobuf::internal::kEmptyString) {
    bywho_->clear();
  }
  clear_has_bywho();
}
inline const ::std::string& RT_MS_MachineGeneral::bywho() const {
  return *bywho_;
}
inline void RT_MS_MachineGeneral::set_bywho(const ::std::string& value) {
  set_has_bywho();
  if (bywho_ == &::google::protobuf::internal::kEmptyString) {
    bywho_ = new ::std::string;
  }
  bywho_->assign(value);
}
inline void RT_MS_MachineGeneral::set_bywho(const char* value) {
  set_has_bywho();
  if (bywho_ == &::google::protobuf::internal::kEmptyString) {
    bywho_ = new ::std::string;
  }
  bywho_->assign(value);
}
inline void RT_MS_MachineGeneral::set_bywho(const char* value, size_t size) {
  set_has_bywho();
  if (bywho_ == &::google::protobuf::internal::kEmptyString) {
    bywho_ = new ::std::string;
  }
  bywho_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_bywho() {
  set_has_bywho();
  if (bywho_ == &::google::protobuf::internal::kEmptyString) {
    bywho_ = new ::std::string;
  }
  return bywho_;
}
inline ::std::string* RT_MS_MachineGeneral::release_bywho() {
  clear_has_bywho();
  if (bywho_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bywho_;
    bywho_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string comments = 8;
inline bool RT_MS_MachineGeneral::has_comments() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_comments() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MachineGeneral::clear_has_comments() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MachineGeneral::clear_comments() {
  if (comments_ != &::google::protobuf::internal::kEmptyString) {
    comments_->clear();
  }
  clear_has_comments();
}
inline const ::std::string& RT_MS_MachineGeneral::comments() const {
  return *comments_;
}
inline void RT_MS_MachineGeneral::set_comments(const ::std::string& value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void RT_MS_MachineGeneral::set_comments(const char* value) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(value);
}
inline void RT_MS_MachineGeneral::set_comments(const char* value, size_t size) {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  comments_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_comments() {
  set_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    comments_ = new ::std::string;
  }
  return comments_;
}
inline ::std::string* RT_MS_MachineGeneral::release_comments() {
  clear_has_comments();
  if (comments_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comments_;
    comments_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 9;
inline bool RT_MS_MachineGeneral::has_uid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineGeneral::set_has_uid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineGeneral::clear_has_uid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineGeneral::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_MachineGeneral::uid() const {
  return *uid_;
}
inline void RT_MS_MachineGeneral::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MachineGeneral::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MachineGeneral::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineGeneral::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_MachineGeneral::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RT_MS_MachineGeometry

// optional float gantryAngleMin = 1;
inline bool RT_MS_MachineGeometry::has_gantryanglemin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_gantryanglemin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineGeometry::clear_has_gantryanglemin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineGeometry::clear_gantryanglemin() {
  gantryanglemin_ = 0;
  clear_has_gantryanglemin();
}
inline float RT_MS_MachineGeometry::gantryanglemin() const {
  return gantryanglemin_;
}
inline void RT_MS_MachineGeometry::set_gantryanglemin(float value) {
  set_has_gantryanglemin();
  gantryanglemin_ = value;
}

// optional float gantryAngleMax = 2;
inline bool RT_MS_MachineGeometry::has_gantryanglemax() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_gantryanglemax() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineGeometry::clear_has_gantryanglemax() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineGeometry::clear_gantryanglemax() {
  gantryanglemax_ = 0;
  clear_has_gantryanglemax();
}
inline float RT_MS_MachineGeometry::gantryanglemax() const {
  return gantryanglemax_;
}
inline void RT_MS_MachineGeometry::set_gantryanglemax(float value) {
  set_has_gantryanglemax();
  gantryanglemax_ = value;
}

// optional float maxSpeedLimit = 3;
inline bool RT_MS_MachineGeometry::has_maxspeedlimit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_maxspeedlimit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineGeometry::clear_has_maxspeedlimit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineGeometry::clear_maxspeedlimit() {
  maxspeedlimit_ = 0;
  clear_has_maxspeedlimit();
}
inline float RT_MS_MachineGeometry::maxspeedlimit() const {
  return maxspeedlimit_;
}
inline void RT_MS_MachineGeometry::set_maxspeedlimit(float value) {
  set_has_maxspeedlimit();
  maxspeedlimit_ = value;
}

// optional float sad = 4;
inline bool RT_MS_MachineGeometry::has_sad() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_sad() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineGeometry::clear_has_sad() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineGeometry::clear_sad() {
  sad_ = 0;
  clear_has_sad();
}
inline float RT_MS_MachineGeometry::sad() const {
  return sad_;
}
inline void RT_MS_MachineGeometry::set_sad(float value) {
  set_has_sad();
  sad_ = value;
}

// optional float cwLimit = 5;
inline bool RT_MS_MachineGeometry::has_cwlimit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_cwlimit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineGeometry::clear_has_cwlimit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineGeometry::clear_cwlimit() {
  cwlimit_ = 0;
  clear_has_cwlimit();
}
inline float RT_MS_MachineGeometry::cwlimit() const {
  return cwlimit_;
}
inline void RT_MS_MachineGeometry::set_cwlimit(float value) {
  set_has_cwlimit();
  cwlimit_ = value;
}

// optional float ccwLimit = 6;
inline bool RT_MS_MachineGeometry::has_ccwlimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_ccwlimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineGeometry::clear_has_ccwlimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineGeometry::clear_ccwlimit() {
  ccwlimit_ = 0;
  clear_has_ccwlimit();
}
inline float RT_MS_MachineGeometry::ccwlimit() const {
  return ccwlimit_;
}
inline void RT_MS_MachineGeometry::set_ccwlimit(float value) {
  set_has_ccwlimit();
  ccwlimit_ = value;
}

// optional float collimatorLow = 7;
inline bool RT_MS_MachineGeometry::has_collimatorlow() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_collimatorlow() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineGeometry::clear_has_collimatorlow() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineGeometry::clear_collimatorlow() {
  collimatorlow_ = 0;
  clear_has_collimatorlow();
}
inline float RT_MS_MachineGeometry::collimatorlow() const {
  return collimatorlow_;
}
inline void RT_MS_MachineGeometry::set_collimatorlow(float value) {
  set_has_collimatorlow();
  collimatorlow_ = value;
}

// optional float collimatorHigh = 8;
inline bool RT_MS_MachineGeometry::has_collimatorhigh() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_collimatorhigh() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MachineGeometry::clear_has_collimatorhigh() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MachineGeometry::clear_collimatorhigh() {
  collimatorhigh_ = 0;
  clear_has_collimatorhigh();
}
inline float RT_MS_MachineGeometry::collimatorhigh() const {
  return collimatorhigh_;
}
inline void RT_MS_MachineGeometry::set_collimatorhigh(float value) {
  set_has_collimatorhigh();
  collimatorhigh_ = value;
}

// optional float lateralMotionMax = 9;
inline bool RT_MS_MachineGeometry::has_lateralmotionmax() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_lateralmotionmax() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineGeometry::clear_has_lateralmotionmax() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineGeometry::clear_lateralmotionmax() {
  lateralmotionmax_ = 0;
  clear_has_lateralmotionmax();
}
inline float RT_MS_MachineGeometry::lateralmotionmax() const {
  return lateralmotionmax_;
}
inline void RT_MS_MachineGeometry::set_lateralmotionmax(float value) {
  set_has_lateralmotionmax();
  lateralmotionmax_ = value;
}

// optional float lateralMotionMin = 10;
inline bool RT_MS_MachineGeometry::has_lateralmotionmin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_lateralmotionmin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MachineGeometry::clear_has_lateralmotionmin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MachineGeometry::clear_lateralmotionmin() {
  lateralmotionmin_ = 0;
  clear_has_lateralmotionmin();
}
inline float RT_MS_MachineGeometry::lateralmotionmin() const {
  return lateralmotionmin_;
}
inline void RT_MS_MachineGeometry::set_lateralmotionmin(float value) {
  set_has_lateralmotionmin();
  lateralmotionmin_ = value;
}

// optional float longitudeMotionMin = 11;
inline bool RT_MS_MachineGeometry::has_longitudemotionmin() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_longitudemotionmin() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MachineGeometry::clear_has_longitudemotionmin() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MachineGeometry::clear_longitudemotionmin() {
  longitudemotionmin_ = 0;
  clear_has_longitudemotionmin();
}
inline float RT_MS_MachineGeometry::longitudemotionmin() const {
  return longitudemotionmin_;
}
inline void RT_MS_MachineGeometry::set_longitudemotionmin(float value) {
  set_has_longitudemotionmin();
  longitudemotionmin_ = value;
}

// optional float longitudeMotionMax = 12;
inline bool RT_MS_MachineGeometry::has_longitudemotionmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_longitudemotionmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MachineGeometry::clear_has_longitudemotionmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MachineGeometry::clear_longitudemotionmax() {
  longitudemotionmax_ = 0;
  clear_has_longitudemotionmax();
}
inline float RT_MS_MachineGeometry::longitudemotionmax() const {
  return longitudemotionmax_;
}
inline void RT_MS_MachineGeometry::set_longitudemotionmax(float value) {
  set_has_longitudemotionmax();
  longitudemotionmax_ = value;
}

// optional float verticalMotionMax = 13;
inline bool RT_MS_MachineGeometry::has_verticalmotionmax() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_verticalmotionmax() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_MachineGeometry::clear_has_verticalmotionmax() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_MachineGeometry::clear_verticalmotionmax() {
  verticalmotionmax_ = 0;
  clear_has_verticalmotionmax();
}
inline float RT_MS_MachineGeometry::verticalmotionmax() const {
  return verticalmotionmax_;
}
inline void RT_MS_MachineGeometry::set_verticalmotionmax(float value) {
  set_has_verticalmotionmax();
  verticalmotionmax_ = value;
}

// optional float verticalMotionMin = 14;
inline bool RT_MS_MachineGeometry::has_verticalmotionmin() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_verticalmotionmin() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_MachineGeometry::clear_has_verticalmotionmin() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_MachineGeometry::clear_verticalmotionmin() {
  verticalmotionmin_ = 0;
  clear_has_verticalmotionmin();
}
inline float RT_MS_MachineGeometry::verticalmotionmin() const {
  return verticalmotionmin_;
}
inline void RT_MS_MachineGeometry::set_verticalmotionmin(float value) {
  set_has_verticalmotionmin();
  verticalmotionmin_ = value;
}

// optional float rTNMax = 15;
inline bool RT_MS_MachineGeometry::has_rtnmax() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_rtnmax() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_MachineGeometry::clear_has_rtnmax() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_MachineGeometry::clear_rtnmax() {
  rtnmax_ = 0;
  clear_has_rtnmax();
}
inline float RT_MS_MachineGeometry::rtnmax() const {
  return rtnmax_;
}
inline void RT_MS_MachineGeometry::set_rtnmax(float value) {
  set_has_rtnmax();
  rtnmax_ = value;
}

// optional float rTNMIN = 16;
inline bool RT_MS_MachineGeometry::has_rtnmin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_rtnmin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_MachineGeometry::clear_has_rtnmin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_MachineGeometry::clear_rtnmin() {
  rtnmin_ = 0;
  clear_has_rtnmin();
}
inline float RT_MS_MachineGeometry::rtnmin() const {
  return rtnmin_;
}
inline void RT_MS_MachineGeometry::set_rtnmin(float value) {
  set_has_rtnmin();
  rtnmin_ = value;
}

// optional float minGantrySpeed_DegreeperSecond = 17;
inline bool RT_MS_MachineGeometry::has_mingantryspeed_degreepersecond() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_MachineGeometry::set_has_mingantryspeed_degreepersecond() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_MachineGeometry::clear_has_mingantryspeed_degreepersecond() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_MachineGeometry::clear_mingantryspeed_degreepersecond() {
  mingantryspeed_degreepersecond_ = 0;
  clear_has_mingantryspeed_degreepersecond();
}
inline float RT_MS_MachineGeometry::mingantryspeed_degreepersecond() const {
  return mingantryspeed_degreepersecond_;
}
inline void RT_MS_MachineGeometry::set_mingantryspeed_degreepersecond(float value) {
  set_has_mingantryspeed_degreepersecond();
  mingantryspeed_degreepersecond_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineJaw

// optional bool isXjaw = 1;
inline bool RT_MS_MachineJaw::has_isxjaw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineJaw::set_has_isxjaw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineJaw::clear_has_isxjaw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineJaw::clear_isxjaw() {
  isxjaw_ = false;
  clear_has_isxjaw();
}
inline bool RT_MS_MachineJaw::isxjaw() const {
  return isxjaw_;
}
inline void RT_MS_MachineJaw::set_isxjaw(bool value) {
  set_has_isxjaw();
  isxjaw_ = value;
}

// optional bool isYjaw = 2;
inline bool RT_MS_MachineJaw::has_isyjaw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineJaw::set_has_isyjaw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineJaw::clear_has_isyjaw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineJaw::clear_isyjaw() {
  isyjaw_ = false;
  clear_has_isyjaw();
}
inline bool RT_MS_MachineJaw::isyjaw() const {
  return isyjaw_;
}
inline void RT_MS_MachineJaw::set_isyjaw(bool value) {
  set_has_isyjaw();
  isyjaw_ = value;
}

// optional bool isXasym = 3;
inline bool RT_MS_MachineJaw::has_isxasym() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineJaw::set_has_isxasym() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineJaw::clear_has_isxasym() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineJaw::clear_isxasym() {
  isxasym_ = false;
  clear_has_isxasym();
}
inline bool RT_MS_MachineJaw::isxasym() const {
  return isxasym_;
}
inline void RT_MS_MachineJaw::set_isxasym(bool value) {
  set_has_isxasym();
  isxasym_ = value;
}

// optional bool isYasym = 4;
inline bool RT_MS_MachineJaw::has_isyasym() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineJaw::set_has_isyasym() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineJaw::clear_has_isyasym() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineJaw::clear_isyasym() {
  isyasym_ = false;
  clear_has_isyasym();
}
inline bool RT_MS_MachineJaw::isyasym() const {
  return isyasym_;
}
inline void RT_MS_MachineJaw::set_isyasym(bool value) {
  set_has_isyasym();
  isyasym_ = value;
}

// optional string leftJawLabel = 5;
inline bool RT_MS_MachineJaw::has_leftjawlabel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineJaw::set_has_leftjawlabel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineJaw::clear_has_leftjawlabel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineJaw::clear_leftjawlabel() {
  if (leftjawlabel_ != &::google::protobuf::internal::kEmptyString) {
    leftjawlabel_->clear();
  }
  clear_has_leftjawlabel();
}
inline const ::std::string& RT_MS_MachineJaw::leftjawlabel() const {
  return *leftjawlabel_;
}
inline void RT_MS_MachineJaw::set_leftjawlabel(const ::std::string& value) {
  set_has_leftjawlabel();
  if (leftjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    leftjawlabel_ = new ::std::string;
  }
  leftjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_leftjawlabel(const char* value) {
  set_has_leftjawlabel();
  if (leftjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    leftjawlabel_ = new ::std::string;
  }
  leftjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_leftjawlabel(const char* value, size_t size) {
  set_has_leftjawlabel();
  if (leftjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    leftjawlabel_ = new ::std::string;
  }
  leftjawlabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineJaw::mutable_leftjawlabel() {
  set_has_leftjawlabel();
  if (leftjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    leftjawlabel_ = new ::std::string;
  }
  return leftjawlabel_;
}
inline ::std::string* RT_MS_MachineJaw::release_leftjawlabel() {
  clear_has_leftjawlabel();
  if (leftjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leftjawlabel_;
    leftjawlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rightJawLabel = 6;
inline bool RT_MS_MachineJaw::has_rightjawlabel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineJaw::set_has_rightjawlabel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineJaw::clear_has_rightjawlabel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineJaw::clear_rightjawlabel() {
  if (rightjawlabel_ != &::google::protobuf::internal::kEmptyString) {
    rightjawlabel_->clear();
  }
  clear_has_rightjawlabel();
}
inline const ::std::string& RT_MS_MachineJaw::rightjawlabel() const {
  return *rightjawlabel_;
}
inline void RT_MS_MachineJaw::set_rightjawlabel(const ::std::string& value) {
  set_has_rightjawlabel();
  if (rightjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    rightjawlabel_ = new ::std::string;
  }
  rightjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_rightjawlabel(const char* value) {
  set_has_rightjawlabel();
  if (rightjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    rightjawlabel_ = new ::std::string;
  }
  rightjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_rightjawlabel(const char* value, size_t size) {
  set_has_rightjawlabel();
  if (rightjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    rightjawlabel_ = new ::std::string;
  }
  rightjawlabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineJaw::mutable_rightjawlabel() {
  set_has_rightjawlabel();
  if (rightjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    rightjawlabel_ = new ::std::string;
  }
  return rightjawlabel_;
}
inline ::std::string* RT_MS_MachineJaw::release_rightjawlabel() {
  clear_has_rightjawlabel();
  if (rightjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rightjawlabel_;
    rightjawlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float maxLeftJawPosition = 7;
inline bool RT_MS_MachineJaw::has_maxleftjawposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineJaw::set_has_maxleftjawposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineJaw::clear_has_maxleftjawposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineJaw::clear_maxleftjawposition() {
  maxleftjawposition_ = 0;
  clear_has_maxleftjawposition();
}
inline float RT_MS_MachineJaw::maxleftjawposition() const {
  return maxleftjawposition_;
}
inline void RT_MS_MachineJaw::set_maxleftjawposition(float value) {
  set_has_maxleftjawposition();
  maxleftjawposition_ = value;
}

// optional float minLeftJawPosition = 8;
inline bool RT_MS_MachineJaw::has_minleftjawposition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MachineJaw::set_has_minleftjawposition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MachineJaw::clear_has_minleftjawposition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MachineJaw::clear_minleftjawposition() {
  minleftjawposition_ = 0;
  clear_has_minleftjawposition();
}
inline float RT_MS_MachineJaw::minleftjawposition() const {
  return minleftjawposition_;
}
inline void RT_MS_MachineJaw::set_minleftjawposition(float value) {
  set_has_minleftjawposition();
  minleftjawposition_ = value;
}

// optional float maxRightJawPosition = 9;
inline bool RT_MS_MachineJaw::has_maxrightjawposition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineJaw::set_has_maxrightjawposition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineJaw::clear_has_maxrightjawposition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineJaw::clear_maxrightjawposition() {
  maxrightjawposition_ = 0;
  clear_has_maxrightjawposition();
}
inline float RT_MS_MachineJaw::maxrightjawposition() const {
  return maxrightjawposition_;
}
inline void RT_MS_MachineJaw::set_maxrightjawposition(float value) {
  set_has_maxrightjawposition();
  maxrightjawposition_ = value;
}

// optional float minRightJawPosition = 10;
inline bool RT_MS_MachineJaw::has_minrightjawposition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MachineJaw::set_has_minrightjawposition() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MachineJaw::clear_has_minrightjawposition() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MachineJaw::clear_minrightjawposition() {
  minrightjawposition_ = 0;
  clear_has_minrightjawposition();
}
inline float RT_MS_MachineJaw::minrightjawposition() const {
  return minrightjawposition_;
}
inline void RT_MS_MachineJaw::set_minrightjawposition(float value) {
  set_has_minrightjawposition();
  minrightjawposition_ = value;
}

// optional float lateralJawOutsideEdge = 11;
inline bool RT_MS_MachineJaw::has_lateraljawoutsideedge() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MachineJaw::set_has_lateraljawoutsideedge() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MachineJaw::clear_has_lateraljawoutsideedge() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MachineJaw::clear_lateraljawoutsideedge() {
  lateraljawoutsideedge_ = 0;
  clear_has_lateraljawoutsideedge();
}
inline float RT_MS_MachineJaw::lateraljawoutsideedge() const {
  return lateraljawoutsideedge_;
}
inline void RT_MS_MachineJaw::set_lateraljawoutsideedge(float value) {
  set_has_lateraljawoutsideedge();
  lateraljawoutsideedge_ = value;
}

// optional float lateralInsideJawEdge = 12;
inline bool RT_MS_MachineJaw::has_lateralinsidejawedge() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MachineJaw::set_has_lateralinsidejawedge() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MachineJaw::clear_has_lateralinsidejawedge() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MachineJaw::clear_lateralinsidejawedge() {
  lateralinsidejawedge_ = 0;
  clear_has_lateralinsidejawedge();
}
inline float RT_MS_MachineJaw::lateralinsidejawedge() const {
  return lateralinsidejawedge_;
}
inline void RT_MS_MachineJaw::set_lateralinsidejawedge(float value) {
  set_has_lateralinsidejawedge();
  lateralinsidejawedge_ = value;
}

// optional float sourceLateralJawDistance = 13;
inline bool RT_MS_MachineJaw::has_sourcelateraljawdistance() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_sourcelateraljawdistance() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_MachineJaw::clear_has_sourcelateraljawdistance() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_MachineJaw::clear_sourcelateraljawdistance() {
  sourcelateraljawdistance_ = 0;
  clear_has_sourcelateraljawdistance();
}
inline float RT_MS_MachineJaw::sourcelateraljawdistance() const {
  return sourcelateraljawdistance_;
}
inline void RT_MS_MachineJaw::set_sourcelateraljawdistance(float value) {
  set_has_sourcelateraljawdistance();
  sourcelateraljawdistance_ = value;
}

// optional float jawGap = 14;
inline bool RT_MS_MachineJaw::has_jawgap() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_jawgap() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_MachineJaw::clear_has_jawgap() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_MachineJaw::clear_jawgap() {
  jawgap_ = 0;
  clear_has_jawgap();
}
inline float RT_MS_MachineJaw::jawgap() const {
  return jawgap_;
}
inline void RT_MS_MachineJaw::set_jawgap(float value) {
  set_has_jawgap();
  jawgap_ = value;
}

// optional float MaxJawSpeed = 15;
inline bool RT_MS_MachineJaw::has_maxjawspeed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_maxjawspeed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_MachineJaw::clear_has_maxjawspeed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_MachineJaw::clear_maxjawspeed() {
  maxjawspeed_ = 0;
  clear_has_maxjawspeed();
}
inline float RT_MS_MachineJaw::maxjawspeed() const {
  return maxjawspeed_;
}
inline void RT_MS_MachineJaw::set_maxjawspeed(float value) {
  set_has_maxjawspeed();
  maxjawspeed_ = value;
}

// optional string topJawLabel = 16;
inline bool RT_MS_MachineJaw::has_topjawlabel() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_topjawlabel() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_MachineJaw::clear_has_topjawlabel() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_MachineJaw::clear_topjawlabel() {
  if (topjawlabel_ != &::google::protobuf::internal::kEmptyString) {
    topjawlabel_->clear();
  }
  clear_has_topjawlabel();
}
inline const ::std::string& RT_MS_MachineJaw::topjawlabel() const {
  return *topjawlabel_;
}
inline void RT_MS_MachineJaw::set_topjawlabel(const ::std::string& value) {
  set_has_topjawlabel();
  if (topjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    topjawlabel_ = new ::std::string;
  }
  topjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_topjawlabel(const char* value) {
  set_has_topjawlabel();
  if (topjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    topjawlabel_ = new ::std::string;
  }
  topjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_topjawlabel(const char* value, size_t size) {
  set_has_topjawlabel();
  if (topjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    topjawlabel_ = new ::std::string;
  }
  topjawlabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineJaw::mutable_topjawlabel() {
  set_has_topjawlabel();
  if (topjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    topjawlabel_ = new ::std::string;
  }
  return topjawlabel_;
}
inline ::std::string* RT_MS_MachineJaw::release_topjawlabel() {
  clear_has_topjawlabel();
  if (topjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topjawlabel_;
    topjawlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string bottomJawLabel = 17;
inline bool RT_MS_MachineJaw::has_bottomjawlabel() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_bottomjawlabel() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_MachineJaw::clear_has_bottomjawlabel() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_MachineJaw::clear_bottomjawlabel() {
  if (bottomjawlabel_ != &::google::protobuf::internal::kEmptyString) {
    bottomjawlabel_->clear();
  }
  clear_has_bottomjawlabel();
}
inline const ::std::string& RT_MS_MachineJaw::bottomjawlabel() const {
  return *bottomjawlabel_;
}
inline void RT_MS_MachineJaw::set_bottomjawlabel(const ::std::string& value) {
  set_has_bottomjawlabel();
  if (bottomjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    bottomjawlabel_ = new ::std::string;
  }
  bottomjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_bottomjawlabel(const char* value) {
  set_has_bottomjawlabel();
  if (bottomjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    bottomjawlabel_ = new ::std::string;
  }
  bottomjawlabel_->assign(value);
}
inline void RT_MS_MachineJaw::set_bottomjawlabel(const char* value, size_t size) {
  set_has_bottomjawlabel();
  if (bottomjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    bottomjawlabel_ = new ::std::string;
  }
  bottomjawlabel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineJaw::mutable_bottomjawlabel() {
  set_has_bottomjawlabel();
  if (bottomjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    bottomjawlabel_ = new ::std::string;
  }
  return bottomjawlabel_;
}
inline ::std::string* RT_MS_MachineJaw::release_bottomjawlabel() {
  clear_has_bottomjawlabel();
  if (bottomjawlabel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bottomjawlabel_;
    bottomjawlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float maxTopJawPosition = 18;
inline bool RT_MS_MachineJaw::has_maxtopjawposition() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_maxtopjawposition() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_MachineJaw::clear_has_maxtopjawposition() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_MachineJaw::clear_maxtopjawposition() {
  maxtopjawposition_ = 0;
  clear_has_maxtopjawposition();
}
inline float RT_MS_MachineJaw::maxtopjawposition() const {
  return maxtopjawposition_;
}
inline void RT_MS_MachineJaw::set_maxtopjawposition(float value) {
  set_has_maxtopjawposition();
  maxtopjawposition_ = value;
}

// optional float minTopJawPosition = 19;
inline bool RT_MS_MachineJaw::has_mintopjawposition() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_mintopjawposition() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_MachineJaw::clear_has_mintopjawposition() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_MachineJaw::clear_mintopjawposition() {
  mintopjawposition_ = 0;
  clear_has_mintopjawposition();
}
inline float RT_MS_MachineJaw::mintopjawposition() const {
  return mintopjawposition_;
}
inline void RT_MS_MachineJaw::set_mintopjawposition(float value) {
  set_has_mintopjawposition();
  mintopjawposition_ = value;
}

// optional float maxBottomJawPosition = 20;
inline bool RT_MS_MachineJaw::has_maxbottomjawposition() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_maxbottomjawposition() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_MachineJaw::clear_has_maxbottomjawposition() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_MachineJaw::clear_maxbottomjawposition() {
  maxbottomjawposition_ = 0;
  clear_has_maxbottomjawposition();
}
inline float RT_MS_MachineJaw::maxbottomjawposition() const {
  return maxbottomjawposition_;
}
inline void RT_MS_MachineJaw::set_maxbottomjawposition(float value) {
  set_has_maxbottomjawposition();
  maxbottomjawposition_ = value;
}

// optional float minBottomJawPosition = 21;
inline bool RT_MS_MachineJaw::has_minbottomjawposition() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_minbottomjawposition() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_MachineJaw::clear_has_minbottomjawposition() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_MachineJaw::clear_minbottomjawposition() {
  minbottomjawposition_ = 0;
  clear_has_minbottomjawposition();
}
inline float RT_MS_MachineJaw::minbottomjawposition() const {
  return minbottomjawposition_;
}
inline void RT_MS_MachineJaw::set_minbottomjawposition(float value) {
  set_has_minbottomjawposition();
  minbottomjawposition_ = value;
}

// optional float longitudeJawOutsideEdge = 22;
inline bool RT_MS_MachineJaw::has_longitudejawoutsideedge() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_longitudejawoutsideedge() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_MachineJaw::clear_has_longitudejawoutsideedge() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_MachineJaw::clear_longitudejawoutsideedge() {
  longitudejawoutsideedge_ = 0;
  clear_has_longitudejawoutsideedge();
}
inline float RT_MS_MachineJaw::longitudejawoutsideedge() const {
  return longitudejawoutsideedge_;
}
inline void RT_MS_MachineJaw::set_longitudejawoutsideedge(float value) {
  set_has_longitudejawoutsideedge();
  longitudejawoutsideedge_ = value;
}

// optional float longitudeJawInsideEdge = 23;
inline bool RT_MS_MachineJaw::has_longitudejawinsideedge() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_longitudejawinsideedge() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_MachineJaw::clear_has_longitudejawinsideedge() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_MachineJaw::clear_longitudejawinsideedge() {
  longitudejawinsideedge_ = 0;
  clear_has_longitudejawinsideedge();
}
inline float RT_MS_MachineJaw::longitudejawinsideedge() const {
  return longitudejawinsideedge_;
}
inline void RT_MS_MachineJaw::set_longitudejawinsideedge(float value) {
  set_has_longitudejawinsideedge();
  longitudejawinsideedge_ = value;
}

// optional float sourceLongitudeJawDistance = 24;
inline bool RT_MS_MachineJaw::has_sourcelongitudejawdistance() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_sourcelongitudejawdistance() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RT_MS_MachineJaw::clear_has_sourcelongitudejawdistance() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RT_MS_MachineJaw::clear_sourcelongitudejawdistance() {
  sourcelongitudejawdistance_ = 0;
  clear_has_sourcelongitudejawdistance();
}
inline float RT_MS_MachineJaw::sourcelongitudejawdistance() const {
  return sourcelongitudejawdistance_;
}
inline void RT_MS_MachineJaw::set_sourcelongitudejawdistance(float value) {
  set_has_sourcelongitudejawdistance();
  sourcelongitudejawdistance_ = value;
}

// optional bool lateralTracking = 25;
inline bool RT_MS_MachineJaw::has_lateraltracking() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_lateraltracking() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RT_MS_MachineJaw::clear_has_lateraltracking() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RT_MS_MachineJaw::clear_lateraltracking() {
  lateraltracking_ = false;
  clear_has_lateraltracking();
}
inline bool RT_MS_MachineJaw::lateraltracking() const {
  return lateraltracking_;
}
inline void RT_MS_MachineJaw::set_lateraltracking(bool value) {
  set_has_lateraltracking();
  lateraltracking_ = value;
}

// optional bool longitudinalTranking = 26;
inline bool RT_MS_MachineJaw::has_longitudinaltranking() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_longitudinaltranking() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RT_MS_MachineJaw::clear_has_longitudinaltranking() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RT_MS_MachineJaw::clear_longitudinaltranking() {
  longitudinaltranking_ = false;
  clear_has_longitudinaltranking();
}
inline bool RT_MS_MachineJaw::longitudinaltranking() const {
  return longitudinaltranking_;
}
inline void RT_MS_MachineJaw::set_longitudinaltranking(bool value) {
  set_has_longitudinaltranking();
  longitudinaltranking_ = value;
}

// optional string note = 27;
inline bool RT_MS_MachineJaw::has_note() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_note() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RT_MS_MachineJaw::clear_has_note() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RT_MS_MachineJaw::clear_note() {
  if (note_ != &::google::protobuf::internal::kEmptyString) {
    note_->clear();
  }
  clear_has_note();
}
inline const ::std::string& RT_MS_MachineJaw::note() const {
  return *note_;
}
inline void RT_MS_MachineJaw::set_note(const ::std::string& value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void RT_MS_MachineJaw::set_note(const char* value) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(value);
}
inline void RT_MS_MachineJaw::set_note(const char* value, size_t size) {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  note_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineJaw::mutable_note() {
  set_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    note_ = new ::std::string;
  }
  return note_;
}
inline ::std::string* RT_MS_MachineJaw::release_note() {
  clear_has_note();
  if (note_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = note_;
    note_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isForceJawFollow = 28;
inline bool RT_MS_MachineJaw::has_isforcejawfollow() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RT_MS_MachineJaw::set_has_isforcejawfollow() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RT_MS_MachineJaw::clear_has_isforcejawfollow() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RT_MS_MachineJaw::clear_isforcejawfollow() {
  isforcejawfollow_ = false;
  clear_has_isforcejawfollow();
}
inline bool RT_MS_MachineJaw::isforcejawfollow() const {
  return isforcejawfollow_;
}
inline void RT_MS_MachineJaw::set_isforcejawfollow(bool value) {
  set_has_isforcejawfollow();
  isforcejawfollow_ = value;
}

// -------------------------------------------------------------------

// RT_MS_PairInfo

// optional string pairUID = 1;
inline bool RT_MS_PairInfo::has_pairuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_PairInfo::set_has_pairuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_PairInfo::clear_has_pairuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_PairInfo::clear_pairuid() {
  if (pairuid_ != &::google::protobuf::internal::kEmptyString) {
    pairuid_->clear();
  }
  clear_has_pairuid();
}
inline const ::std::string& RT_MS_PairInfo::pairuid() const {
  return *pairuid_;
}
inline void RT_MS_PairInfo::set_pairuid(const ::std::string& value) {
  set_has_pairuid();
  if (pairuid_ == &::google::protobuf::internal::kEmptyString) {
    pairuid_ = new ::std::string;
  }
  pairuid_->assign(value);
}
inline void RT_MS_PairInfo::set_pairuid(const char* value) {
  set_has_pairuid();
  if (pairuid_ == &::google::protobuf::internal::kEmptyString) {
    pairuid_ = new ::std::string;
  }
  pairuid_->assign(value);
}
inline void RT_MS_PairInfo::set_pairuid(const char* value, size_t size) {
  set_has_pairuid();
  if (pairuid_ == &::google::protobuf::internal::kEmptyString) {
    pairuid_ = new ::std::string;
  }
  pairuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_PairInfo::mutable_pairuid() {
  set_has_pairuid();
  if (pairuid_ == &::google::protobuf::internal::kEmptyString) {
    pairuid_ = new ::std::string;
  }
  return pairuid_;
}
inline ::std::string* RT_MS_PairInfo::release_pairuid() {
  clear_has_pairuid();
  if (pairuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pairuid_;
    pairuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 pair = 2;
inline bool RT_MS_PairInfo::has_pair() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_PairInfo::set_has_pair() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_PairInfo::clear_has_pair() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_PairInfo::clear_pair() {
  pair_ = 0;
  clear_has_pair();
}
inline ::google::protobuf::int32 RT_MS_PairInfo::pair() const {
  return pair_;
}
inline void RT_MS_PairInfo::set_pair(::google::protobuf::int32 value) {
  set_has_pair();
  pair_ = value;
}

// optional double leafPairs = 3;
inline bool RT_MS_PairInfo::has_leafpairs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_PairInfo::set_has_leafpairs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_PairInfo::clear_has_leafpairs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_PairInfo::clear_leafpairs() {
  leafpairs_ = 0;
  clear_has_leafpairs();
}
inline double RT_MS_PairInfo::leafpairs() const {
  return leafpairs_;
}
inline void RT_MS_PairInfo::set_leafpairs(double value) {
  set_has_leafpairs();
  leafpairs_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineMLC

// optional float sourceToMLCtopDistance = 1;
inline bool RT_MS_MachineMLC::has_sourcetomlctopdistance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineMLC::set_has_sourcetomlctopdistance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineMLC::clear_has_sourcetomlctopdistance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineMLC::clear_sourcetomlctopdistance() {
  sourcetomlctopdistance_ = 0;
  clear_has_sourcetomlctopdistance();
}
inline float RT_MS_MachineMLC::sourcetomlctopdistance() const {
  return sourcetomlctopdistance_;
}
inline void RT_MS_MachineMLC::set_sourcetomlctopdistance(float value) {
  set_has_sourcetomlctopdistance();
  sourcetomlctopdistance_ = value;
}

// optional float minLeafJawOverlap = 2;
inline bool RT_MS_MachineMLC::has_minleafjawoverlap() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineMLC::set_has_minleafjawoverlap() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineMLC::clear_has_minleafjawoverlap() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineMLC::clear_minleafjawoverlap() {
  minleafjawoverlap_ = 0;
  clear_has_minleafjawoverlap();
}
inline float RT_MS_MachineMLC::minleafjawoverlap() const {
  return minleafjawoverlap_;
}
inline void RT_MS_MachineMLC::set_minleafjawoverlap(float value) {
  set_has_minleafjawoverlap();
  minleafjawoverlap_ = value;
}

// optional float minGap = 3;
inline bool RT_MS_MachineMLC::has_mingap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineMLC::set_has_mingap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineMLC::clear_has_mingap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineMLC::clear_mingap() {
  mingap_ = 0;
  clear_has_mingap();
}
inline float RT_MS_MachineMLC::mingap() const {
  return mingap_;
}
inline void RT_MS_MachineMLC::set_mingap(float value) {
  set_has_mingap();
  mingap_ = value;
}

// optional float maxLeafSpeed = 4;
inline bool RT_MS_MachineMLC::has_maxleafspeed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineMLC::set_has_maxleafspeed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineMLC::clear_has_maxleafspeed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineMLC::clear_maxleafspeed() {
  maxleafspeed_ = 0;
  clear_has_maxleafspeed();
}
inline float RT_MS_MachineMLC::maxleafspeed() const {
  return maxleafspeed_;
}
inline void RT_MS_MachineMLC::set_maxleafspeed(float value) {
  set_has_maxleafspeed();
  maxleafspeed_ = value;
}

// optional float minTipPosition = 5;
inline bool RT_MS_MachineMLC::has_mintipposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineMLC::set_has_mintipposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineMLC::clear_has_mintipposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineMLC::clear_mintipposition() {
  mintipposition_ = 0;
  clear_has_mintipposition();
}
inline float RT_MS_MachineMLC::mintipposition() const {
  return mintipposition_;
}
inline void RT_MS_MachineMLC::set_mintipposition(float value) {
  set_has_mintipposition();
  mintipposition_ = value;
}

// optional float maxTipPosition = 6;
inline bool RT_MS_MachineMLC::has_maxtipposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineMLC::set_has_maxtipposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineMLC::clear_has_maxtipposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineMLC::clear_maxtipposition() {
  maxtipposition_ = 0;
  clear_has_maxtipposition();
}
inline float RT_MS_MachineMLC::maxtipposition() const {
  return maxtipposition_;
}
inline void RT_MS_MachineMLC::set_maxtipposition(float value) {
  set_has_maxtipposition();
  maxtipposition_ = value;
}

// optional bool leafInterdigitation = 7;
inline bool RT_MS_MachineMLC::has_leafinterdigitation() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineMLC::set_has_leafinterdigitation() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineMLC::clear_has_leafinterdigitation() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineMLC::clear_leafinterdigitation() {
  leafinterdigitation_ = false;
  clear_has_leafinterdigitation();
}
inline bool RT_MS_MachineMLC::leafinterdigitation() const {
  return leafinterdigitation_;
}
inline void RT_MS_MachineMLC::set_leafinterdigitation(bool value) {
  set_has_leafinterdigitation();
  leafinterdigitation_ = value;
}

// optional float maxLeafoutofCarriageDistance = 8;
inline bool RT_MS_MachineMLC::has_maxleafoutofcarriagedistance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MachineMLC::set_has_maxleafoutofcarriagedistance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MachineMLC::clear_has_maxleafoutofcarriagedistance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MachineMLC::clear_maxleafoutofcarriagedistance() {
  maxleafoutofcarriagedistance_ = 0;
  clear_has_maxleafoutofcarriagedistance();
}
inline float RT_MS_MachineMLC::maxleafoutofcarriagedistance() const {
  return maxleafoutofcarriagedistance_;
}
inline void RT_MS_MachineMLC::set_maxleafoutofcarriagedistance(float value) {
  set_has_maxleafoutofcarriagedistance();
  maxleafoutofcarriagedistance_ = value;
}

// optional int32 mlcDirection = 9;
inline bool RT_MS_MachineMLC::has_mlcdirection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineMLC::set_has_mlcdirection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineMLC::clear_has_mlcdirection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineMLC::clear_mlcdirection() {
  mlcdirection_ = 0;
  clear_has_mlcdirection();
}
inline ::google::protobuf::int32 RT_MS_MachineMLC::mlcdirection() const {
  return mlcdirection_;
}
inline void RT_MS_MachineMLC::set_mlcdirection(::google::protobuf::int32 value) {
  set_has_mlcdirection();
  mlcdirection_ = value;
}

// optional int32 pairs = 10;
inline bool RT_MS_MachineMLC::has_pairs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MachineMLC::set_has_pairs() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MachineMLC::clear_has_pairs() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MachineMLC::clear_pairs() {
  pairs_ = 0;
  clear_has_pairs();
}
inline ::google::protobuf::int32 RT_MS_MachineMLC::pairs() const {
  return pairs_;
}
inline void RT_MS_MachineMLC::set_pairs(::google::protobuf::int32 value) {
  set_has_pairs();
  pairs_ = value;
}

// repeated .ms.proto.RT_MS_PairInfo pairInfoList = 11;
inline int RT_MS_MachineMLC::pairinfolist_size() const {
  return pairinfolist_.size();
}
inline void RT_MS_MachineMLC::clear_pairinfolist() {
  pairinfolist_.Clear();
}
inline const ::ms::proto::RT_MS_PairInfo& RT_MS_MachineMLC::pairinfolist(int index) const {
  return pairinfolist_.Get(index);
}
inline ::ms::proto::RT_MS_PairInfo* RT_MS_MachineMLC::mutable_pairinfolist(int index) {
  return pairinfolist_.Mutable(index);
}
inline ::ms::proto::RT_MS_PairInfo* RT_MS_MachineMLC::add_pairinfolist() {
  return pairinfolist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PairInfo >&
RT_MS_MachineMLC::pairinfolist() const {
  return pairinfolist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_PairInfo >*
RT_MS_MachineMLC::mutable_pairinfolist() {
  return &pairinfolist_;
}

// optional int32 maxLeafAcc_mmPerSec2 = 12;
inline bool RT_MS_MachineMLC::has_maxleafacc_mmpersec2() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MachineMLC::set_has_maxleafacc_mmpersec2() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MachineMLC::clear_has_maxleafacc_mmpersec2() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MachineMLC::clear_maxleafacc_mmpersec2() {
  maxleafacc_mmpersec2_ = 0;
  clear_has_maxleafacc_mmpersec2();
}
inline ::google::protobuf::int32 RT_MS_MachineMLC::maxleafacc_mmpersec2() const {
  return maxleafacc_mmpersec2_;
}
inline void RT_MS_MachineMLC::set_maxleafacc_mmpersec2(::google::protobuf::int32 value) {
  set_has_maxleafacc_mmpersec2();
  maxleafacc_mmpersec2_ = value;
}

// -------------------------------------------------------------------

// RT_MS_CommissionInfo

// optional int32 radiationType = 1;
inline bool RT_MS_CommissionInfo::has_radiationtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_radiationtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_CommissionInfo::clear_has_radiationtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_CommissionInfo::clear_radiationtype() {
  radiationtype_ = 0;
  clear_has_radiationtype();
}
inline ::google::protobuf::int32 RT_MS_CommissionInfo::radiationtype() const {
  return radiationtype_;
}
inline void RT_MS_CommissionInfo::set_radiationtype(::google::protobuf::int32 value) {
  set_has_radiationtype();
  radiationtype_ = value;
}

// optional float energy = 2;
inline bool RT_MS_CommissionInfo::has_energy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_energy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_CommissionInfo::clear_has_energy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_CommissionInfo::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float RT_MS_CommissionInfo::energy() const {
  return energy_;
}
inline void RT_MS_CommissionInfo::set_energy(float value) {
  set_has_energy();
  energy_ = value;
}

// optional int32 flatteningFilterType = 3;
inline bool RT_MS_CommissionInfo::has_flatteningfiltertype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_flatteningfiltertype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_CommissionInfo::clear_has_flatteningfiltertype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_CommissionInfo::clear_flatteningfiltertype() {
  flatteningfiltertype_ = 0;
  clear_has_flatteningfiltertype();
}
inline ::google::protobuf::int32 RT_MS_CommissionInfo::flatteningfiltertype() const {
  return flatteningfiltertype_;
}
inline void RT_MS_CommissionInfo::set_flatteningfiltertype(::google::protobuf::int32 value) {
  set_has_flatteningfiltertype();
  flatteningfiltertype_ = value;
}

// optional bool isConvolution = 4;
inline bool RT_MS_CommissionInfo::has_isconvolution() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isconvolution() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_CommissionInfo::clear_has_isconvolution() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_CommissionInfo::clear_isconvolution() {
  isconvolution_ = false;
  clear_has_isconvolution();
}
inline bool RT_MS_CommissionInfo::isconvolution() const {
  return isconvolution_;
}
inline void RT_MS_CommissionInfo::set_isconvolution(bool value) {
  set_has_isconvolution();
  isconvolution_ = value;
}

// optional bool isPencilBeam = 5;
inline bool RT_MS_CommissionInfo::has_ispencilbeam() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_ispencilbeam() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_CommissionInfo::clear_has_ispencilbeam() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_CommissionInfo::clear_ispencilbeam() {
  ispencilbeam_ = false;
  clear_has_ispencilbeam();
}
inline bool RT_MS_CommissionInfo::ispencilbeam() const {
  return ispencilbeam_;
}
inline void RT_MS_CommissionInfo::set_ispencilbeam(bool value) {
  set_has_ispencilbeam();
  ispencilbeam_ = value;
}

// optional bool isMonteCarlo = 6;
inline bool RT_MS_CommissionInfo::has_ismontecarlo() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_ismontecarlo() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_CommissionInfo::clear_has_ismontecarlo() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_CommissionInfo::clear_ismontecarlo() {
  ismontecarlo_ = false;
  clear_has_ismontecarlo();
}
inline bool RT_MS_CommissionInfo::ismontecarlo() const {
  return ismontecarlo_;
}
inline void RT_MS_CommissionInfo::set_ismontecarlo(bool value) {
  set_has_ismontecarlo();
  ismontecarlo_ = value;
}

// optional bool isDoseRateVarSupport = 7;
inline bool RT_MS_CommissionInfo::has_isdoseratevarsupport() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isdoseratevarsupport() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_CommissionInfo::clear_has_isdoseratevarsupport() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_CommissionInfo::clear_isdoseratevarsupport() {
  isdoseratevarsupport_ = false;
  clear_has_isdoseratevarsupport();
}
inline bool RT_MS_CommissionInfo::isdoseratevarsupport() const {
  return isdoseratevarsupport_;
}
inline void RT_MS_CommissionInfo::set_isdoseratevarsupport(bool value) {
  set_has_isdoseratevarsupport();
  isdoseratevarsupport_ = value;
}

// optional bool isPlan2D = 8;
inline bool RT_MS_CommissionInfo::has_isplan2d() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplan2d() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_CommissionInfo::clear_has_isplan2d() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_CommissionInfo::clear_isplan2d() {
  isplan2d_ = false;
  clear_has_isplan2d();
}
inline bool RT_MS_CommissionInfo::isplan2d() const {
  return isplan2d_;
}
inline void RT_MS_CommissionInfo::set_isplan2d(bool value) {
  set_has_isplan2d();
  isplan2d_ = value;
}

// optional bool isPlan3D = 9;
inline bool RT_MS_CommissionInfo::has_isplan3d() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplan3d() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_CommissionInfo::clear_has_isplan3d() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_CommissionInfo::clear_isplan3d() {
  isplan3d_ = false;
  clear_has_isplan3d();
}
inline bool RT_MS_CommissionInfo::isplan3d() const {
  return isplan3d_;
}
inline void RT_MS_CommissionInfo::set_isplan3d(bool value) {
  set_has_isplan3d();
  isplan3d_ = value;
}

// optional bool isPlanStepShoot = 10;
inline bool RT_MS_CommissionInfo::has_isplanstepshoot() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplanstepshoot() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_CommissionInfo::clear_has_isplanstepshoot() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_CommissionInfo::clear_isplanstepshoot() {
  isplanstepshoot_ = false;
  clear_has_isplanstepshoot();
}
inline bool RT_MS_CommissionInfo::isplanstepshoot() const {
  return isplanstepshoot_;
}
inline void RT_MS_CommissionInfo::set_isplanstepshoot(bool value) {
  set_has_isplanstepshoot();
  isplanstepshoot_ = value;
}

// optional bool isPlanSlidingWindow = 11;
inline bool RT_MS_CommissionInfo::has_isplanslidingwindow() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplanslidingwindow() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_CommissionInfo::clear_has_isplanslidingwindow() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_CommissionInfo::clear_isplanslidingwindow() {
  isplanslidingwindow_ = false;
  clear_has_isplanslidingwindow();
}
inline bool RT_MS_CommissionInfo::isplanslidingwindow() const {
  return isplanslidingwindow_;
}
inline void RT_MS_CommissionInfo::set_isplanslidingwindow(bool value) {
  set_has_isplanslidingwindow();
  isplanslidingwindow_ = value;
}

// optional bool isPlanSimpleArc = 12;
inline bool RT_MS_CommissionInfo::has_isplansimplearc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplansimplearc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_CommissionInfo::clear_has_isplansimplearc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_CommissionInfo::clear_isplansimplearc() {
  isplansimplearc_ = false;
  clear_has_isplansimplearc();
}
inline bool RT_MS_CommissionInfo::isplansimplearc() const {
  return isplansimplearc_;
}
inline void RT_MS_CommissionInfo::set_isplansimplearc(bool value) {
  set_has_isplansimplearc();
  isplansimplearc_ = value;
}

// optional bool isPlanConformalArc = 13;
inline bool RT_MS_CommissionInfo::has_isplanconformalarc() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplanconformalarc() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_CommissionInfo::clear_has_isplanconformalarc() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_CommissionInfo::clear_isplanconformalarc() {
  isplanconformalarc_ = false;
  clear_has_isplanconformalarc();
}
inline bool RT_MS_CommissionInfo::isplanconformalarc() const {
  return isplanconformalarc_;
}
inline void RT_MS_CommissionInfo::set_isplanconformalarc(bool value) {
  set_has_isplanconformalarc();
  isplanconformalarc_ = value;
}

// optional bool isPlanVMATArc = 14;
inline bool RT_MS_CommissionInfo::has_isplanvmatarc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplanvmatarc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_CommissionInfo::clear_has_isplanvmatarc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_CommissionInfo::clear_isplanvmatarc() {
  isplanvmatarc_ = false;
  clear_has_isplanvmatarc();
}
inline bool RT_MS_CommissionInfo::isplanvmatarc() const {
  return isplanvmatarc_;
}
inline void RT_MS_CommissionInfo::set_isplanvmatarc(bool value) {
  set_has_isplanvmatarc();
  isplanvmatarc_ = value;
}

// optional bool isPlanBurstArc = 15;
inline bool RT_MS_CommissionInfo::has_isplanburstarc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isplanburstarc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_CommissionInfo::clear_has_isplanburstarc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_CommissionInfo::clear_isplanburstarc() {
  isplanburstarc_ = false;
  clear_has_isplanburstarc();
}
inline bool RT_MS_CommissionInfo::isplanburstarc() const {
  return isplanburstarc_;
}
inline void RT_MS_CommissionInfo::set_isplanburstarc(bool value) {
  set_has_isplanburstarc();
  isplanburstarc_ = value;
}

// optional bool electornType = 16;
inline bool RT_MS_CommissionInfo::has_electorntype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_electorntype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_CommissionInfo::clear_has_electorntype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_CommissionInfo::clear_electorntype() {
  electorntype_ = false;
  clear_has_electorntype();
}
inline bool RT_MS_CommissionInfo::electorntype() const {
  return electorntype_;
}
inline void RT_MS_CommissionInfo::set_electorntype(bool value) {
  set_has_electorntype();
  electorntype_ = value;
}

// repeated .ms.proto.RT_MS_MachineBeamModeDoseRate doseRateListInfo = 17;
inline int RT_MS_CommissionInfo::doseratelistinfo_size() const {
  return doseratelistinfo_.size();
}
inline void RT_MS_CommissionInfo::clear_doseratelistinfo() {
  doseratelistinfo_.Clear();
}
inline const ::ms::proto::RT_MS_MachineBeamModeDoseRate& RT_MS_CommissionInfo::doseratelistinfo(int index) const {
  return doseratelistinfo_.Get(index);
}
inline ::ms::proto::RT_MS_MachineBeamModeDoseRate* RT_MS_CommissionInfo::mutable_doseratelistinfo(int index) {
  return doseratelistinfo_.Mutable(index);
}
inline ::ms::proto::RT_MS_MachineBeamModeDoseRate* RT_MS_CommissionInfo::add_doseratelistinfo() {
  return doseratelistinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineBeamModeDoseRate >&
RT_MS_CommissionInfo::doseratelistinfo() const {
  return doseratelistinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineBeamModeDoseRate >*
RT_MS_CommissionInfo::mutable_doseratelistinfo() {
  return &doseratelistinfo_;
}

// optional bool isCheckedHalfProfile = 18;
inline bool RT_MS_CommissionInfo::has_ischeckedhalfprofile() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_ischeckedhalfprofile() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_CommissionInfo::clear_has_ischeckedhalfprofile() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_CommissionInfo::clear_ischeckedhalfprofile() {
  ischeckedhalfprofile_ = false;
  clear_has_ischeckedhalfprofile();
}
inline bool RT_MS_CommissionInfo::ischeckedhalfprofile() const {
  return ischeckedhalfprofile_;
}
inline void RT_MS_CommissionInfo::set_ischeckedhalfprofile(bool value) {
  set_has_ischeckedhalfprofile();
  ischeckedhalfprofile_ = value;
}

// optional string commissionUID = 19;
inline bool RT_MS_CommissionInfo::has_commissionuid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_commissionuid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_CommissionInfo::clear_has_commissionuid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_CommissionInfo::clear_commissionuid() {
  if (commissionuid_ != &::google::protobuf::internal::kEmptyString) {
    commissionuid_->clear();
  }
  clear_has_commissionuid();
}
inline const ::std::string& RT_MS_CommissionInfo::commissionuid() const {
  return *commissionuid_;
}
inline void RT_MS_CommissionInfo::set_commissionuid(const ::std::string& value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_commissionuid(const char* value) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_commissionuid(const char* value, size_t size) {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  commissionuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_commissionuid() {
  set_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    commissionuid_ = new ::std::string;
  }
  return commissionuid_;
}
inline ::std::string* RT_MS_CommissionInfo::release_commissionuid() {
  clear_has_commissionuid();
  if (commissionuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commissionuid_;
    commissionuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string commissionName = 20;
inline bool RT_MS_CommissionInfo::has_commissionname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_commissionname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_CommissionInfo::clear_has_commissionname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_CommissionInfo::clear_commissionname() {
  if (commissionname_ != &::google::protobuf::internal::kEmptyString) {
    commissionname_->clear();
  }
  clear_has_commissionname();
}
inline const ::std::string& RT_MS_CommissionInfo::commissionname() const {
  return *commissionname_;
}
inline void RT_MS_CommissionInfo::set_commissionname(const ::std::string& value) {
  set_has_commissionname();
  if (commissionname_ == &::google::protobuf::internal::kEmptyString) {
    commissionname_ = new ::std::string;
  }
  commissionname_->assign(value);
}
inline void RT_MS_CommissionInfo::set_commissionname(const char* value) {
  set_has_commissionname();
  if (commissionname_ == &::google::protobuf::internal::kEmptyString) {
    commissionname_ = new ::std::string;
  }
  commissionname_->assign(value);
}
inline void RT_MS_CommissionInfo::set_commissionname(const char* value, size_t size) {
  set_has_commissionname();
  if (commissionname_ == &::google::protobuf::internal::kEmptyString) {
    commissionname_ = new ::std::string;
  }
  commissionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_commissionname() {
  set_has_commissionname();
  if (commissionname_ == &::google::protobuf::internal::kEmptyString) {
    commissionname_ = new ::std::string;
  }
  return commissionname_;
}
inline ::std::string* RT_MS_CommissionInfo::release_commissionname() {
  clear_has_commissionname();
  if (commissionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commissionname_;
    commissionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isApprove = 21;
inline bool RT_MS_CommissionInfo::has_isapprove() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_isapprove() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_CommissionInfo::clear_has_isapprove() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_CommissionInfo::clear_isapprove() {
  isapprove_ = false;
  clear_has_isapprove();
}
inline bool RT_MS_CommissionInfo::isapprove() const {
  return isapprove_;
}
inline void RT_MS_CommissionInfo::set_isapprove(bool value) {
  set_has_isapprove();
  isapprove_ = value;
}

// optional float calibrationFieldSizeX = 22;
inline bool RT_MS_CommissionInfo::has_calibrationfieldsizex() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_calibrationfieldsizex() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_CommissionInfo::clear_has_calibrationfieldsizex() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_CommissionInfo::clear_calibrationfieldsizex() {
  calibrationfieldsizex_ = 0;
  clear_has_calibrationfieldsizex();
}
inline float RT_MS_CommissionInfo::calibrationfieldsizex() const {
  return calibrationfieldsizex_;
}
inline void RT_MS_CommissionInfo::set_calibrationfieldsizex(float value) {
  set_has_calibrationfieldsizex();
  calibrationfieldsizex_ = value;
}

// optional float calibrationFieldSizeY = 23;
inline bool RT_MS_CommissionInfo::has_calibrationfieldsizey() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_calibrationfieldsizey() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_CommissionInfo::clear_has_calibrationfieldsizey() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_CommissionInfo::clear_calibrationfieldsizey() {
  calibrationfieldsizey_ = 0;
  clear_has_calibrationfieldsizey();
}
inline float RT_MS_CommissionInfo::calibrationfieldsizey() const {
  return calibrationfieldsizey_;
}
inline void RT_MS_CommissionInfo::set_calibrationfieldsizey(float value) {
  set_has_calibrationfieldsizey();
  calibrationfieldsizey_ = value;
}

// optional float calibrationDmax = 24;
inline bool RT_MS_CommissionInfo::has_calibrationdmax() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_calibrationdmax() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RT_MS_CommissionInfo::clear_has_calibrationdmax() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RT_MS_CommissionInfo::clear_calibrationdmax() {
  calibrationdmax_ = 0;
  clear_has_calibrationdmax();
}
inline float RT_MS_CommissionInfo::calibrationdmax() const {
  return calibrationdmax_;
}
inline void RT_MS_CommissionInfo::set_calibrationdmax(float value) {
  set_has_calibrationdmax();
  calibrationdmax_ = value;
}

// optional float sSD = 25;
inline bool RT_MS_CommissionInfo::has_ssd() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_ssd() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RT_MS_CommissionInfo::clear_has_ssd() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RT_MS_CommissionInfo::clear_ssd() {
  ssd_ = 0;
  clear_has_ssd();
}
inline float RT_MS_CommissionInfo::ssd() const {
  return ssd_;
}
inline void RT_MS_CommissionInfo::set_ssd(float value) {
  set_has_ssd();
  ssd_ = value;
}

// optional float lateral = 26;
inline bool RT_MS_CommissionInfo::has_lateral() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_lateral() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RT_MS_CommissionInfo::clear_has_lateral() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RT_MS_CommissionInfo::clear_lateral() {
  lateral_ = 0;
  clear_has_lateral();
}
inline float RT_MS_CommissionInfo::lateral() const {
  return lateral_;
}
inline void RT_MS_CommissionInfo::set_lateral(float value) {
  set_has_lateral();
  lateral_ = value;
}

// optional float depth = 27;
inline bool RT_MS_CommissionInfo::has_depth() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_depth() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RT_MS_CommissionInfo::clear_has_depth() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RT_MS_CommissionInfo::clear_depth() {
  depth_ = 0;
  clear_has_depth();
}
inline float RT_MS_CommissionInfo::depth() const {
  return depth_;
}
inline void RT_MS_CommissionInfo::set_depth(float value) {
  set_has_depth();
  depth_ = value;
}

// optional string date = 28;
inline bool RT_MS_CommissionInfo::has_date() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_date() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RT_MS_CommissionInfo::clear_has_date() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RT_MS_CommissionInfo::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& RT_MS_CommissionInfo::date() const {
  return *date_;
}
inline void RT_MS_CommissionInfo::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void RT_MS_CommissionInfo::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void RT_MS_CommissionInfo::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* RT_MS_CommissionInfo::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string time = 29;
inline bool RT_MS_CommissionInfo::has_time() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_time() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RT_MS_CommissionInfo::clear_has_time() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RT_MS_CommissionInfo::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& RT_MS_CommissionInfo::time() const {
  return *time_;
}
inline void RT_MS_CommissionInfo::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void RT_MS_CommissionInfo::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void RT_MS_CommissionInfo::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* RT_MS_CommissionInfo::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string who = 30;
inline bool RT_MS_CommissionInfo::has_who() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_who() {
  _has_bits_[0] |= 0x20000000u;
}
inline void RT_MS_CommissionInfo::clear_has_who() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void RT_MS_CommissionInfo::clear_who() {
  if (who_ != &::google::protobuf::internal::kEmptyString) {
    who_->clear();
  }
  clear_has_who();
}
inline const ::std::string& RT_MS_CommissionInfo::who() const {
  return *who_;
}
inline void RT_MS_CommissionInfo::set_who(const ::std::string& value) {
  set_has_who();
  if (who_ == &::google::protobuf::internal::kEmptyString) {
    who_ = new ::std::string;
  }
  who_->assign(value);
}
inline void RT_MS_CommissionInfo::set_who(const char* value) {
  set_has_who();
  if (who_ == &::google::protobuf::internal::kEmptyString) {
    who_ = new ::std::string;
  }
  who_->assign(value);
}
inline void RT_MS_CommissionInfo::set_who(const char* value, size_t size) {
  set_has_who();
  if (who_ == &::google::protobuf::internal::kEmptyString) {
    who_ = new ::std::string;
  }
  who_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_who() {
  set_has_who();
  if (who_ == &::google::protobuf::internal::kEmptyString) {
    who_ = new ::std::string;
  }
  return who_;
}
inline ::std::string* RT_MS_CommissionInfo::release_who() {
  clear_has_who();
  if (who_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = who_;
    who_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 31;
inline bool RT_MS_CommissionInfo::has_uid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_uid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void RT_MS_CommissionInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void RT_MS_CommissionInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_CommissionInfo::uid() const {
  return *uid_;
}
inline void RT_MS_CommissionInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_CommissionInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ParentUID = 32;
inline bool RT_MS_CommissionInfo::has_parentuid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_parentuid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void RT_MS_CommissionInfo::clear_has_parentuid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void RT_MS_CommissionInfo::clear_parentuid() {
  if (parentuid_ != &::google::protobuf::internal::kEmptyString) {
    parentuid_->clear();
  }
  clear_has_parentuid();
}
inline const ::std::string& RT_MS_CommissionInfo::parentuid() const {
  return *parentuid_;
}
inline void RT_MS_CommissionInfo::set_parentuid(const ::std::string& value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_parentuid(const char* value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_parentuid(const char* value, size_t size) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_parentuid() {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  return parentuid_;
}
inline ::std::string* RT_MS_CommissionInfo::release_parentuid() {
  clear_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentuid_;
    parentuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float penumbra = 33;
inline bool RT_MS_CommissionInfo::has_penumbra() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_penumbra() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RT_MS_CommissionInfo::clear_has_penumbra() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RT_MS_CommissionInfo::clear_penumbra() {
  penumbra_ = 0;
  clear_has_penumbra();
}
inline float RT_MS_CommissionInfo::penumbra() const {
  return penumbra_;
}
inline void RT_MS_CommissionInfo::set_penumbra(float value) {
  set_has_penumbra();
  penumbra_ = value;
}

// optional float blockattenuationfactor = 34;
inline bool RT_MS_CommissionInfo::has_blockattenuationfactor() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_blockattenuationfactor() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RT_MS_CommissionInfo::clear_has_blockattenuationfactor() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RT_MS_CommissionInfo::clear_blockattenuationfactor() {
  blockattenuationfactor_ = 0;
  clear_has_blockattenuationfactor();
}
inline float RT_MS_CommissionInfo::blockattenuationfactor() const {
  return blockattenuationfactor_;
}
inline void RT_MS_CommissionInfo::set_blockattenuationfactor(float value) {
  set_has_blockattenuationfactor();
  blockattenuationfactor_ = value;
}

// repeated float trayFactorList = 35;
inline int RT_MS_CommissionInfo::trayfactorlist_size() const {
  return trayfactorlist_.size();
}
inline void RT_MS_CommissionInfo::clear_trayfactorlist() {
  trayfactorlist_.Clear();
}
inline float RT_MS_CommissionInfo::trayfactorlist(int index) const {
  return trayfactorlist_.Get(index);
}
inline void RT_MS_CommissionInfo::set_trayfactorlist(int index, float value) {
  trayfactorlist_.Set(index, value);
}
inline void RT_MS_CommissionInfo::add_trayfactorlist(float value) {
  trayfactorlist_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RT_MS_CommissionInfo::trayfactorlist() const {
  return trayfactorlist_;
}
inline ::google::protobuf::RepeatedField< float >*
RT_MS_CommissionInfo::mutable_trayfactorlist() {
  return &trayfactorlist_;
}

// optional string phoCommissionUID = 36;
inline bool RT_MS_CommissionInfo::has_phocommissionuid() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_phocommissionuid() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RT_MS_CommissionInfo::clear_has_phocommissionuid() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RT_MS_CommissionInfo::clear_phocommissionuid() {
  if (phocommissionuid_ != &::google::protobuf::internal::kEmptyString) {
    phocommissionuid_->clear();
  }
  clear_has_phocommissionuid();
}
inline const ::std::string& RT_MS_CommissionInfo::phocommissionuid() const {
  return *phocommissionuid_;
}
inline void RT_MS_CommissionInfo::set_phocommissionuid(const ::std::string& value) {
  set_has_phocommissionuid();
  if (phocommissionuid_ == &::google::protobuf::internal::kEmptyString) {
    phocommissionuid_ = new ::std::string;
  }
  phocommissionuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_phocommissionuid(const char* value) {
  set_has_phocommissionuid();
  if (phocommissionuid_ == &::google::protobuf::internal::kEmptyString) {
    phocommissionuid_ = new ::std::string;
  }
  phocommissionuid_->assign(value);
}
inline void RT_MS_CommissionInfo::set_phocommissionuid(const char* value, size_t size) {
  set_has_phocommissionuid();
  if (phocommissionuid_ == &::google::protobuf::internal::kEmptyString) {
    phocommissionuid_ = new ::std::string;
  }
  phocommissionuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_CommissionInfo::mutable_phocommissionuid() {
  set_has_phocommissionuid();
  if (phocommissionuid_ == &::google::protobuf::internal::kEmptyString) {
    phocommissionuid_ = new ::std::string;
  }
  return phocommissionuid_;
}
inline ::std::string* RT_MS_CommissionInfo::release_phocommissionuid() {
  clear_has_phocommissionuid();
  if (phocommissionuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phocommissionuid_;
    phocommissionuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float norDepth = 37;
inline bool RT_MS_CommissionInfo::has_nordepth() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_nordepth() {
  _has_bits_[1] |= 0x00000010u;
}
inline void RT_MS_CommissionInfo::clear_has_nordepth() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void RT_MS_CommissionInfo::clear_nordepth() {
  nordepth_ = 0;
  clear_has_nordepth();
}
inline float RT_MS_CommissionInfo::nordepth() const {
  return nordepth_;
}
inline void RT_MS_CommissionInfo::set_nordepth(float value) {
  set_has_nordepth();
  nordepth_ = value;
}

// optional float mlcFactor = 38;
inline bool RT_MS_CommissionInfo::has_mlcfactor() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_mlcfactor() {
  _has_bits_[1] |= 0x00000020u;
}
inline void RT_MS_CommissionInfo::clear_has_mlcfactor() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void RT_MS_CommissionInfo::clear_mlcfactor() {
  mlcfactor_ = 0;
  clear_has_mlcfactor();
}
inline float RT_MS_CommissionInfo::mlcfactor() const {
  return mlcfactor_;
}
inline void RT_MS_CommissionInfo::set_mlcfactor(float value) {
  set_has_mlcfactor();
  mlcfactor_ = value;
}

// optional float xJawFactor = 39;
inline bool RT_MS_CommissionInfo::has_xjawfactor() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_xjawfactor() {
  _has_bits_[1] |= 0x00000040u;
}
inline void RT_MS_CommissionInfo::clear_has_xjawfactor() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void RT_MS_CommissionInfo::clear_xjawfactor() {
  xjawfactor_ = 0;
  clear_has_xjawfactor();
}
inline float RT_MS_CommissionInfo::xjawfactor() const {
  return xjawfactor_;
}
inline void RT_MS_CommissionInfo::set_xjawfactor(float value) {
  set_has_xjawfactor();
  xjawfactor_ = value;
}

// optional float yJawFactor = 40;
inline bool RT_MS_CommissionInfo::has_yjawfactor() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_yjawfactor() {
  _has_bits_[1] |= 0x00000080u;
}
inline void RT_MS_CommissionInfo::clear_has_yjawfactor() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void RT_MS_CommissionInfo::clear_yjawfactor() {
  yjawfactor_ = 0;
  clear_has_yjawfactor();
}
inline float RT_MS_CommissionInfo::yjawfactor() const {
  return yjawfactor_;
}
inline void RT_MS_CommissionInfo::set_yjawfactor(float value) {
  set_has_yjawfactor();
  yjawfactor_ = value;
}

// optional .ms.proto.RT_MS_PhotonMonteCarloInformation PhotonMonteCarloInfo = 41;
inline bool RT_MS_CommissionInfo::has_photonmontecarloinfo() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_photonmontecarloinfo() {
  _has_bits_[1] |= 0x00000100u;
}
inline void RT_MS_CommissionInfo::clear_has_photonmontecarloinfo() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void RT_MS_CommissionInfo::clear_photonmontecarloinfo() {
  if (photonmontecarloinfo_ != NULL) photonmontecarloinfo_->::ms::proto::RT_MS_PhotonMonteCarloInformation::Clear();
  clear_has_photonmontecarloinfo();
}
inline const ::ms::proto::RT_MS_PhotonMonteCarloInformation& RT_MS_CommissionInfo::photonmontecarloinfo() const {
  return photonmontecarloinfo_ != NULL ? *photonmontecarloinfo_ : *default_instance_->photonmontecarloinfo_;
}
inline ::ms::proto::RT_MS_PhotonMonteCarloInformation* RT_MS_CommissionInfo::mutable_photonmontecarloinfo() {
  set_has_photonmontecarloinfo();
  if (photonmontecarloinfo_ == NULL) photonmontecarloinfo_ = new ::ms::proto::RT_MS_PhotonMonteCarloInformation;
  return photonmontecarloinfo_;
}
inline ::ms::proto::RT_MS_PhotonMonteCarloInformation* RT_MS_CommissionInfo::release_photonmontecarloinfo() {
  clear_has_photonmontecarloinfo();
  ::ms::proto::RT_MS_PhotonMonteCarloInformation* temp = photonmontecarloinfo_;
  photonmontecarloinfo_ = NULL;
  return temp;
}

// optional int32 mindoserate_mupermin = 42;
inline bool RT_MS_CommissionInfo::has_mindoserate_mupermin() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void RT_MS_CommissionInfo::set_has_mindoserate_mupermin() {
  _has_bits_[1] |= 0x00000200u;
}
inline void RT_MS_CommissionInfo::clear_has_mindoserate_mupermin() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void RT_MS_CommissionInfo::clear_mindoserate_mupermin() {
  mindoserate_mupermin_ = 0;
  clear_has_mindoserate_mupermin();
}
inline ::google::protobuf::int32 RT_MS_CommissionInfo::mindoserate_mupermin() const {
  return mindoserate_mupermin_;
}
inline void RT_MS_CommissionInfo::set_mindoserate_mupermin(::google::protobuf::int32 value) {
  set_has_mindoserate_mupermin();
  mindoserate_mupermin_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineBeamModeDoseRate

// optional string doseRateUID = 1;
inline bool RT_MS_MachineBeamModeDoseRate::has_doserateuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineBeamModeDoseRate::set_has_doserateuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_has_doserateuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_doserateuid() {
  if (doserateuid_ != &::google::protobuf::internal::kEmptyString) {
    doserateuid_->clear();
  }
  clear_has_doserateuid();
}
inline const ::std::string& RT_MS_MachineBeamModeDoseRate::doserateuid() const {
  return *doserateuid_;
}
inline void RT_MS_MachineBeamModeDoseRate::set_doserateuid(const ::std::string& value) {
  set_has_doserateuid();
  if (doserateuid_ == &::google::protobuf::internal::kEmptyString) {
    doserateuid_ = new ::std::string;
  }
  doserateuid_->assign(value);
}
inline void RT_MS_MachineBeamModeDoseRate::set_doserateuid(const char* value) {
  set_has_doserateuid();
  if (doserateuid_ == &::google::protobuf::internal::kEmptyString) {
    doserateuid_ = new ::std::string;
  }
  doserateuid_->assign(value);
}
inline void RT_MS_MachineBeamModeDoseRate::set_doserateuid(const char* value, size_t size) {
  set_has_doserateuid();
  if (doserateuid_ == &::google::protobuf::internal::kEmptyString) {
    doserateuid_ = new ::std::string;
  }
  doserateuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineBeamModeDoseRate::mutable_doserateuid() {
  set_has_doserateuid();
  if (doserateuid_ == &::google::protobuf::internal::kEmptyString) {
    doserateuid_ = new ::std::string;
  }
  return doserateuid_;
}
inline ::std::string* RT_MS_MachineBeamModeDoseRate::release_doserateuid() {
  clear_has_doserateuid();
  if (doserateuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = doserateuid_;
    doserateuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 doseRate = 2;
inline bool RT_MS_MachineBeamModeDoseRate::has_doserate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineBeamModeDoseRate::set_has_doserate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_has_doserate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_doserate() {
  doserate_ = 0;
  clear_has_doserate();
}
inline ::google::protobuf::int32 RT_MS_MachineBeamModeDoseRate::doserate() const {
  return doserate_;
}
inline void RT_MS_MachineBeamModeDoseRate::set_doserate(::google::protobuf::int32 value) {
  set_has_doserate();
  doserate_ = value;
}

// optional bool isDoseRateDefault = 3;
inline bool RT_MS_MachineBeamModeDoseRate::has_isdoseratedefault() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineBeamModeDoseRate::set_has_isdoseratedefault() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_has_isdoseratedefault() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineBeamModeDoseRate::clear_isdoseratedefault() {
  isdoseratedefault_ = false;
  clear_has_isdoseratedefault();
}
inline bool RT_MS_MachineBeamModeDoseRate::isdoseratedefault() const {
  return isdoseratedefault_;
}
inline void RT_MS_MachineBeamModeDoseRate::set_isdoseratedefault(bool value) {
  set_has_isdoseratedefault();
  isdoseratedefault_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineTray

// optional string trayUID = 1;
inline bool RT_MS_MachineTray::has_trayuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineTray::set_has_trayuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineTray::clear_has_trayuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineTray::clear_trayuid() {
  if (trayuid_ != &::google::protobuf::internal::kEmptyString) {
    trayuid_->clear();
  }
  clear_has_trayuid();
}
inline const ::std::string& RT_MS_MachineTray::trayuid() const {
  return *trayuid_;
}
inline void RT_MS_MachineTray::set_trayuid(const ::std::string& value) {
  set_has_trayuid();
  if (trayuid_ == &::google::protobuf::internal::kEmptyString) {
    trayuid_ = new ::std::string;
  }
  trayuid_->assign(value);
}
inline void RT_MS_MachineTray::set_trayuid(const char* value) {
  set_has_trayuid();
  if (trayuid_ == &::google::protobuf::internal::kEmptyString) {
    trayuid_ = new ::std::string;
  }
  trayuid_->assign(value);
}
inline void RT_MS_MachineTray::set_trayuid(const char* value, size_t size) {
  set_has_trayuid();
  if (trayuid_ == &::google::protobuf::internal::kEmptyString) {
    trayuid_ = new ::std::string;
  }
  trayuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineTray::mutable_trayuid() {
  set_has_trayuid();
  if (trayuid_ == &::google::protobuf::internal::kEmptyString) {
    trayuid_ = new ::std::string;
  }
  return trayuid_;
}
inline ::std::string* RT_MS_MachineTray::release_trayuid() {
  clear_has_trayuid();
  if (trayuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trayuid_;
    trayuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trayid = 2;
inline bool RT_MS_MachineTray::has_trayid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineTray::set_has_trayid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineTray::clear_has_trayid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineTray::clear_trayid() {
  if (trayid_ != &::google::protobuf::internal::kEmptyString) {
    trayid_->clear();
  }
  clear_has_trayid();
}
inline const ::std::string& RT_MS_MachineTray::trayid() const {
  return *trayid_;
}
inline void RT_MS_MachineTray::set_trayid(const ::std::string& value) {
  set_has_trayid();
  if (trayid_ == &::google::protobuf::internal::kEmptyString) {
    trayid_ = new ::std::string;
  }
  trayid_->assign(value);
}
inline void RT_MS_MachineTray::set_trayid(const char* value) {
  set_has_trayid();
  if (trayid_ == &::google::protobuf::internal::kEmptyString) {
    trayid_ = new ::std::string;
  }
  trayid_->assign(value);
}
inline void RT_MS_MachineTray::set_trayid(const char* value, size_t size) {
  set_has_trayid();
  if (trayid_ == &::google::protobuf::internal::kEmptyString) {
    trayid_ = new ::std::string;
  }
  trayid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineTray::mutable_trayid() {
  set_has_trayid();
  if (trayid_ == &::google::protobuf::internal::kEmptyString) {
    trayid_ = new ::std::string;
  }
  return trayid_;
}
inline ::std::string* RT_MS_MachineTray::release_trayid() {
  clear_has_trayid();
  if (trayid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trayid_;
    trayid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trayCode = 3;
inline bool RT_MS_MachineTray::has_traycode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineTray::set_has_traycode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineTray::clear_has_traycode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineTray::clear_traycode() {
  if (traycode_ != &::google::protobuf::internal::kEmptyString) {
    traycode_->clear();
  }
  clear_has_traycode();
}
inline const ::std::string& RT_MS_MachineTray::traycode() const {
  return *traycode_;
}
inline void RT_MS_MachineTray::set_traycode(const ::std::string& value) {
  set_has_traycode();
  if (traycode_ == &::google::protobuf::internal::kEmptyString) {
    traycode_ = new ::std::string;
  }
  traycode_->assign(value);
}
inline void RT_MS_MachineTray::set_traycode(const char* value) {
  set_has_traycode();
  if (traycode_ == &::google::protobuf::internal::kEmptyString) {
    traycode_ = new ::std::string;
  }
  traycode_->assign(value);
}
inline void RT_MS_MachineTray::set_traycode(const char* value, size_t size) {
  set_has_traycode();
  if (traycode_ == &::google::protobuf::internal::kEmptyString) {
    traycode_ = new ::std::string;
  }
  traycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineTray::mutable_traycode() {
  set_has_traycode();
  if (traycode_ == &::google::protobuf::internal::kEmptyString) {
    traycode_ = new ::std::string;
  }
  return traycode_;
}
inline ::std::string* RT_MS_MachineTray::release_traycode() {
  clear_has_traycode();
  if (traycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = traycode_;
    traycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RT_MS_MachineAccessories

// optional bool isApertureBlock = 1;
inline bool RT_MS_MachineAccessories::has_isapertureblock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_isapertureblock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineAccessories::clear_has_isapertureblock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineAccessories::clear_isapertureblock() {
  isapertureblock_ = false;
  clear_has_isapertureblock();
}
inline bool RT_MS_MachineAccessories::isapertureblock() const {
  return isapertureblock_;
}
inline void RT_MS_MachineAccessories::set_isapertureblock(bool value) {
  set_has_isapertureblock();
  isapertureblock_ = value;
}

// optional bool isShieldBlock = 2;
inline bool RT_MS_MachineAccessories::has_isshieldblock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_isshieldblock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineAccessories::clear_has_isshieldblock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineAccessories::clear_isshieldblock() {
  isshieldblock_ = false;
  clear_has_isshieldblock();
}
inline bool RT_MS_MachineAccessories::isshieldblock() const {
  return isshieldblock_;
}
inline void RT_MS_MachineAccessories::set_isshieldblock(bool value) {
  set_has_isshieldblock();
  isshieldblock_ = value;
}

// optional float sourceToBlockTryDistance = 3;
inline bool RT_MS_MachineAccessories::has_sourcetoblocktrydistance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_sourcetoblocktrydistance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineAccessories::clear_has_sourcetoblocktrydistance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineAccessories::clear_sourcetoblocktrydistance() {
  sourcetoblocktrydistance_ = 0;
  clear_has_sourcetoblocktrydistance();
}
inline float RT_MS_MachineAccessories::sourcetoblocktrydistance() const {
  return sourcetoblocktrydistance_;
}
inline void RT_MS_MachineAccessories::set_sourcetoblocktrydistance(float value) {
  set_has_sourcetoblocktrydistance();
  sourcetoblocktrydistance_ = value;
}

// optional float height = 4;
inline bool RT_MS_MachineAccessories::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineAccessories::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineAccessories::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float RT_MS_MachineAccessories::height() const {
  return height_;
}
inline void RT_MS_MachineAccessories::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional float sourceToApplicatorLowDistance = 5;
inline bool RT_MS_MachineAccessories::has_sourcetoapplicatorlowdistance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_sourcetoapplicatorlowdistance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineAccessories::clear_has_sourcetoapplicatorlowdistance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineAccessories::clear_sourcetoapplicatorlowdistance() {
  sourcetoapplicatorlowdistance_ = 0;
  clear_has_sourcetoapplicatorlowdistance();
}
inline float RT_MS_MachineAccessories::sourcetoapplicatorlowdistance() const {
  return sourcetoapplicatorlowdistance_;
}
inline void RT_MS_MachineAccessories::set_sourcetoapplicatorlowdistance(float value) {
  set_has_sourcetoapplicatorlowdistance();
  sourcetoapplicatorlowdistance_ = value;
}

// optional float sourceToWedgeDistance = 6;
inline bool RT_MS_MachineAccessories::has_sourcetowedgedistance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_sourcetowedgedistance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineAccessories::clear_has_sourcetowedgedistance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineAccessories::clear_sourcetowedgedistance() {
  sourcetowedgedistance_ = 0;
  clear_has_sourcetowedgedistance();
}
inline float RT_MS_MachineAccessories::sourcetowedgedistance() const {
  return sourcetowedgedistance_;
}
inline void RT_MS_MachineAccessories::set_sourcetowedgedistance(float value) {
  set_has_sourcetowedgedistance();
  sourcetowedgedistance_ = value;
}

// repeated .ms.proto.RT_MS_MachineElectronApplicator electronApplicatorListInfo = 7;
inline int RT_MS_MachineAccessories::electronapplicatorlistinfo_size() const {
  return electronapplicatorlistinfo_.size();
}
inline void RT_MS_MachineAccessories::clear_electronapplicatorlistinfo() {
  electronapplicatorlistinfo_.Clear();
}
inline const ::ms::proto::RT_MS_MachineElectronApplicator& RT_MS_MachineAccessories::electronapplicatorlistinfo(int index) const {
  return electronapplicatorlistinfo_.Get(index);
}
inline ::ms::proto::RT_MS_MachineElectronApplicator* RT_MS_MachineAccessories::mutable_electronapplicatorlistinfo(int index) {
  return electronapplicatorlistinfo_.Mutable(index);
}
inline ::ms::proto::RT_MS_MachineElectronApplicator* RT_MS_MachineAccessories::add_electronapplicatorlistinfo() {
  return electronapplicatorlistinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineElectronApplicator >&
RT_MS_MachineAccessories::electronapplicatorlistinfo() const {
  return electronapplicatorlistinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineElectronApplicator >*
RT_MS_MachineAccessories::mutable_electronapplicatorlistinfo() {
  return &electronapplicatorlistinfo_;
}

// repeated .ms.proto.RT_MS_MachineWedge machineWedgeListInfo = 8;
inline int RT_MS_MachineAccessories::machinewedgelistinfo_size() const {
  return machinewedgelistinfo_.size();
}
inline void RT_MS_MachineAccessories::clear_machinewedgelistinfo() {
  machinewedgelistinfo_.Clear();
}
inline const ::ms::proto::RT_MS_MachineWedge& RT_MS_MachineAccessories::machinewedgelistinfo(int index) const {
  return machinewedgelistinfo_.Get(index);
}
inline ::ms::proto::RT_MS_MachineWedge* RT_MS_MachineAccessories::mutable_machinewedgelistinfo(int index) {
  return machinewedgelistinfo_.Mutable(index);
}
inline ::ms::proto::RT_MS_MachineWedge* RT_MS_MachineAccessories::add_machinewedgelistinfo() {
  return machinewedgelistinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineWedge >&
RT_MS_MachineAccessories::machinewedgelistinfo() const {
  return machinewedgelistinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineWedge >*
RT_MS_MachineAccessories::mutable_machinewedgelistinfo() {
  return &machinewedgelistinfo_;
}

// optional .ms.proto.RT_MS_MachineMotorizedWedge motorizedWedge = 9;
inline bool RT_MS_MachineAccessories::has_motorizedwedge() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_motorizedwedge() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineAccessories::clear_has_motorizedwedge() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineAccessories::clear_motorizedwedge() {
  if (motorizedwedge_ != NULL) motorizedwedge_->::ms::proto::RT_MS_MachineMotorizedWedge::Clear();
  clear_has_motorizedwedge();
}
inline const ::ms::proto::RT_MS_MachineMotorizedWedge& RT_MS_MachineAccessories::motorizedwedge() const {
  return motorizedwedge_ != NULL ? *motorizedwedge_ : *default_instance_->motorizedwedge_;
}
inline ::ms::proto::RT_MS_MachineMotorizedWedge* RT_MS_MachineAccessories::mutable_motorizedwedge() {
  set_has_motorizedwedge();
  if (motorizedwedge_ == NULL) motorizedwedge_ = new ::ms::proto::RT_MS_MachineMotorizedWedge;
  return motorizedwedge_;
}
inline ::ms::proto::RT_MS_MachineMotorizedWedge* RT_MS_MachineAccessories::release_motorizedwedge() {
  clear_has_motorizedwedge();
  ::ms::proto::RT_MS_MachineMotorizedWedge* temp = motorizedwedge_;
  motorizedwedge_ = NULL;
  return temp;
}

// repeated string trayUIDList = 10;
inline int RT_MS_MachineAccessories::trayuidlist_size() const {
  return trayuidlist_.size();
}
inline void RT_MS_MachineAccessories::clear_trayuidlist() {
  trayuidlist_.Clear();
}
inline const ::std::string& RT_MS_MachineAccessories::trayuidlist(int index) const {
  return trayuidlist_.Get(index);
}
inline ::std::string* RT_MS_MachineAccessories::mutable_trayuidlist(int index) {
  return trayuidlist_.Mutable(index);
}
inline void RT_MS_MachineAccessories::set_trayuidlist(int index, const ::std::string& value) {
  trayuidlist_.Mutable(index)->assign(value);
}
inline void RT_MS_MachineAccessories::set_trayuidlist(int index, const char* value) {
  trayuidlist_.Mutable(index)->assign(value);
}
inline void RT_MS_MachineAccessories::set_trayuidlist(int index, const char* value, size_t size) {
  trayuidlist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineAccessories::add_trayuidlist() {
  return trayuidlist_.Add();
}
inline void RT_MS_MachineAccessories::add_trayuidlist(const ::std::string& value) {
  trayuidlist_.Add()->assign(value);
}
inline void RT_MS_MachineAccessories::add_trayuidlist(const char* value) {
  trayuidlist_.Add()->assign(value);
}
inline void RT_MS_MachineAccessories::add_trayuidlist(const char* value, size_t size) {
  trayuidlist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RT_MS_MachineAccessories::trayuidlist() const {
  return trayuidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RT_MS_MachineAccessories::mutable_trayuidlist() {
  return &trayuidlist_;
}

// optional string UID = 11;
inline bool RT_MS_MachineAccessories::has_uid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MachineAccessories::set_has_uid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MachineAccessories::clear_has_uid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MachineAccessories::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_MachineAccessories::uid() const {
  return *uid_;
}
inline void RT_MS_MachineAccessories::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MachineAccessories::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MachineAccessories::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineAccessories::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_MachineAccessories::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string trayACCcode = 12;
inline int RT_MS_MachineAccessories::trayacccode_size() const {
  return trayacccode_.size();
}
inline void RT_MS_MachineAccessories::clear_trayacccode() {
  trayacccode_.Clear();
}
inline const ::std::string& RT_MS_MachineAccessories::trayacccode(int index) const {
  return trayacccode_.Get(index);
}
inline ::std::string* RT_MS_MachineAccessories::mutable_trayacccode(int index) {
  return trayacccode_.Mutable(index);
}
inline void RT_MS_MachineAccessories::set_trayacccode(int index, const ::std::string& value) {
  trayacccode_.Mutable(index)->assign(value);
}
inline void RT_MS_MachineAccessories::set_trayacccode(int index, const char* value) {
  trayacccode_.Mutable(index)->assign(value);
}
inline void RT_MS_MachineAccessories::set_trayacccode(int index, const char* value, size_t size) {
  trayacccode_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineAccessories::add_trayacccode() {
  return trayacccode_.Add();
}
inline void RT_MS_MachineAccessories::add_trayacccode(const ::std::string& value) {
  trayacccode_.Add()->assign(value);
}
inline void RT_MS_MachineAccessories::add_trayacccode(const char* value) {
  trayacccode_.Add()->assign(value);
}
inline void RT_MS_MachineAccessories::add_trayacccode(const char* value, size_t size) {
  trayacccode_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RT_MS_MachineAccessories::trayacccode() const {
  return trayacccode_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RT_MS_MachineAccessories::mutable_trayacccode() {
  return &trayacccode_;
}

// repeated .ms.proto.RT_MS_MachineTray trayList = 13;
inline int RT_MS_MachineAccessories::traylist_size() const {
  return traylist_.size();
}
inline void RT_MS_MachineAccessories::clear_traylist() {
  traylist_.Clear();
}
inline const ::ms::proto::RT_MS_MachineTray& RT_MS_MachineAccessories::traylist(int index) const {
  return traylist_.Get(index);
}
inline ::ms::proto::RT_MS_MachineTray* RT_MS_MachineAccessories::mutable_traylist(int index) {
  return traylist_.Mutable(index);
}
inline ::ms::proto::RT_MS_MachineTray* RT_MS_MachineAccessories::add_traylist() {
  return traylist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineTray >&
RT_MS_MachineAccessories::traylist() const {
  return traylist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MachineTray >*
RT_MS_MachineAccessories::mutable_traylist() {
  return &traylist_;
}

// -------------------------------------------------------------------

// RT_MS_MachineElectronApplicator

// optional string applicatorACCID = 1;
inline bool RT_MS_MachineElectronApplicator::has_applicatoraccid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineElectronApplicator::set_has_applicatoraccid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineElectronApplicator::clear_has_applicatoraccid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineElectronApplicator::clear_applicatoraccid() {
  if (applicatoraccid_ != &::google::protobuf::internal::kEmptyString) {
    applicatoraccid_->clear();
  }
  clear_has_applicatoraccid();
}
inline const ::std::string& RT_MS_MachineElectronApplicator::applicatoraccid() const {
  return *applicatoraccid_;
}
inline void RT_MS_MachineElectronApplicator::set_applicatoraccid(const ::std::string& value) {
  set_has_applicatoraccid();
  if (applicatoraccid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoraccid_ = new ::std::string;
  }
  applicatoraccid_->assign(value);
}
inline void RT_MS_MachineElectronApplicator::set_applicatoraccid(const char* value) {
  set_has_applicatoraccid();
  if (applicatoraccid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoraccid_ = new ::std::string;
  }
  applicatoraccid_->assign(value);
}
inline void RT_MS_MachineElectronApplicator::set_applicatoraccid(const char* value, size_t size) {
  set_has_applicatoraccid();
  if (applicatoraccid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoraccid_ = new ::std::string;
  }
  applicatoraccid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineElectronApplicator::mutable_applicatoraccid() {
  set_has_applicatoraccid();
  if (applicatoraccid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoraccid_ = new ::std::string;
  }
  return applicatoraccid_;
}
inline ::std::string* RT_MS_MachineElectronApplicator::release_applicatoraccid() {
  clear_has_applicatoraccid();
  if (applicatoraccid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = applicatoraccid_;
    applicatoraccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float sizeX = 2;
inline bool RT_MS_MachineElectronApplicator::has_sizex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineElectronApplicator::set_has_sizex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineElectronApplicator::clear_has_sizex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineElectronApplicator::clear_sizex() {
  sizex_ = 0;
  clear_has_sizex();
}
inline float RT_MS_MachineElectronApplicator::sizex() const {
  return sizex_;
}
inline void RT_MS_MachineElectronApplicator::set_sizex(float value) {
  set_has_sizex();
  sizex_ = value;
}

// optional float sizeY = 3;
inline bool RT_MS_MachineElectronApplicator::has_sizey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineElectronApplicator::set_has_sizey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineElectronApplicator::clear_has_sizey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineElectronApplicator::clear_sizey() {
  sizey_ = 0;
  clear_has_sizey();
}
inline float RT_MS_MachineElectronApplicator::sizey() const {
  return sizey_;
}
inline void RT_MS_MachineElectronApplicator::set_sizey(float value) {
  set_has_sizey();
  sizey_ = value;
}

// optional string applicatorUID = 4;
inline bool RT_MS_MachineElectronApplicator::has_applicatoruid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineElectronApplicator::set_has_applicatoruid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineElectronApplicator::clear_has_applicatoruid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineElectronApplicator::clear_applicatoruid() {
  if (applicatoruid_ != &::google::protobuf::internal::kEmptyString) {
    applicatoruid_->clear();
  }
  clear_has_applicatoruid();
}
inline const ::std::string& RT_MS_MachineElectronApplicator::applicatoruid() const {
  return *applicatoruid_;
}
inline void RT_MS_MachineElectronApplicator::set_applicatoruid(const ::std::string& value) {
  set_has_applicatoruid();
  if (applicatoruid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoruid_ = new ::std::string;
  }
  applicatoruid_->assign(value);
}
inline void RT_MS_MachineElectronApplicator::set_applicatoruid(const char* value) {
  set_has_applicatoruid();
  if (applicatoruid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoruid_ = new ::std::string;
  }
  applicatoruid_->assign(value);
}
inline void RT_MS_MachineElectronApplicator::set_applicatoruid(const char* value, size_t size) {
  set_has_applicatoruid();
  if (applicatoruid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoruid_ = new ::std::string;
  }
  applicatoruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineElectronApplicator::mutable_applicatoruid() {
  set_has_applicatoruid();
  if (applicatoruid_ == &::google::protobuf::internal::kEmptyString) {
    applicatoruid_ = new ::std::string;
  }
  return applicatoruid_;
}
inline ::std::string* RT_MS_MachineElectronApplicator::release_applicatoruid() {
  clear_has_applicatoruid();
  if (applicatoruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = applicatoruid_;
    applicatoruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RT_MS_MachineMotorizedWedge

// optional int32 motorizedWedgeOrientation = 1;
inline bool RT_MS_MachineMotorizedWedge::has_motorizedwedgeorientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineMotorizedWedge::set_has_motorizedwedgeorientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineMotorizedWedge::clear_has_motorizedwedgeorientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineMotorizedWedge::clear_motorizedwedgeorientation() {
  motorizedwedgeorientation_ = 0;
  clear_has_motorizedwedgeorientation();
}
inline ::google::protobuf::int32 RT_MS_MachineMotorizedWedge::motorizedwedgeorientation() const {
  return motorizedwedgeorientation_;
}
inline void RT_MS_MachineMotorizedWedge::set_motorizedwedgeorientation(::google::protobuf::int32 value) {
  set_has_motorizedwedgeorientation();
  motorizedwedgeorientation_ = value;
}

// optional float motorizedFieldSizeLimitX = 2;
inline bool RT_MS_MachineMotorizedWedge::has_motorizedfieldsizelimitx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineMotorizedWedge::set_has_motorizedfieldsizelimitx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineMotorizedWedge::clear_has_motorizedfieldsizelimitx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineMotorizedWedge::clear_motorizedfieldsizelimitx() {
  motorizedfieldsizelimitx_ = 0;
  clear_has_motorizedfieldsizelimitx();
}
inline float RT_MS_MachineMotorizedWedge::motorizedfieldsizelimitx() const {
  return motorizedfieldsizelimitx_;
}
inline void RT_MS_MachineMotorizedWedge::set_motorizedfieldsizelimitx(float value) {
  set_has_motorizedfieldsizelimitx();
  motorizedfieldsizelimitx_ = value;
}

// optional float motorizedfieldSizeLimitY = 3;
inline bool RT_MS_MachineMotorizedWedge::has_motorizedfieldsizelimity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineMotorizedWedge::set_has_motorizedfieldsizelimity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineMotorizedWedge::clear_has_motorizedfieldsizelimity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineMotorizedWedge::clear_motorizedfieldsizelimity() {
  motorizedfieldsizelimity_ = 0;
  clear_has_motorizedfieldsizelimity();
}
inline float RT_MS_MachineMotorizedWedge::motorizedfieldsizelimity() const {
  return motorizedfieldsizelimity_;
}
inline void RT_MS_MachineMotorizedWedge::set_motorizedfieldsizelimity(float value) {
  set_has_motorizedfieldsizelimity();
  motorizedfieldsizelimity_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MachineWedge

// optional string wedgeACCID = 1;
inline bool RT_MS_MachineWedge::has_wedgeaccid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MachineWedge::set_has_wedgeaccid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MachineWedge::clear_has_wedgeaccid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MachineWedge::clear_wedgeaccid() {
  if (wedgeaccid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeaccid_->clear();
  }
  clear_has_wedgeaccid();
}
inline const ::std::string& RT_MS_MachineWedge::wedgeaccid() const {
  return *wedgeaccid_;
}
inline void RT_MS_MachineWedge::set_wedgeaccid(const ::std::string& value) {
  set_has_wedgeaccid();
  if (wedgeaccid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeaccid_ = new ::std::string;
  }
  wedgeaccid_->assign(value);
}
inline void RT_MS_MachineWedge::set_wedgeaccid(const char* value) {
  set_has_wedgeaccid();
  if (wedgeaccid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeaccid_ = new ::std::string;
  }
  wedgeaccid_->assign(value);
}
inline void RT_MS_MachineWedge::set_wedgeaccid(const char* value, size_t size) {
  set_has_wedgeaccid();
  if (wedgeaccid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeaccid_ = new ::std::string;
  }
  wedgeaccid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineWedge::mutable_wedgeaccid() {
  set_has_wedgeaccid();
  if (wedgeaccid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeaccid_ = new ::std::string;
  }
  return wedgeaccid_;
}
inline ::std::string* RT_MS_MachineWedge::release_wedgeaccid() {
  clear_has_wedgeaccid();
  if (wedgeaccid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeaccid_;
    wedgeaccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float degree = 2;
inline bool RT_MS_MachineWedge::has_degree() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MachineWedge::set_has_degree() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MachineWedge::clear_has_degree() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MachineWedge::clear_degree() {
  degree_ = 0;
  clear_has_degree();
}
inline float RT_MS_MachineWedge::degree() const {
  return degree_;
}
inline void RT_MS_MachineWedge::set_degree(float value) {
  set_has_degree();
  degree_ = value;
}

// optional float leftMin = 3;
inline bool RT_MS_MachineWedge::has_leftmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MachineWedge::set_has_leftmin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MachineWedge::clear_has_leftmin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MachineWedge::clear_leftmin() {
  leftmin_ = 0;
  clear_has_leftmin();
}
inline float RT_MS_MachineWedge::leftmin() const {
  return leftmin_;
}
inline void RT_MS_MachineWedge::set_leftmin(float value) {
  set_has_leftmin();
  leftmin_ = value;
}

// optional float leftMax = 4;
inline bool RT_MS_MachineWedge::has_leftmax() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MachineWedge::set_has_leftmax() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MachineWedge::clear_has_leftmax() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MachineWedge::clear_leftmax() {
  leftmax_ = 0;
  clear_has_leftmax();
}
inline float RT_MS_MachineWedge::leftmax() const {
  return leftmax_;
}
inline void RT_MS_MachineWedge::set_leftmax(float value) {
  set_has_leftmax();
  leftmax_ = value;
}

// optional float rightMin = 5;
inline bool RT_MS_MachineWedge::has_rightmin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MachineWedge::set_has_rightmin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MachineWedge::clear_has_rightmin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MachineWedge::clear_rightmin() {
  rightmin_ = 0;
  clear_has_rightmin();
}
inline float RT_MS_MachineWedge::rightmin() const {
  return rightmin_;
}
inline void RT_MS_MachineWedge::set_rightmin(float value) {
  set_has_rightmin();
  rightmin_ = value;
}

// optional float rightMax = 6;
inline bool RT_MS_MachineWedge::has_rightmax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MachineWedge::set_has_rightmax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MachineWedge::clear_has_rightmax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MachineWedge::clear_rightmax() {
  rightmax_ = 0;
  clear_has_rightmax();
}
inline float RT_MS_MachineWedge::rightmax() const {
  return rightmax_;
}
inline void RT_MS_MachineWedge::set_rightmax(float value) {
  set_has_rightmax();
  rightmax_ = value;
}

// optional float topMin = 7;
inline bool RT_MS_MachineWedge::has_topmin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MachineWedge::set_has_topmin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MachineWedge::clear_has_topmin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MachineWedge::clear_topmin() {
  topmin_ = 0;
  clear_has_topmin();
}
inline float RT_MS_MachineWedge::topmin() const {
  return topmin_;
}
inline void RT_MS_MachineWedge::set_topmin(float value) {
  set_has_topmin();
  topmin_ = value;
}

// optional float topMax = 8;
inline bool RT_MS_MachineWedge::has_topmax() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MachineWedge::set_has_topmax() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MachineWedge::clear_has_topmax() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MachineWedge::clear_topmax() {
  topmax_ = 0;
  clear_has_topmax();
}
inline float RT_MS_MachineWedge::topmax() const {
  return topmax_;
}
inline void RT_MS_MachineWedge::set_topmax(float value) {
  set_has_topmax();
  topmax_ = value;
}

// optional float bottomMin = 9;
inline bool RT_MS_MachineWedge::has_bottommin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MachineWedge::set_has_bottommin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MachineWedge::clear_has_bottommin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MachineWedge::clear_bottommin() {
  bottommin_ = 0;
  clear_has_bottommin();
}
inline float RT_MS_MachineWedge::bottommin() const {
  return bottommin_;
}
inline void RT_MS_MachineWedge::set_bottommin(float value) {
  set_has_bottommin();
  bottommin_ = value;
}

// optional float bottomMax = 10;
inline bool RT_MS_MachineWedge::has_bottommax() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MachineWedge::set_has_bottommax() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MachineWedge::clear_has_bottommax() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MachineWedge::clear_bottommax() {
  bottommax_ = 0;
  clear_has_bottommax();
}
inline float RT_MS_MachineWedge::bottommax() const {
  return bottommax_;
}
inline void RT_MS_MachineWedge::set_bottommax(float value) {
  set_has_bottommax();
  bottommax_ = value;
}

// optional string orientationType = 11;
inline bool RT_MS_MachineWedge::has_orientationtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MachineWedge::set_has_orientationtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MachineWedge::clear_has_orientationtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MachineWedge::clear_orientationtype() {
  if (orientationtype_ != &::google::protobuf::internal::kEmptyString) {
    orientationtype_->clear();
  }
  clear_has_orientationtype();
}
inline const ::std::string& RT_MS_MachineWedge::orientationtype() const {
  return *orientationtype_;
}
inline void RT_MS_MachineWedge::set_orientationtype(const ::std::string& value) {
  set_has_orientationtype();
  if (orientationtype_ == &::google::protobuf::internal::kEmptyString) {
    orientationtype_ = new ::std::string;
  }
  orientationtype_->assign(value);
}
inline void RT_MS_MachineWedge::set_orientationtype(const char* value) {
  set_has_orientationtype();
  if (orientationtype_ == &::google::protobuf::internal::kEmptyString) {
    orientationtype_ = new ::std::string;
  }
  orientationtype_->assign(value);
}
inline void RT_MS_MachineWedge::set_orientationtype(const char* value, size_t size) {
  set_has_orientationtype();
  if (orientationtype_ == &::google::protobuf::internal::kEmptyString) {
    orientationtype_ = new ::std::string;
  }
  orientationtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineWedge::mutable_orientationtype() {
  set_has_orientationtype();
  if (orientationtype_ == &::google::protobuf::internal::kEmptyString) {
    orientationtype_ = new ::std::string;
  }
  return orientationtype_;
}
inline ::std::string* RT_MS_MachineWedge::release_orientationtype() {
  clear_has_orientationtype();
  if (orientationtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orientationtype_;
    orientationtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeUID = 12;
inline bool RT_MS_MachineWedge::has_wedgeuid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MachineWedge::set_has_wedgeuid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MachineWedge::clear_has_wedgeuid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MachineWedge::clear_wedgeuid() {
  if (wedgeuid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeuid_->clear();
  }
  clear_has_wedgeuid();
}
inline const ::std::string& RT_MS_MachineWedge::wedgeuid() const {
  return *wedgeuid_;
}
inline void RT_MS_MachineWedge::set_wedgeuid(const ::std::string& value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_MachineWedge::set_wedgeuid(const char* value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_MachineWedge::set_wedgeuid(const char* value, size_t size) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineWedge::mutable_wedgeuid() {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  return wedgeuid_;
}
inline ::std::string* RT_MS_MachineWedge::release_wedgeuid() {
  clear_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeuid_;
    wedgeuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 wedgeType = 13;
inline bool RT_MS_MachineWedge::has_wedgetype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_MachineWedge::set_has_wedgetype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_MachineWedge::clear_has_wedgetype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_MachineWedge::clear_wedgetype() {
  wedgetype_ = 0;
  clear_has_wedgetype();
}
inline ::google::protobuf::int32 RT_MS_MachineWedge::wedgetype() const {
  return wedgetype_;
}
inline void RT_MS_MachineWedge::set_wedgetype(::google::protobuf::int32 value) {
  set_has_wedgetype();
  wedgetype_ = value;
}

// optional string accCode = 14;
inline bool RT_MS_MachineWedge::has_acccode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_MachineWedge::set_has_acccode() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_MachineWedge::clear_has_acccode() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_MachineWedge::clear_acccode() {
  if (acccode_ != &::google::protobuf::internal::kEmptyString) {
    acccode_->clear();
  }
  clear_has_acccode();
}
inline const ::std::string& RT_MS_MachineWedge::acccode() const {
  return *acccode_;
}
inline void RT_MS_MachineWedge::set_acccode(const ::std::string& value) {
  set_has_acccode();
  if (acccode_ == &::google::protobuf::internal::kEmptyString) {
    acccode_ = new ::std::string;
  }
  acccode_->assign(value);
}
inline void RT_MS_MachineWedge::set_acccode(const char* value) {
  set_has_acccode();
  if (acccode_ == &::google::protobuf::internal::kEmptyString) {
    acccode_ = new ::std::string;
  }
  acccode_->assign(value);
}
inline void RT_MS_MachineWedge::set_acccode(const char* value, size_t size) {
  set_has_acccode();
  if (acccode_ == &::google::protobuf::internal::kEmptyString) {
    acccode_ = new ::std::string;
  }
  acccode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MachineWedge::mutable_acccode() {
  set_has_acccode();
  if (acccode_ == &::google::protobuf::internal::kEmptyString) {
    acccode_ = new ::std::string;
  }
  return acccode_;
}
inline ::std::string* RT_MS_MachineWedge::release_acccode() {
  clear_has_acccode();
  if (acccode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acccode_;
    acccode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace ms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5fms_5fmachinesettingconfig_2eproto__INCLUDED
