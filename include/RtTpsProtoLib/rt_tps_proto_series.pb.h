// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_tps_proto_series.proto

#ifndef PROTOBUF_rt_5ftps_5fproto_5fseries_2eproto__INCLUDED
#define PROTOBUF_rt_5ftps_5fproto_5fseries_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "rt_tps_proto_series_table.pb.h"
#include "rt_tps_proto_poi.pb.h"
// @@protoc_insertion_point(includes)

namespace tps {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5ftps_5fproto_5fseries_2eproto();
void protobuf_AssignDesc_rt_5ftps_5fproto_5fseries_2eproto();
void protobuf_ShutdownFile_rt_5ftps_5fproto_5fseries_2eproto();

class RtTpsProtoImagetransformation;
class RtTpsProtoSeries;
class RtTpsProtoRepeatedSeries;

// ===================================================================

class RtTpsProtoImagetransformation : public ::google::protobuf::Message {
 public:
  RtTpsProtoImagetransformation();
  virtual ~RtTpsProtoImagetransformation();
  
  RtTpsProtoImagetransformation(const RtTpsProtoImagetransformation& from);
  
  inline RtTpsProtoImagetransformation& operator=(const RtTpsProtoImagetransformation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoImagetransformation& default_instance();
  
  void Swap(RtTpsProtoImagetransformation* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoImagetransformation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoImagetransformation& from);
  void MergeFrom(const RtTpsProtoImagetransformation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string originalseriesuid = 2;
  inline bool has_originalseriesuid() const;
  inline void clear_originalseriesuid();
  static const int kOriginalseriesuidFieldNumber = 2;
  inline const ::std::string& originalseriesuid() const;
  inline void set_originalseriesuid(const ::std::string& value);
  inline void set_originalseriesuid(const char* value);
  inline void set_originalseriesuid(const char* value, size_t size);
  inline ::std::string* mutable_originalseriesuid();
  inline ::std::string* release_originalseriesuid();
  
  // optional string transfomationseriesuid = 3;
  inline bool has_transfomationseriesuid() const;
  inline void clear_transfomationseriesuid();
  static const int kTransfomationseriesuidFieldNumber = 3;
  inline const ::std::string& transfomationseriesuid() const;
  inline void set_transfomationseriesuid(const ::std::string& value);
  inline void set_transfomationseriesuid(const char* value);
  inline void set_transfomationseriesuid(const char* value, size_t size);
  inline ::std::string* mutable_transfomationseriesuid();
  inline ::std::string* release_transfomationseriesuid();
  
  // optional string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // optional int32 RegistrationMethod = 5;
  inline bool has_registrationmethod() const;
  inline void clear_registrationmethod();
  static const int kRegistrationMethodFieldNumber = 5;
  inline ::google::protobuf::int32 registrationmethod() const;
  inline void set_registrationmethod(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoImagetransformation)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_originalseriesuid();
  inline void clear_has_originalseriesuid();
  inline void set_has_transfomationseriesuid();
  inline void clear_has_transfomationseriesuid();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_registrationmethod();
  inline void clear_has_registrationmethod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* originalseriesuid_;
  ::std::string* transfomationseriesuid_;
  ::std::string* description_;
  ::google::protobuf::int32 registrationmethod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fseries_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoImagetransformation* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoSeries : public ::google::protobuf::Message {
 public:
  RtTpsProtoSeries();
  virtual ~RtTpsProtoSeries();
  
  RtTpsProtoSeries(const RtTpsProtoSeries& from);
  
  inline RtTpsProtoSeries& operator=(const RtTpsProtoSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoSeries& default_instance();
  
  void Swap(RtTpsProtoSeries* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoSeries& from);
  void MergeFrom(const RtTpsProtoSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string seriesUID = 1;
  inline bool has_seriesuid() const;
  inline void clear_seriesuid();
  static const int kSeriesUIDFieldNumber = 1;
  inline const ::std::string& seriesuid() const;
  inline void set_seriesuid(const ::std::string& value);
  inline void set_seriesuid(const char* value);
  inline void set_seriesuid(const char* value, size_t size);
  inline ::std::string* mutable_seriesuid();
  inline ::std::string* release_seriesuid();
  
  // optional float windowingCenter = 2;
  inline bool has_windowingcenter() const;
  inline void clear_windowingcenter();
  static const int kWindowingCenterFieldNumber = 2;
  inline float windowingcenter() const;
  inline void set_windowingcenter(float value);
  
  // optional float windowingWidth = 3;
  inline bool has_windowingwidth() const;
  inline void clear_windowingwidth();
  static const int kWindowingWidthFieldNumber = 3;
  inline float windowingwidth() const;
  inline void set_windowingwidth(float value);
  
  // optional int32 currentSlice = 4;
  inline bool has_currentslice() const;
  inline void clear_currentslice();
  static const int kCurrentSliceFieldNumber = 4;
  inline ::google::protobuf::int32 currentslice() const;
  inline void set_currentslice(::google::protobuf::int32 value);
  
  // optional int32 sliceCount = 5;
  inline bool has_slicecount() const;
  inline void clear_slicecount();
  static const int kSliceCountFieldNumber = 5;
  inline ::google::protobuf::int32 slicecount() const;
  inline void set_slicecount(::google::protobuf::int32 value);
  
  // optional int32 xDimension = 6;
  inline bool has_xdimension() const;
  inline void clear_xdimension();
  static const int kXDimensionFieldNumber = 6;
  inline ::google::protobuf::int32 xdimension() const;
  inline void set_xdimension(::google::protobuf::int32 value);
  
  // optional int32 yDimension = 7;
  inline bool has_ydimension() const;
  inline void clear_ydimension();
  static const int kYDimensionFieldNumber = 7;
  inline ::google::protobuf::int32 ydimension() const;
  inline void set_ydimension(::google::protobuf::int32 value);
  
  // optional float xPixelSpacing = 8;
  inline bool has_xpixelspacing() const;
  inline void clear_xpixelspacing();
  static const int kXPixelSpacingFieldNumber = 8;
  inline float xpixelspacing() const;
  inline void set_xpixelspacing(float value);
  
  // optional float yPixelSpacing = 9;
  inline bool has_ypixelspacing() const;
  inline void clear_ypixelspacing();
  static const int kYPixelSpacingFieldNumber = 9;
  inline float ypixelspacing() const;
  inline void set_ypixelspacing(float value);
  
  // optional float sliceSpacing = 10;
  inline bool has_slicespacing() const;
  inline void clear_slicespacing();
  static const int kSliceSpacingFieldNumber = 10;
  inline float slicespacing() const;
  inline void set_slicespacing(float value);
  
  // optional string modality = 11;
  inline bool has_modality() const;
  inline void clear_modality();
  static const int kModalityFieldNumber = 11;
  inline const ::std::string& modality() const;
  inline void set_modality(const ::std::string& value);
  inline void set_modality(const char* value);
  inline void set_modality(const char* value, size_t size);
  inline ::std::string* mutable_modality();
  inline ::std::string* release_modality();
  
  // optional int32 bitAllocated = 12;
  inline bool has_bitallocated() const;
  inline void clear_bitallocated();
  static const int kBitAllocatedFieldNumber = 12;
  inline ::google::protobuf::int32 bitallocated() const;
  inline void set_bitallocated(::google::protobuf::int32 value);
  
  // optional string seriestime = 13;
  inline bool has_seriestime() const;
  inline void clear_seriestime();
  static const int kSeriestimeFieldNumber = 13;
  inline const ::std::string& seriestime() const;
  inline void set_seriestime(const ::std::string& value);
  inline void set_seriestime(const char* value);
  inline void set_seriestime(const char* value, size_t size);
  inline ::std::string* mutable_seriestime();
  inline ::std::string* release_seriestime();
  
  // optional string seriesdate = 14;
  inline bool has_seriesdate() const;
  inline void clear_seriesdate();
  static const int kSeriesdateFieldNumber = 14;
  inline const ::std::string& seriesdate() const;
  inline void set_seriesdate(const ::std::string& value);
  inline void set_seriesdate(const char* value);
  inline void set_seriesdate(const char* value, size_t size);
  inline ::std::string* mutable_seriesdate();
  inline ::std::string* release_seriesdate();
  
  // optional string seriesdescription = 15;
  inline bool has_seriesdescription() const;
  inline void clear_seriesdescription();
  static const int kSeriesdescriptionFieldNumber = 15;
  inline const ::std::string& seriesdescription() const;
  inline void set_seriesdescription(const ::std::string& value);
  inline void set_seriesdescription(const char* value);
  inline void set_seriesdescription(const char* value, size_t size);
  inline ::std::string* mutable_seriesdescription();
  inline ::std::string* release_seriesdescription();
  
  // optional string patientPosition = 16;
  inline bool has_patientposition() const;
  inline void clear_patientposition();
  static const int kPatientPositionFieldNumber = 16;
  inline const ::std::string& patientposition() const;
  inline void set_patientposition(const ::std::string& value);
  inline void set_patientposition(const char* value);
  inline void set_patientposition(const char* value, size_t size);
  inline ::std::string* mutable_patientposition();
  inline ::std::string* release_patientposition();
  
  // optional bytes imageSliceBuffer = 17;
  inline bool has_imageslicebuffer() const;
  inline void clear_imageslicebuffer();
  static const int kImageSliceBufferFieldNumber = 17;
  inline const ::std::string& imageslicebuffer() const;
  inline void set_imageslicebuffer(const ::std::string& value);
  inline void set_imageslicebuffer(const char* value);
  inline void set_imageslicebuffer(const void* value, size_t size);
  inline ::std::string* mutable_imageslicebuffer();
  inline ::std::string* release_imageslicebuffer();
  
  // optional bool isqa = 18;
  inline bool has_isqa() const;
  inline void clear_isqa();
  static const int kIsqaFieldNumber = 18;
  inline bool isqa() const;
  inline void set_isqa(bool value);
  
  // optional int32 seriesNumber = 19;
  inline bool has_seriesnumber() const;
  inline void clear_seriesnumber();
  static const int kSeriesNumberFieldNumber = 19;
  inline ::google::protobuf::int32 seriesnumber() const;
  inline void set_seriesnumber(::google::protobuf::int32 value);
  
  // optional string frameOfReference = 20;
  inline bool has_frameofreference() const;
  inline void clear_frameofreference();
  static const int kFrameOfReferenceFieldNumber = 20;
  inline const ::std::string& frameofreference() const;
  inline void set_frameofreference(const ::std::string& value);
  inline void set_frameofreference(const char* value);
  inline void set_frameofreference(const char* value, size_t size);
  inline ::std::string* mutable_frameofreference();
  inline ::std::string* release_frameofreference();
  
  // optional string manufacturerModelName = 21;
  inline bool has_manufacturermodelname() const;
  inline void clear_manufacturermodelname();
  static const int kManufacturerModelNameFieldNumber = 21;
  inline const ::std::string& manufacturermodelname() const;
  inline void set_manufacturermodelname(const ::std::string& value);
  inline void set_manufacturermodelname(const char* value);
  inline void set_manufacturermodelname(const char* value, size_t size);
  inline ::std::string* mutable_manufacturermodelname();
  inline ::std::string* release_manufacturermodelname();
  
  // optional string acquisitionDateTime = 22;
  inline bool has_acquisitiondatetime() const;
  inline void clear_acquisitiondatetime();
  static const int kAcquisitionDateTimeFieldNumber = 22;
  inline const ::std::string& acquisitiondatetime() const;
  inline void set_acquisitiondatetime(const ::std::string& value);
  inline void set_acquisitiondatetime(const char* value);
  inline void set_acquisitiondatetime(const char* value, size_t size);
  inline ::std::string* mutable_acquisitiondatetime();
  inline ::std::string* release_acquisitiondatetime();
  
  // optional string courseUID = 23;
  inline bool has_courseuid() const;
  inline void clear_courseuid();
  static const int kCourseUIDFieldNumber = 23;
  inline const ::std::string& courseuid() const;
  inline void set_courseuid(const ::std::string& value);
  inline void set_courseuid(const char* value);
  inline void set_courseuid(const char* value, size_t size);
  inline ::std::string* mutable_courseuid();
  inline ::std::string* release_courseuid();
  
  // optional float startX = 24;
  inline bool has_startx() const;
  inline void clear_startx();
  static const int kStartXFieldNumber = 24;
  inline float startx() const;
  inline void set_startx(float value);
  
  // optional float startY = 25;
  inline bool has_starty() const;
  inline void clear_starty();
  static const int kStartYFieldNumber = 25;
  inline float starty() const;
  inline void set_starty(float value);
  
  // optional float startZ = 26;
  inline bool has_startz() const;
  inline void clear_startz();
  static const int kStartZFieldNumber = 26;
  inline float startz() const;
  inline void set_startz(float value);
  
  // optional float sizeX = 27;
  inline bool has_sizex() const;
  inline void clear_sizex();
  static const int kSizeXFieldNumber = 27;
  inline float sizex() const;
  inline void set_sizex(float value);
  
  // optional float sizeY = 28;
  inline bool has_sizey() const;
  inline void clear_sizey();
  static const int kSizeYFieldNumber = 28;
  inline float sizey() const;
  inline void set_sizey(float value);
  
  // optional float sizeZ = 29;
  inline bool has_sizez() const;
  inline void clear_sizez();
  static const int kSizeZFieldNumber = 29;
  inline float sizez() const;
  inline void set_sizez(float value);
  
  // repeated .tps.proto.RtTpsProtoImagetransformation imagetransformationList = 30;
  inline int imagetransformationlist_size() const;
  inline void clear_imagetransformationlist();
  static const int kImagetransformationListFieldNumber = 30;
  inline const ::tps::proto::RtTpsProtoImagetransformation& imagetransformationlist(int index) const;
  inline ::tps::proto::RtTpsProtoImagetransformation* mutable_imagetransformationlist(int index);
  inline ::tps::proto::RtTpsProtoImagetransformation* add_imagetransformationlist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoImagetransformation >&
      imagetransformationlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoImagetransformation >*
      mutable_imagetransformationlist();
  
  // repeated float orientationX = 31;
  inline int orientationx_size() const;
  inline void clear_orientationx();
  static const int kOrientationXFieldNumber = 31;
  inline float orientationx(int index) const;
  inline void set_orientationx(int index, float value);
  inline void add_orientationx(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      orientationx() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_orientationx();
  
  // repeated float orientationY = 32;
  inline int orientationy_size() const;
  inline void clear_orientationy();
  static const int kOrientationYFieldNumber = 32;
  inline float orientationy(int index) const;
  inline void set_orientationy(int index, float value);
  inline void add_orientationy(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      orientationy() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_orientationy();
  
  // repeated float orientationZ = 33;
  inline int orientationz_size() const;
  inline void clear_orientationz();
  static const int kOrientationZFieldNumber = 33;
  inline float orientationz(int index) const;
  inline void set_orientationz(int index, float value);
  inline void add_orientationz(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      orientationz() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_orientationz();
  
  // optional string groupUid = 34;
  inline bool has_groupuid() const;
  inline void clear_groupuid();
  static const int kGroupUidFieldNumber = 34;
  inline const ::std::string& groupuid() const;
  inline void set_groupuid(const ::std::string& value);
  inline void set_groupuid(const char* value);
  inline void set_groupuid(const char* value, size_t size);
  inline ::std::string* mutable_groupuid();
  inline ::std::string* release_groupuid();
  
  // optional string slicethickness = 35;
  inline bool has_slicethickness() const;
  inline void clear_slicethickness();
  static const int kSlicethicknessFieldNumber = 35;
  inline const ::std::string& slicethickness() const;
  inline void set_slicethickness(const ::std::string& value);
  inline void set_slicethickness(const char* value);
  inline void set_slicethickness(const char* value, size_t size);
  inline ::std::string* mutable_slicethickness();
  inline ::std::string* release_slicethickness();
  
  // optional string studyid = 36;
  inline bool has_studyid() const;
  inline void clear_studyid();
  static const int kStudyidFieldNumber = 36;
  inline const ::std::string& studyid() const;
  inline void set_studyid(const ::std::string& value);
  inline void set_studyid(const char* value);
  inline void set_studyid(const char* value, size_t size);
  inline ::std::string* mutable_studyid();
  inline ::std::string* release_studyid();
  
  // optional string studydescription = 37;
  inline bool has_studydescription() const;
  inline void clear_studydescription();
  static const int kStudydescriptionFieldNumber = 37;
  inline const ::std::string& studydescription() const;
  inline void set_studydescription(const ::std::string& value);
  inline void set_studydescription(const char* value);
  inline void set_studydescription(const char* value, size_t size);
  inline ::std::string* mutable_studydescription();
  inline ::std::string* release_studydescription();
  
  // optional string patientname = 38;
  inline bool has_patientname() const;
  inline void clear_patientname();
  static const int kPatientnameFieldNumber = 38;
  inline const ::std::string& patientname() const;
  inline void set_patientname(const ::std::string& value);
  inline void set_patientname(const char* value);
  inline void set_patientname(const char* value, size_t size);
  inline ::std::string* mutable_patientname();
  inline ::std::string* release_patientname();
  
  // optional string patientid = 39;
  inline bool has_patientid() const;
  inline void clear_patientid();
  static const int kPatientidFieldNumber = 39;
  inline const ::std::string& patientid() const;
  inline void set_patientid(const ::std::string& value);
  inline void set_patientid(const char* value);
  inline void set_patientid(const char* value, size_t size);
  inline ::std::string* mutable_patientid();
  inline ::std::string* release_patientid();
  
  // optional string patientbirthdate = 40;
  inline bool has_patientbirthdate() const;
  inline void clear_patientbirthdate();
  static const int kPatientbirthdateFieldNumber = 40;
  inline const ::std::string& patientbirthdate() const;
  inline void set_patientbirthdate(const ::std::string& value);
  inline void set_patientbirthdate(const char* value);
  inline void set_patientbirthdate(const char* value, size_t size);
  inline ::std::string* mutable_patientbirthdate();
  inline ::std::string* release_patientbirthdate();
  
  // optional string patientage = 41;
  inline bool has_patientage() const;
  inline void clear_patientage();
  static const int kPatientageFieldNumber = 41;
  inline const ::std::string& patientage() const;
  inline void set_patientage(const ::std::string& value);
  inline void set_patientage(const char* value);
  inline void set_patientage(const char* value, size_t size);
  inline ::std::string* mutable_patientage();
  inline ::std::string* release_patientage();
  
  // optional string patientsex = 42;
  inline bool has_patientsex() const;
  inline void clear_patientsex();
  static const int kPatientsexFieldNumber = 42;
  inline const ::std::string& patientsex() const;
  inline void set_patientsex(const ::std::string& value);
  inline void set_patientsex(const char* value);
  inline void set_patientsex(const char* value, size_t size);
  inline ::std::string* mutable_patientsex();
  inline ::std::string* release_patientsex();
  
  // optional string institutionname = 43;
  inline bool has_institutionname() const;
  inline void clear_institutionname();
  static const int kInstitutionnameFieldNumber = 43;
  inline const ::std::string& institutionname() const;
  inline void set_institutionname(const ::std::string& value);
  inline void set_institutionname(const char* value);
  inline void set_institutionname(const char* value, size_t size);
  inline ::std::string* mutable_institutionname();
  inline ::std::string* release_institutionname();
  
  // optional string manufacturer = 44;
  inline bool has_manufacturer() const;
  inline void clear_manufacturer();
  static const int kManufacturerFieldNumber = 44;
  inline const ::std::string& manufacturer() const;
  inline void set_manufacturer(const ::std::string& value);
  inline void set_manufacturer(const char* value);
  inline void set_manufacturer(const char* value, size_t size);
  inline ::std::string* mutable_manufacturer();
  inline ::std::string* release_manufacturer();
  
  // optional string ct2densityUID = 45;
  inline bool has_ct2densityuid() const;
  inline void clear_ct2densityuid();
  static const int kCt2DensityUIDFieldNumber = 45;
  inline const ::std::string& ct2densityuid() const;
  inline void set_ct2densityuid(const ::std::string& value);
  inline void set_ct2densityuid(const char* value);
  inline void set_ct2densityuid(const char* value, size_t size);
  inline ::std::string* mutable_ct2densityuid();
  inline ::std::string* release_ct2densityuid();
  
  // optional .tps.proto.RtTpsProtoSeriesTable seriesTable = 46;
  inline bool has_seriestable() const;
  inline void clear_seriestable();
  static const int kSeriesTableFieldNumber = 46;
  inline const ::tps::proto::RtTpsProtoSeriesTable& seriestable() const;
  inline ::tps::proto::RtTpsProtoSeriesTable* mutable_seriestable();
  inline ::tps::proto::RtTpsProtoSeriesTable* release_seriestable();
  
  // optional string patientuid = 47;
  inline bool has_patientuid() const;
  inline void clear_patientuid();
  static const int kPatientuidFieldNumber = 47;
  inline const ::std::string& patientuid() const;
  inline void set_patientuid(const ::std::string& value);
  inline void set_patientuid(const char* value);
  inline void set_patientuid(const char* value, size_t size);
  inline ::std::string* mutable_patientuid();
  inline ::std::string* release_patientuid();
  
  // optional string seriesname = 48;
  inline bool has_seriesname() const;
  inline void clear_seriesname();
  static const int kSeriesnameFieldNumber = 48;
  inline const ::std::string& seriesname() const;
  inline void set_seriesname(const ::std::string& value);
  inline void set_seriesname(const char* value);
  inline void set_seriesname(const char* value, size_t size);
  inline ::std::string* mutable_seriesname();
  inline ::std::string* release_seriesname();
  
  // optional bool isphantom = 49;
  inline bool has_isphantom() const;
  inline void clear_isphantom();
  static const int kIsphantomFieldNumber = 49;
  inline bool isphantom() const;
  inline void set_isphantom(bool value);
  
  // repeated .tps.proto.RtTpsProtoPoi poiList = 50;
  inline int poilist_size() const;
  inline void clear_poilist();
  static const int kPoiListFieldNumber = 50;
  inline const ::tps::proto::RtTpsProtoPoi& poilist(int index) const;
  inline ::tps::proto::RtTpsProtoPoi* mutable_poilist(int index);
  inline ::tps::proto::RtTpsProtoPoi* add_poilist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >&
      poilist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >*
      mutable_poilist();
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoSeries)
 private:
  inline void set_has_seriesuid();
  inline void clear_has_seriesuid();
  inline void set_has_windowingcenter();
  inline void clear_has_windowingcenter();
  inline void set_has_windowingwidth();
  inline void clear_has_windowingwidth();
  inline void set_has_currentslice();
  inline void clear_has_currentslice();
  inline void set_has_slicecount();
  inline void clear_has_slicecount();
  inline void set_has_xdimension();
  inline void clear_has_xdimension();
  inline void set_has_ydimension();
  inline void clear_has_ydimension();
  inline void set_has_xpixelspacing();
  inline void clear_has_xpixelspacing();
  inline void set_has_ypixelspacing();
  inline void clear_has_ypixelspacing();
  inline void set_has_slicespacing();
  inline void clear_has_slicespacing();
  inline void set_has_modality();
  inline void clear_has_modality();
  inline void set_has_bitallocated();
  inline void clear_has_bitallocated();
  inline void set_has_seriestime();
  inline void clear_has_seriestime();
  inline void set_has_seriesdate();
  inline void clear_has_seriesdate();
  inline void set_has_seriesdescription();
  inline void clear_has_seriesdescription();
  inline void set_has_patientposition();
  inline void clear_has_patientposition();
  inline void set_has_imageslicebuffer();
  inline void clear_has_imageslicebuffer();
  inline void set_has_isqa();
  inline void clear_has_isqa();
  inline void set_has_seriesnumber();
  inline void clear_has_seriesnumber();
  inline void set_has_frameofreference();
  inline void clear_has_frameofreference();
  inline void set_has_manufacturermodelname();
  inline void clear_has_manufacturermodelname();
  inline void set_has_acquisitiondatetime();
  inline void clear_has_acquisitiondatetime();
  inline void set_has_courseuid();
  inline void clear_has_courseuid();
  inline void set_has_startx();
  inline void clear_has_startx();
  inline void set_has_starty();
  inline void clear_has_starty();
  inline void set_has_startz();
  inline void clear_has_startz();
  inline void set_has_sizex();
  inline void clear_has_sizex();
  inline void set_has_sizey();
  inline void clear_has_sizey();
  inline void set_has_sizez();
  inline void clear_has_sizez();
  inline void set_has_groupuid();
  inline void clear_has_groupuid();
  inline void set_has_slicethickness();
  inline void clear_has_slicethickness();
  inline void set_has_studyid();
  inline void clear_has_studyid();
  inline void set_has_studydescription();
  inline void clear_has_studydescription();
  inline void set_has_patientname();
  inline void clear_has_patientname();
  inline void set_has_patientid();
  inline void clear_has_patientid();
  inline void set_has_patientbirthdate();
  inline void clear_has_patientbirthdate();
  inline void set_has_patientage();
  inline void clear_has_patientage();
  inline void set_has_patientsex();
  inline void clear_has_patientsex();
  inline void set_has_institutionname();
  inline void clear_has_institutionname();
  inline void set_has_manufacturer();
  inline void clear_has_manufacturer();
  inline void set_has_ct2densityuid();
  inline void clear_has_ct2densityuid();
  inline void set_has_seriestable();
  inline void clear_has_seriestable();
  inline void set_has_patientuid();
  inline void clear_has_patientuid();
  inline void set_has_seriesname();
  inline void clear_has_seriesname();
  inline void set_has_isphantom();
  inline void clear_has_isphantom();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* seriesuid_;
  float windowingcenter_;
  float windowingwidth_;
  ::google::protobuf::int32 currentslice_;
  ::google::protobuf::int32 slicecount_;
  ::google::protobuf::int32 xdimension_;
  ::google::protobuf::int32 ydimension_;
  float xpixelspacing_;
  float ypixelspacing_;
  ::std::string* modality_;
  float slicespacing_;
  ::google::protobuf::int32 bitallocated_;
  ::std::string* seriestime_;
  ::std::string* seriesdate_;
  ::std::string* seriesdescription_;
  ::std::string* patientposition_;
  ::std::string* imageslicebuffer_;
  ::std::string* frameofreference_;
  ::std::string* manufacturermodelname_;
  ::google::protobuf::int32 seriesnumber_;
  float startx_;
  ::std::string* acquisitiondatetime_;
  ::std::string* courseuid_;
  float starty_;
  float startz_;
  float sizex_;
  float sizey_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoImagetransformation > imagetransformationlist_;
  ::google::protobuf::RepeatedField< float > orientationx_;
  ::google::protobuf::RepeatedField< float > orientationy_;
  float sizez_;
  bool isqa_;
  bool isphantom_;
  ::google::protobuf::RepeatedField< float > orientationz_;
  ::std::string* groupuid_;
  ::std::string* slicethickness_;
  ::std::string* studyid_;
  ::std::string* studydescription_;
  ::std::string* patientname_;
  ::std::string* patientid_;
  ::std::string* patientbirthdate_;
  ::std::string* patientage_;
  ::std::string* patientsex_;
  ::std::string* institutionname_;
  ::std::string* manufacturer_;
  ::std::string* ct2densityuid_;
  ::tps::proto::RtTpsProtoSeriesTable* seriestable_;
  ::std::string* patientuid_;
  ::std::string* seriesname_;
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi > poilist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(50 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fseries_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoSeries* default_instance_;
};
// -------------------------------------------------------------------

class RtTpsProtoRepeatedSeries : public ::google::protobuf::Message {
 public:
  RtTpsProtoRepeatedSeries();
  virtual ~RtTpsProtoRepeatedSeries();
  
  RtTpsProtoRepeatedSeries(const RtTpsProtoRepeatedSeries& from);
  
  inline RtTpsProtoRepeatedSeries& operator=(const RtTpsProtoRepeatedSeries& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtTpsProtoRepeatedSeries& default_instance();
  
  void Swap(RtTpsProtoRepeatedSeries* other);
  
  // implements Message ----------------------------------------------
  
  RtTpsProtoRepeatedSeries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtTpsProtoRepeatedSeries& from);
  void MergeFrom(const RtTpsProtoRepeatedSeries& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .tps.proto.RtTpsProtoSeries seriesList = 1;
  inline int serieslist_size() const;
  inline void clear_serieslist();
  static const int kSeriesListFieldNumber = 1;
  inline const ::tps::proto::RtTpsProtoSeries& serieslist(int index) const;
  inline ::tps::proto::RtTpsProtoSeries* mutable_serieslist(int index);
  inline ::tps::proto::RtTpsProtoSeries* add_serieslist();
  inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSeries >&
      serieslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSeries >*
      mutable_serieslist();
  
  // @@protoc_insertion_point(class_scope:tps.proto.RtTpsProtoRepeatedSeries)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSeries > serieslist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_AssignDesc_rt_5ftps_5fproto_5fseries_2eproto();
  friend void protobuf_ShutdownFile_rt_5ftps_5fproto_5fseries_2eproto();
  
  void InitAsDefaultInstance();
  static RtTpsProtoRepeatedSeries* default_instance_;
};
// ===================================================================


// ===================================================================

// RtTpsProtoImagetransformation

// optional string uid = 1;
inline bool RtTpsProtoImagetransformation::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoImagetransformation::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoImagetransformation::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoImagetransformation::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RtTpsProtoImagetransformation::uid() const {
  return *uid_;
}
inline void RtTpsProtoImagetransformation::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoImagetransformation::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RtTpsProtoImagetransformation::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string originalseriesuid = 2;
inline bool RtTpsProtoImagetransformation::has_originalseriesuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoImagetransformation::set_has_originalseriesuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoImagetransformation::clear_has_originalseriesuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoImagetransformation::clear_originalseriesuid() {
  if (originalseriesuid_ != &::google::protobuf::internal::kEmptyString) {
    originalseriesuid_->clear();
  }
  clear_has_originalseriesuid();
}
inline const ::std::string& RtTpsProtoImagetransformation::originalseriesuid() const {
  return *originalseriesuid_;
}
inline void RtTpsProtoImagetransformation::set_originalseriesuid(const ::std::string& value) {
  set_has_originalseriesuid();
  if (originalseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    originalseriesuid_ = new ::std::string;
  }
  originalseriesuid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_originalseriesuid(const char* value) {
  set_has_originalseriesuid();
  if (originalseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    originalseriesuid_ = new ::std::string;
  }
  originalseriesuid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_originalseriesuid(const char* value, size_t size) {
  set_has_originalseriesuid();
  if (originalseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    originalseriesuid_ = new ::std::string;
  }
  originalseriesuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoImagetransformation::mutable_originalseriesuid() {
  set_has_originalseriesuid();
  if (originalseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    originalseriesuid_ = new ::std::string;
  }
  return originalseriesuid_;
}
inline ::std::string* RtTpsProtoImagetransformation::release_originalseriesuid() {
  clear_has_originalseriesuid();
  if (originalseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originalseriesuid_;
    originalseriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string transfomationseriesuid = 3;
inline bool RtTpsProtoImagetransformation::has_transfomationseriesuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoImagetransformation::set_has_transfomationseriesuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoImagetransformation::clear_has_transfomationseriesuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoImagetransformation::clear_transfomationseriesuid() {
  if (transfomationseriesuid_ != &::google::protobuf::internal::kEmptyString) {
    transfomationseriesuid_->clear();
  }
  clear_has_transfomationseriesuid();
}
inline const ::std::string& RtTpsProtoImagetransformation::transfomationseriesuid() const {
  return *transfomationseriesuid_;
}
inline void RtTpsProtoImagetransformation::set_transfomationseriesuid(const ::std::string& value) {
  set_has_transfomationseriesuid();
  if (transfomationseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    transfomationseriesuid_ = new ::std::string;
  }
  transfomationseriesuid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_transfomationseriesuid(const char* value) {
  set_has_transfomationseriesuid();
  if (transfomationseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    transfomationseriesuid_ = new ::std::string;
  }
  transfomationseriesuid_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_transfomationseriesuid(const char* value, size_t size) {
  set_has_transfomationseriesuid();
  if (transfomationseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    transfomationseriesuid_ = new ::std::string;
  }
  transfomationseriesuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoImagetransformation::mutable_transfomationseriesuid() {
  set_has_transfomationseriesuid();
  if (transfomationseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    transfomationseriesuid_ = new ::std::string;
  }
  return transfomationseriesuid_;
}
inline ::std::string* RtTpsProtoImagetransformation::release_transfomationseriesuid() {
  clear_has_transfomationseriesuid();
  if (transfomationseriesuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transfomationseriesuid_;
    transfomationseriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string description = 4;
inline bool RtTpsProtoImagetransformation::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoImagetransformation::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoImagetransformation::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoImagetransformation::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& RtTpsProtoImagetransformation::description() const {
  return *description_;
}
inline void RtTpsProtoImagetransformation::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void RtTpsProtoImagetransformation::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoImagetransformation::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* RtTpsProtoImagetransformation::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 RegistrationMethod = 5;
inline bool RtTpsProtoImagetransformation::has_registrationmethod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtTpsProtoImagetransformation::set_has_registrationmethod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtTpsProtoImagetransformation::clear_has_registrationmethod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtTpsProtoImagetransformation::clear_registrationmethod() {
  registrationmethod_ = 0;
  clear_has_registrationmethod();
}
inline ::google::protobuf::int32 RtTpsProtoImagetransformation::registrationmethod() const {
  return registrationmethod_;
}
inline void RtTpsProtoImagetransformation::set_registrationmethod(::google::protobuf::int32 value) {
  set_has_registrationmethod();
  registrationmethod_ = value;
}

// -------------------------------------------------------------------

// RtTpsProtoSeries

// required string seriesUID = 1;
inline bool RtTpsProtoSeries::has_seriesuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriesuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtTpsProtoSeries::clear_has_seriesuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtTpsProtoSeries::clear_seriesuid() {
  if (seriesuid_ != &::google::protobuf::internal::kEmptyString) {
    seriesuid_->clear();
  }
  clear_has_seriesuid();
}
inline const ::std::string& RtTpsProtoSeries::seriesuid() const {
  return *seriesuid_;
}
inline void RtTpsProtoSeries::set_seriesuid(const ::std::string& value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesuid(const char* value) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesuid(const char* value, size_t size) {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  seriesuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_seriesuid() {
  set_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    seriesuid_ = new ::std::string;
  }
  return seriesuid_;
}
inline ::std::string* RtTpsProtoSeries::release_seriesuid() {
  clear_has_seriesuid();
  if (seriesuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesuid_;
    seriesuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float windowingCenter = 2;
inline bool RtTpsProtoSeries::has_windowingcenter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtTpsProtoSeries::set_has_windowingcenter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtTpsProtoSeries::clear_has_windowingcenter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtTpsProtoSeries::clear_windowingcenter() {
  windowingcenter_ = 0;
  clear_has_windowingcenter();
}
inline float RtTpsProtoSeries::windowingcenter() const {
  return windowingcenter_;
}
inline void RtTpsProtoSeries::set_windowingcenter(float value) {
  set_has_windowingcenter();
  windowingcenter_ = value;
}

// optional float windowingWidth = 3;
inline bool RtTpsProtoSeries::has_windowingwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtTpsProtoSeries::set_has_windowingwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtTpsProtoSeries::clear_has_windowingwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtTpsProtoSeries::clear_windowingwidth() {
  windowingwidth_ = 0;
  clear_has_windowingwidth();
}
inline float RtTpsProtoSeries::windowingwidth() const {
  return windowingwidth_;
}
inline void RtTpsProtoSeries::set_windowingwidth(float value) {
  set_has_windowingwidth();
  windowingwidth_ = value;
}

// optional int32 currentSlice = 4;
inline bool RtTpsProtoSeries::has_currentslice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtTpsProtoSeries::set_has_currentslice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtTpsProtoSeries::clear_has_currentslice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtTpsProtoSeries::clear_currentslice() {
  currentslice_ = 0;
  clear_has_currentslice();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::currentslice() const {
  return currentslice_;
}
inline void RtTpsProtoSeries::set_currentslice(::google::protobuf::int32 value) {
  set_has_currentslice();
  currentslice_ = value;
}

// optional int32 sliceCount = 5;
inline bool RtTpsProtoSeries::has_slicecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RtTpsProtoSeries::set_has_slicecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RtTpsProtoSeries::clear_has_slicecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RtTpsProtoSeries::clear_slicecount() {
  slicecount_ = 0;
  clear_has_slicecount();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::slicecount() const {
  return slicecount_;
}
inline void RtTpsProtoSeries::set_slicecount(::google::protobuf::int32 value) {
  set_has_slicecount();
  slicecount_ = value;
}

// optional int32 xDimension = 6;
inline bool RtTpsProtoSeries::has_xdimension() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RtTpsProtoSeries::set_has_xdimension() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RtTpsProtoSeries::clear_has_xdimension() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RtTpsProtoSeries::clear_xdimension() {
  xdimension_ = 0;
  clear_has_xdimension();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::xdimension() const {
  return xdimension_;
}
inline void RtTpsProtoSeries::set_xdimension(::google::protobuf::int32 value) {
  set_has_xdimension();
  xdimension_ = value;
}

// optional int32 yDimension = 7;
inline bool RtTpsProtoSeries::has_ydimension() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RtTpsProtoSeries::set_has_ydimension() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RtTpsProtoSeries::clear_has_ydimension() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RtTpsProtoSeries::clear_ydimension() {
  ydimension_ = 0;
  clear_has_ydimension();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::ydimension() const {
  return ydimension_;
}
inline void RtTpsProtoSeries::set_ydimension(::google::protobuf::int32 value) {
  set_has_ydimension();
  ydimension_ = value;
}

// optional float xPixelSpacing = 8;
inline bool RtTpsProtoSeries::has_xpixelspacing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RtTpsProtoSeries::set_has_xpixelspacing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RtTpsProtoSeries::clear_has_xpixelspacing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RtTpsProtoSeries::clear_xpixelspacing() {
  xpixelspacing_ = 0;
  clear_has_xpixelspacing();
}
inline float RtTpsProtoSeries::xpixelspacing() const {
  return xpixelspacing_;
}
inline void RtTpsProtoSeries::set_xpixelspacing(float value) {
  set_has_xpixelspacing();
  xpixelspacing_ = value;
}

// optional float yPixelSpacing = 9;
inline bool RtTpsProtoSeries::has_ypixelspacing() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RtTpsProtoSeries::set_has_ypixelspacing() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RtTpsProtoSeries::clear_has_ypixelspacing() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RtTpsProtoSeries::clear_ypixelspacing() {
  ypixelspacing_ = 0;
  clear_has_ypixelspacing();
}
inline float RtTpsProtoSeries::ypixelspacing() const {
  return ypixelspacing_;
}
inline void RtTpsProtoSeries::set_ypixelspacing(float value) {
  set_has_ypixelspacing();
  ypixelspacing_ = value;
}

// optional float sliceSpacing = 10;
inline bool RtTpsProtoSeries::has_slicespacing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RtTpsProtoSeries::set_has_slicespacing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RtTpsProtoSeries::clear_has_slicespacing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RtTpsProtoSeries::clear_slicespacing() {
  slicespacing_ = 0;
  clear_has_slicespacing();
}
inline float RtTpsProtoSeries::slicespacing() const {
  return slicespacing_;
}
inline void RtTpsProtoSeries::set_slicespacing(float value) {
  set_has_slicespacing();
  slicespacing_ = value;
}

// optional string modality = 11;
inline bool RtTpsProtoSeries::has_modality() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RtTpsProtoSeries::set_has_modality() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RtTpsProtoSeries::clear_has_modality() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RtTpsProtoSeries::clear_modality() {
  if (modality_ != &::google::protobuf::internal::kEmptyString) {
    modality_->clear();
  }
  clear_has_modality();
}
inline const ::std::string& RtTpsProtoSeries::modality() const {
  return *modality_;
}
inline void RtTpsProtoSeries::set_modality(const ::std::string& value) {
  set_has_modality();
  if (modality_ == &::google::protobuf::internal::kEmptyString) {
    modality_ = new ::std::string;
  }
  modality_->assign(value);
}
inline void RtTpsProtoSeries::set_modality(const char* value) {
  set_has_modality();
  if (modality_ == &::google::protobuf::internal::kEmptyString) {
    modality_ = new ::std::string;
  }
  modality_->assign(value);
}
inline void RtTpsProtoSeries::set_modality(const char* value, size_t size) {
  set_has_modality();
  if (modality_ == &::google::protobuf::internal::kEmptyString) {
    modality_ = new ::std::string;
  }
  modality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_modality() {
  set_has_modality();
  if (modality_ == &::google::protobuf::internal::kEmptyString) {
    modality_ = new ::std::string;
  }
  return modality_;
}
inline ::std::string* RtTpsProtoSeries::release_modality() {
  clear_has_modality();
  if (modality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modality_;
    modality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 bitAllocated = 12;
inline bool RtTpsProtoSeries::has_bitallocated() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RtTpsProtoSeries::set_has_bitallocated() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RtTpsProtoSeries::clear_has_bitallocated() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RtTpsProtoSeries::clear_bitallocated() {
  bitallocated_ = 0;
  clear_has_bitallocated();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::bitallocated() const {
  return bitallocated_;
}
inline void RtTpsProtoSeries::set_bitallocated(::google::protobuf::int32 value) {
  set_has_bitallocated();
  bitallocated_ = value;
}

// optional string seriestime = 13;
inline bool RtTpsProtoSeries::has_seriestime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriestime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RtTpsProtoSeries::clear_has_seriestime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RtTpsProtoSeries::clear_seriestime() {
  if (seriestime_ != &::google::protobuf::internal::kEmptyString) {
    seriestime_->clear();
  }
  clear_has_seriestime();
}
inline const ::std::string& RtTpsProtoSeries::seriestime() const {
  return *seriestime_;
}
inline void RtTpsProtoSeries::set_seriestime(const ::std::string& value) {
  set_has_seriestime();
  if (seriestime_ == &::google::protobuf::internal::kEmptyString) {
    seriestime_ = new ::std::string;
  }
  seriestime_->assign(value);
}
inline void RtTpsProtoSeries::set_seriestime(const char* value) {
  set_has_seriestime();
  if (seriestime_ == &::google::protobuf::internal::kEmptyString) {
    seriestime_ = new ::std::string;
  }
  seriestime_->assign(value);
}
inline void RtTpsProtoSeries::set_seriestime(const char* value, size_t size) {
  set_has_seriestime();
  if (seriestime_ == &::google::protobuf::internal::kEmptyString) {
    seriestime_ = new ::std::string;
  }
  seriestime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_seriestime() {
  set_has_seriestime();
  if (seriestime_ == &::google::protobuf::internal::kEmptyString) {
    seriestime_ = new ::std::string;
  }
  return seriestime_;
}
inline ::std::string* RtTpsProtoSeries::release_seriestime() {
  clear_has_seriestime();
  if (seriestime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriestime_;
    seriestime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string seriesdate = 14;
inline bool RtTpsProtoSeries::has_seriesdate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriesdate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RtTpsProtoSeries::clear_has_seriesdate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RtTpsProtoSeries::clear_seriesdate() {
  if (seriesdate_ != &::google::protobuf::internal::kEmptyString) {
    seriesdate_->clear();
  }
  clear_has_seriesdate();
}
inline const ::std::string& RtTpsProtoSeries::seriesdate() const {
  return *seriesdate_;
}
inline void RtTpsProtoSeries::set_seriesdate(const ::std::string& value) {
  set_has_seriesdate();
  if (seriesdate_ == &::google::protobuf::internal::kEmptyString) {
    seriesdate_ = new ::std::string;
  }
  seriesdate_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesdate(const char* value) {
  set_has_seriesdate();
  if (seriesdate_ == &::google::protobuf::internal::kEmptyString) {
    seriesdate_ = new ::std::string;
  }
  seriesdate_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesdate(const char* value, size_t size) {
  set_has_seriesdate();
  if (seriesdate_ == &::google::protobuf::internal::kEmptyString) {
    seriesdate_ = new ::std::string;
  }
  seriesdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_seriesdate() {
  set_has_seriesdate();
  if (seriesdate_ == &::google::protobuf::internal::kEmptyString) {
    seriesdate_ = new ::std::string;
  }
  return seriesdate_;
}
inline ::std::string* RtTpsProtoSeries::release_seriesdate() {
  clear_has_seriesdate();
  if (seriesdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesdate_;
    seriesdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string seriesdescription = 15;
inline bool RtTpsProtoSeries::has_seriesdescription() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriesdescription() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RtTpsProtoSeries::clear_has_seriesdescription() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RtTpsProtoSeries::clear_seriesdescription() {
  if (seriesdescription_ != &::google::protobuf::internal::kEmptyString) {
    seriesdescription_->clear();
  }
  clear_has_seriesdescription();
}
inline const ::std::string& RtTpsProtoSeries::seriesdescription() const {
  return *seriesdescription_;
}
inline void RtTpsProtoSeries::set_seriesdescription(const ::std::string& value) {
  set_has_seriesdescription();
  if (seriesdescription_ == &::google::protobuf::internal::kEmptyString) {
    seriesdescription_ = new ::std::string;
  }
  seriesdescription_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesdescription(const char* value) {
  set_has_seriesdescription();
  if (seriesdescription_ == &::google::protobuf::internal::kEmptyString) {
    seriesdescription_ = new ::std::string;
  }
  seriesdescription_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesdescription(const char* value, size_t size) {
  set_has_seriesdescription();
  if (seriesdescription_ == &::google::protobuf::internal::kEmptyString) {
    seriesdescription_ = new ::std::string;
  }
  seriesdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_seriesdescription() {
  set_has_seriesdescription();
  if (seriesdescription_ == &::google::protobuf::internal::kEmptyString) {
    seriesdescription_ = new ::std::string;
  }
  return seriesdescription_;
}
inline ::std::string* RtTpsProtoSeries::release_seriesdescription() {
  clear_has_seriesdescription();
  if (seriesdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesdescription_;
    seriesdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientPosition = 16;
inline bool RtTpsProtoSeries::has_patientposition() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientposition() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RtTpsProtoSeries::clear_has_patientposition() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RtTpsProtoSeries::clear_patientposition() {
  if (patientposition_ != &::google::protobuf::internal::kEmptyString) {
    patientposition_->clear();
  }
  clear_has_patientposition();
}
inline const ::std::string& RtTpsProtoSeries::patientposition() const {
  return *patientposition_;
}
inline void RtTpsProtoSeries::set_patientposition(const ::std::string& value) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(value);
}
inline void RtTpsProtoSeries::set_patientposition(const char* value) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(value);
}
inline void RtTpsProtoSeries::set_patientposition(const char* value, size_t size) {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  patientposition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientposition() {
  set_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    patientposition_ = new ::std::string;
  }
  return patientposition_;
}
inline ::std::string* RtTpsProtoSeries::release_patientposition() {
  clear_has_patientposition();
  if (patientposition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientposition_;
    patientposition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes imageSliceBuffer = 17;
inline bool RtTpsProtoSeries::has_imageslicebuffer() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RtTpsProtoSeries::set_has_imageslicebuffer() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RtTpsProtoSeries::clear_has_imageslicebuffer() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RtTpsProtoSeries::clear_imageslicebuffer() {
  if (imageslicebuffer_ != &::google::protobuf::internal::kEmptyString) {
    imageslicebuffer_->clear();
  }
  clear_has_imageslicebuffer();
}
inline const ::std::string& RtTpsProtoSeries::imageslicebuffer() const {
  return *imageslicebuffer_;
}
inline void RtTpsProtoSeries::set_imageslicebuffer(const ::std::string& value) {
  set_has_imageslicebuffer();
  if (imageslicebuffer_ == &::google::protobuf::internal::kEmptyString) {
    imageslicebuffer_ = new ::std::string;
  }
  imageslicebuffer_->assign(value);
}
inline void RtTpsProtoSeries::set_imageslicebuffer(const char* value) {
  set_has_imageslicebuffer();
  if (imageslicebuffer_ == &::google::protobuf::internal::kEmptyString) {
    imageslicebuffer_ = new ::std::string;
  }
  imageslicebuffer_->assign(value);
}
inline void RtTpsProtoSeries::set_imageslicebuffer(const void* value, size_t size) {
  set_has_imageslicebuffer();
  if (imageslicebuffer_ == &::google::protobuf::internal::kEmptyString) {
    imageslicebuffer_ = new ::std::string;
  }
  imageslicebuffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_imageslicebuffer() {
  set_has_imageslicebuffer();
  if (imageslicebuffer_ == &::google::protobuf::internal::kEmptyString) {
    imageslicebuffer_ = new ::std::string;
  }
  return imageslicebuffer_;
}
inline ::std::string* RtTpsProtoSeries::release_imageslicebuffer() {
  clear_has_imageslicebuffer();
  if (imageslicebuffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageslicebuffer_;
    imageslicebuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isqa = 18;
inline bool RtTpsProtoSeries::has_isqa() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RtTpsProtoSeries::set_has_isqa() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RtTpsProtoSeries::clear_has_isqa() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RtTpsProtoSeries::clear_isqa() {
  isqa_ = false;
  clear_has_isqa();
}
inline bool RtTpsProtoSeries::isqa() const {
  return isqa_;
}
inline void RtTpsProtoSeries::set_isqa(bool value) {
  set_has_isqa();
  isqa_ = value;
}

// optional int32 seriesNumber = 19;
inline bool RtTpsProtoSeries::has_seriesnumber() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriesnumber() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RtTpsProtoSeries::clear_has_seriesnumber() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RtTpsProtoSeries::clear_seriesnumber() {
  seriesnumber_ = 0;
  clear_has_seriesnumber();
}
inline ::google::protobuf::int32 RtTpsProtoSeries::seriesnumber() const {
  return seriesnumber_;
}
inline void RtTpsProtoSeries::set_seriesnumber(::google::protobuf::int32 value) {
  set_has_seriesnumber();
  seriesnumber_ = value;
}

// optional string frameOfReference = 20;
inline bool RtTpsProtoSeries::has_frameofreference() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RtTpsProtoSeries::set_has_frameofreference() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RtTpsProtoSeries::clear_has_frameofreference() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RtTpsProtoSeries::clear_frameofreference() {
  if (frameofreference_ != &::google::protobuf::internal::kEmptyString) {
    frameofreference_->clear();
  }
  clear_has_frameofreference();
}
inline const ::std::string& RtTpsProtoSeries::frameofreference() const {
  return *frameofreference_;
}
inline void RtTpsProtoSeries::set_frameofreference(const ::std::string& value) {
  set_has_frameofreference();
  if (frameofreference_ == &::google::protobuf::internal::kEmptyString) {
    frameofreference_ = new ::std::string;
  }
  frameofreference_->assign(value);
}
inline void RtTpsProtoSeries::set_frameofreference(const char* value) {
  set_has_frameofreference();
  if (frameofreference_ == &::google::protobuf::internal::kEmptyString) {
    frameofreference_ = new ::std::string;
  }
  frameofreference_->assign(value);
}
inline void RtTpsProtoSeries::set_frameofreference(const char* value, size_t size) {
  set_has_frameofreference();
  if (frameofreference_ == &::google::protobuf::internal::kEmptyString) {
    frameofreference_ = new ::std::string;
  }
  frameofreference_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_frameofreference() {
  set_has_frameofreference();
  if (frameofreference_ == &::google::protobuf::internal::kEmptyString) {
    frameofreference_ = new ::std::string;
  }
  return frameofreference_;
}
inline ::std::string* RtTpsProtoSeries::release_frameofreference() {
  clear_has_frameofreference();
  if (frameofreference_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frameofreference_;
    frameofreference_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string manufacturerModelName = 21;
inline bool RtTpsProtoSeries::has_manufacturermodelname() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RtTpsProtoSeries::set_has_manufacturermodelname() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RtTpsProtoSeries::clear_has_manufacturermodelname() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RtTpsProtoSeries::clear_manufacturermodelname() {
  if (manufacturermodelname_ != &::google::protobuf::internal::kEmptyString) {
    manufacturermodelname_->clear();
  }
  clear_has_manufacturermodelname();
}
inline const ::std::string& RtTpsProtoSeries::manufacturermodelname() const {
  return *manufacturermodelname_;
}
inline void RtTpsProtoSeries::set_manufacturermodelname(const ::std::string& value) {
  set_has_manufacturermodelname();
  if (manufacturermodelname_ == &::google::protobuf::internal::kEmptyString) {
    manufacturermodelname_ = new ::std::string;
  }
  manufacturermodelname_->assign(value);
}
inline void RtTpsProtoSeries::set_manufacturermodelname(const char* value) {
  set_has_manufacturermodelname();
  if (manufacturermodelname_ == &::google::protobuf::internal::kEmptyString) {
    manufacturermodelname_ = new ::std::string;
  }
  manufacturermodelname_->assign(value);
}
inline void RtTpsProtoSeries::set_manufacturermodelname(const char* value, size_t size) {
  set_has_manufacturermodelname();
  if (manufacturermodelname_ == &::google::protobuf::internal::kEmptyString) {
    manufacturermodelname_ = new ::std::string;
  }
  manufacturermodelname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_manufacturermodelname() {
  set_has_manufacturermodelname();
  if (manufacturermodelname_ == &::google::protobuf::internal::kEmptyString) {
    manufacturermodelname_ = new ::std::string;
  }
  return manufacturermodelname_;
}
inline ::std::string* RtTpsProtoSeries::release_manufacturermodelname() {
  clear_has_manufacturermodelname();
  if (manufacturermodelname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturermodelname_;
    manufacturermodelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string acquisitionDateTime = 22;
inline bool RtTpsProtoSeries::has_acquisitiondatetime() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RtTpsProtoSeries::set_has_acquisitiondatetime() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RtTpsProtoSeries::clear_has_acquisitiondatetime() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RtTpsProtoSeries::clear_acquisitiondatetime() {
  if (acquisitiondatetime_ != &::google::protobuf::internal::kEmptyString) {
    acquisitiondatetime_->clear();
  }
  clear_has_acquisitiondatetime();
}
inline const ::std::string& RtTpsProtoSeries::acquisitiondatetime() const {
  return *acquisitiondatetime_;
}
inline void RtTpsProtoSeries::set_acquisitiondatetime(const ::std::string& value) {
  set_has_acquisitiondatetime();
  if (acquisitiondatetime_ == &::google::protobuf::internal::kEmptyString) {
    acquisitiondatetime_ = new ::std::string;
  }
  acquisitiondatetime_->assign(value);
}
inline void RtTpsProtoSeries::set_acquisitiondatetime(const char* value) {
  set_has_acquisitiondatetime();
  if (acquisitiondatetime_ == &::google::protobuf::internal::kEmptyString) {
    acquisitiondatetime_ = new ::std::string;
  }
  acquisitiondatetime_->assign(value);
}
inline void RtTpsProtoSeries::set_acquisitiondatetime(const char* value, size_t size) {
  set_has_acquisitiondatetime();
  if (acquisitiondatetime_ == &::google::protobuf::internal::kEmptyString) {
    acquisitiondatetime_ = new ::std::string;
  }
  acquisitiondatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_acquisitiondatetime() {
  set_has_acquisitiondatetime();
  if (acquisitiondatetime_ == &::google::protobuf::internal::kEmptyString) {
    acquisitiondatetime_ = new ::std::string;
  }
  return acquisitiondatetime_;
}
inline ::std::string* RtTpsProtoSeries::release_acquisitiondatetime() {
  clear_has_acquisitiondatetime();
  if (acquisitiondatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acquisitiondatetime_;
    acquisitiondatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string courseUID = 23;
inline bool RtTpsProtoSeries::has_courseuid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RtTpsProtoSeries::set_has_courseuid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RtTpsProtoSeries::clear_has_courseuid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RtTpsProtoSeries::clear_courseuid() {
  if (courseuid_ != &::google::protobuf::internal::kEmptyString) {
    courseuid_->clear();
  }
  clear_has_courseuid();
}
inline const ::std::string& RtTpsProtoSeries::courseuid() const {
  return *courseuid_;
}
inline void RtTpsProtoSeries::set_courseuid(const ::std::string& value) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(value);
}
inline void RtTpsProtoSeries::set_courseuid(const char* value) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(value);
}
inline void RtTpsProtoSeries::set_courseuid(const char* value, size_t size) {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  courseuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_courseuid() {
  set_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    courseuid_ = new ::std::string;
  }
  return courseuid_;
}
inline ::std::string* RtTpsProtoSeries::release_courseuid() {
  clear_has_courseuid();
  if (courseuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = courseuid_;
    courseuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float startX = 24;
inline bool RtTpsProtoSeries::has_startx() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RtTpsProtoSeries::set_has_startx() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RtTpsProtoSeries::clear_has_startx() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RtTpsProtoSeries::clear_startx() {
  startx_ = 0;
  clear_has_startx();
}
inline float RtTpsProtoSeries::startx() const {
  return startx_;
}
inline void RtTpsProtoSeries::set_startx(float value) {
  set_has_startx();
  startx_ = value;
}

// optional float startY = 25;
inline bool RtTpsProtoSeries::has_starty() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RtTpsProtoSeries::set_has_starty() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RtTpsProtoSeries::clear_has_starty() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RtTpsProtoSeries::clear_starty() {
  starty_ = 0;
  clear_has_starty();
}
inline float RtTpsProtoSeries::starty() const {
  return starty_;
}
inline void RtTpsProtoSeries::set_starty(float value) {
  set_has_starty();
  starty_ = value;
}

// optional float startZ = 26;
inline bool RtTpsProtoSeries::has_startz() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RtTpsProtoSeries::set_has_startz() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RtTpsProtoSeries::clear_has_startz() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RtTpsProtoSeries::clear_startz() {
  startz_ = 0;
  clear_has_startz();
}
inline float RtTpsProtoSeries::startz() const {
  return startz_;
}
inline void RtTpsProtoSeries::set_startz(float value) {
  set_has_startz();
  startz_ = value;
}

// optional float sizeX = 27;
inline bool RtTpsProtoSeries::has_sizex() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RtTpsProtoSeries::set_has_sizex() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RtTpsProtoSeries::clear_has_sizex() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RtTpsProtoSeries::clear_sizex() {
  sizex_ = 0;
  clear_has_sizex();
}
inline float RtTpsProtoSeries::sizex() const {
  return sizex_;
}
inline void RtTpsProtoSeries::set_sizex(float value) {
  set_has_sizex();
  sizex_ = value;
}

// optional float sizeY = 28;
inline bool RtTpsProtoSeries::has_sizey() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RtTpsProtoSeries::set_has_sizey() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RtTpsProtoSeries::clear_has_sizey() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RtTpsProtoSeries::clear_sizey() {
  sizey_ = 0;
  clear_has_sizey();
}
inline float RtTpsProtoSeries::sizey() const {
  return sizey_;
}
inline void RtTpsProtoSeries::set_sizey(float value) {
  set_has_sizey();
  sizey_ = value;
}

// optional float sizeZ = 29;
inline bool RtTpsProtoSeries::has_sizez() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RtTpsProtoSeries::set_has_sizez() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RtTpsProtoSeries::clear_has_sizez() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RtTpsProtoSeries::clear_sizez() {
  sizez_ = 0;
  clear_has_sizez();
}
inline float RtTpsProtoSeries::sizez() const {
  return sizez_;
}
inline void RtTpsProtoSeries::set_sizez(float value) {
  set_has_sizez();
  sizez_ = value;
}

// repeated .tps.proto.RtTpsProtoImagetransformation imagetransformationList = 30;
inline int RtTpsProtoSeries::imagetransformationlist_size() const {
  return imagetransformationlist_.size();
}
inline void RtTpsProtoSeries::clear_imagetransformationlist() {
  imagetransformationlist_.Clear();
}
inline const ::tps::proto::RtTpsProtoImagetransformation& RtTpsProtoSeries::imagetransformationlist(int index) const {
  return imagetransformationlist_.Get(index);
}
inline ::tps::proto::RtTpsProtoImagetransformation* RtTpsProtoSeries::mutable_imagetransformationlist(int index) {
  return imagetransformationlist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoImagetransformation* RtTpsProtoSeries::add_imagetransformationlist() {
  return imagetransformationlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoImagetransformation >&
RtTpsProtoSeries::imagetransformationlist() const {
  return imagetransformationlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoImagetransformation >*
RtTpsProtoSeries::mutable_imagetransformationlist() {
  return &imagetransformationlist_;
}

// repeated float orientationX = 31;
inline int RtTpsProtoSeries::orientationx_size() const {
  return orientationx_.size();
}
inline void RtTpsProtoSeries::clear_orientationx() {
  orientationx_.Clear();
}
inline float RtTpsProtoSeries::orientationx(int index) const {
  return orientationx_.Get(index);
}
inline void RtTpsProtoSeries::set_orientationx(int index, float value) {
  orientationx_.Set(index, value);
}
inline void RtTpsProtoSeries::add_orientationx(float value) {
  orientationx_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RtTpsProtoSeries::orientationx() const {
  return orientationx_;
}
inline ::google::protobuf::RepeatedField< float >*
RtTpsProtoSeries::mutable_orientationx() {
  return &orientationx_;
}

// repeated float orientationY = 32;
inline int RtTpsProtoSeries::orientationy_size() const {
  return orientationy_.size();
}
inline void RtTpsProtoSeries::clear_orientationy() {
  orientationy_.Clear();
}
inline float RtTpsProtoSeries::orientationy(int index) const {
  return orientationy_.Get(index);
}
inline void RtTpsProtoSeries::set_orientationy(int index, float value) {
  orientationy_.Set(index, value);
}
inline void RtTpsProtoSeries::add_orientationy(float value) {
  orientationy_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RtTpsProtoSeries::orientationy() const {
  return orientationy_;
}
inline ::google::protobuf::RepeatedField< float >*
RtTpsProtoSeries::mutable_orientationy() {
  return &orientationy_;
}

// repeated float orientationZ = 33;
inline int RtTpsProtoSeries::orientationz_size() const {
  return orientationz_.size();
}
inline void RtTpsProtoSeries::clear_orientationz() {
  orientationz_.Clear();
}
inline float RtTpsProtoSeries::orientationz(int index) const {
  return orientationz_.Get(index);
}
inline void RtTpsProtoSeries::set_orientationz(int index, float value) {
  orientationz_.Set(index, value);
}
inline void RtTpsProtoSeries::add_orientationz(float value) {
  orientationz_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RtTpsProtoSeries::orientationz() const {
  return orientationz_;
}
inline ::google::protobuf::RepeatedField< float >*
RtTpsProtoSeries::mutable_orientationz() {
  return &orientationz_;
}

// optional string groupUid = 34;
inline bool RtTpsProtoSeries::has_groupuid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RtTpsProtoSeries::set_has_groupuid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RtTpsProtoSeries::clear_has_groupuid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RtTpsProtoSeries::clear_groupuid() {
  if (groupuid_ != &::google::protobuf::internal::kEmptyString) {
    groupuid_->clear();
  }
  clear_has_groupuid();
}
inline const ::std::string& RtTpsProtoSeries::groupuid() const {
  return *groupuid_;
}
inline void RtTpsProtoSeries::set_groupuid(const ::std::string& value) {
  set_has_groupuid();
  if (groupuid_ == &::google::protobuf::internal::kEmptyString) {
    groupuid_ = new ::std::string;
  }
  groupuid_->assign(value);
}
inline void RtTpsProtoSeries::set_groupuid(const char* value) {
  set_has_groupuid();
  if (groupuid_ == &::google::protobuf::internal::kEmptyString) {
    groupuid_ = new ::std::string;
  }
  groupuid_->assign(value);
}
inline void RtTpsProtoSeries::set_groupuid(const char* value, size_t size) {
  set_has_groupuid();
  if (groupuid_ == &::google::protobuf::internal::kEmptyString) {
    groupuid_ = new ::std::string;
  }
  groupuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_groupuid() {
  set_has_groupuid();
  if (groupuid_ == &::google::protobuf::internal::kEmptyString) {
    groupuid_ = new ::std::string;
  }
  return groupuid_;
}
inline ::std::string* RtTpsProtoSeries::release_groupuid() {
  clear_has_groupuid();
  if (groupuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupuid_;
    groupuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string slicethickness = 35;
inline bool RtTpsProtoSeries::has_slicethickness() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RtTpsProtoSeries::set_has_slicethickness() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RtTpsProtoSeries::clear_has_slicethickness() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RtTpsProtoSeries::clear_slicethickness() {
  if (slicethickness_ != &::google::protobuf::internal::kEmptyString) {
    slicethickness_->clear();
  }
  clear_has_slicethickness();
}
inline const ::std::string& RtTpsProtoSeries::slicethickness() const {
  return *slicethickness_;
}
inline void RtTpsProtoSeries::set_slicethickness(const ::std::string& value) {
  set_has_slicethickness();
  if (slicethickness_ == &::google::protobuf::internal::kEmptyString) {
    slicethickness_ = new ::std::string;
  }
  slicethickness_->assign(value);
}
inline void RtTpsProtoSeries::set_slicethickness(const char* value) {
  set_has_slicethickness();
  if (slicethickness_ == &::google::protobuf::internal::kEmptyString) {
    slicethickness_ = new ::std::string;
  }
  slicethickness_->assign(value);
}
inline void RtTpsProtoSeries::set_slicethickness(const char* value, size_t size) {
  set_has_slicethickness();
  if (slicethickness_ == &::google::protobuf::internal::kEmptyString) {
    slicethickness_ = new ::std::string;
  }
  slicethickness_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_slicethickness() {
  set_has_slicethickness();
  if (slicethickness_ == &::google::protobuf::internal::kEmptyString) {
    slicethickness_ = new ::std::string;
  }
  return slicethickness_;
}
inline ::std::string* RtTpsProtoSeries::release_slicethickness() {
  clear_has_slicethickness();
  if (slicethickness_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = slicethickness_;
    slicethickness_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string studyid = 36;
inline bool RtTpsProtoSeries::has_studyid() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RtTpsProtoSeries::set_has_studyid() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RtTpsProtoSeries::clear_has_studyid() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RtTpsProtoSeries::clear_studyid() {
  if (studyid_ != &::google::protobuf::internal::kEmptyString) {
    studyid_->clear();
  }
  clear_has_studyid();
}
inline const ::std::string& RtTpsProtoSeries::studyid() const {
  return *studyid_;
}
inline void RtTpsProtoSeries::set_studyid(const ::std::string& value) {
  set_has_studyid();
  if (studyid_ == &::google::protobuf::internal::kEmptyString) {
    studyid_ = new ::std::string;
  }
  studyid_->assign(value);
}
inline void RtTpsProtoSeries::set_studyid(const char* value) {
  set_has_studyid();
  if (studyid_ == &::google::protobuf::internal::kEmptyString) {
    studyid_ = new ::std::string;
  }
  studyid_->assign(value);
}
inline void RtTpsProtoSeries::set_studyid(const char* value, size_t size) {
  set_has_studyid();
  if (studyid_ == &::google::protobuf::internal::kEmptyString) {
    studyid_ = new ::std::string;
  }
  studyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_studyid() {
  set_has_studyid();
  if (studyid_ == &::google::protobuf::internal::kEmptyString) {
    studyid_ = new ::std::string;
  }
  return studyid_;
}
inline ::std::string* RtTpsProtoSeries::release_studyid() {
  clear_has_studyid();
  if (studyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = studyid_;
    studyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string studydescription = 37;
inline bool RtTpsProtoSeries::has_studydescription() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void RtTpsProtoSeries::set_has_studydescription() {
  _has_bits_[1] |= 0x00000010u;
}
inline void RtTpsProtoSeries::clear_has_studydescription() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void RtTpsProtoSeries::clear_studydescription() {
  if (studydescription_ != &::google::protobuf::internal::kEmptyString) {
    studydescription_->clear();
  }
  clear_has_studydescription();
}
inline const ::std::string& RtTpsProtoSeries::studydescription() const {
  return *studydescription_;
}
inline void RtTpsProtoSeries::set_studydescription(const ::std::string& value) {
  set_has_studydescription();
  if (studydescription_ == &::google::protobuf::internal::kEmptyString) {
    studydescription_ = new ::std::string;
  }
  studydescription_->assign(value);
}
inline void RtTpsProtoSeries::set_studydescription(const char* value) {
  set_has_studydescription();
  if (studydescription_ == &::google::protobuf::internal::kEmptyString) {
    studydescription_ = new ::std::string;
  }
  studydescription_->assign(value);
}
inline void RtTpsProtoSeries::set_studydescription(const char* value, size_t size) {
  set_has_studydescription();
  if (studydescription_ == &::google::protobuf::internal::kEmptyString) {
    studydescription_ = new ::std::string;
  }
  studydescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_studydescription() {
  set_has_studydescription();
  if (studydescription_ == &::google::protobuf::internal::kEmptyString) {
    studydescription_ = new ::std::string;
  }
  return studydescription_;
}
inline ::std::string* RtTpsProtoSeries::release_studydescription() {
  clear_has_studydescription();
  if (studydescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = studydescription_;
    studydescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientname = 38;
inline bool RtTpsProtoSeries::has_patientname() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientname() {
  _has_bits_[1] |= 0x00000020u;
}
inline void RtTpsProtoSeries::clear_has_patientname() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void RtTpsProtoSeries::clear_patientname() {
  if (patientname_ != &::google::protobuf::internal::kEmptyString) {
    patientname_->clear();
  }
  clear_has_patientname();
}
inline const ::std::string& RtTpsProtoSeries::patientname() const {
  return *patientname_;
}
inline void RtTpsProtoSeries::set_patientname(const ::std::string& value) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(value);
}
inline void RtTpsProtoSeries::set_patientname(const char* value) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(value);
}
inline void RtTpsProtoSeries::set_patientname(const char* value, size_t size) {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  patientname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientname() {
  set_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    patientname_ = new ::std::string;
  }
  return patientname_;
}
inline ::std::string* RtTpsProtoSeries::release_patientname() {
  clear_has_patientname();
  if (patientname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientname_;
    patientname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientid = 39;
inline bool RtTpsProtoSeries::has_patientid() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientid() {
  _has_bits_[1] |= 0x00000040u;
}
inline void RtTpsProtoSeries::clear_has_patientid() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void RtTpsProtoSeries::clear_patientid() {
  if (patientid_ != &::google::protobuf::internal::kEmptyString) {
    patientid_->clear();
  }
  clear_has_patientid();
}
inline const ::std::string& RtTpsProtoSeries::patientid() const {
  return *patientid_;
}
inline void RtTpsProtoSeries::set_patientid(const ::std::string& value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void RtTpsProtoSeries::set_patientid(const char* value) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(value);
}
inline void RtTpsProtoSeries::set_patientid(const char* value, size_t size) {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  patientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientid() {
  set_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    patientid_ = new ::std::string;
  }
  return patientid_;
}
inline ::std::string* RtTpsProtoSeries::release_patientid() {
  clear_has_patientid();
  if (patientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientid_;
    patientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientbirthdate = 40;
inline bool RtTpsProtoSeries::has_patientbirthdate() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientbirthdate() {
  _has_bits_[1] |= 0x00000080u;
}
inline void RtTpsProtoSeries::clear_has_patientbirthdate() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void RtTpsProtoSeries::clear_patientbirthdate() {
  if (patientbirthdate_ != &::google::protobuf::internal::kEmptyString) {
    patientbirthdate_->clear();
  }
  clear_has_patientbirthdate();
}
inline const ::std::string& RtTpsProtoSeries::patientbirthdate() const {
  return *patientbirthdate_;
}
inline void RtTpsProtoSeries::set_patientbirthdate(const ::std::string& value) {
  set_has_patientbirthdate();
  if (patientbirthdate_ == &::google::protobuf::internal::kEmptyString) {
    patientbirthdate_ = new ::std::string;
  }
  patientbirthdate_->assign(value);
}
inline void RtTpsProtoSeries::set_patientbirthdate(const char* value) {
  set_has_patientbirthdate();
  if (patientbirthdate_ == &::google::protobuf::internal::kEmptyString) {
    patientbirthdate_ = new ::std::string;
  }
  patientbirthdate_->assign(value);
}
inline void RtTpsProtoSeries::set_patientbirthdate(const char* value, size_t size) {
  set_has_patientbirthdate();
  if (patientbirthdate_ == &::google::protobuf::internal::kEmptyString) {
    patientbirthdate_ = new ::std::string;
  }
  patientbirthdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientbirthdate() {
  set_has_patientbirthdate();
  if (patientbirthdate_ == &::google::protobuf::internal::kEmptyString) {
    patientbirthdate_ = new ::std::string;
  }
  return patientbirthdate_;
}
inline ::std::string* RtTpsProtoSeries::release_patientbirthdate() {
  clear_has_patientbirthdate();
  if (patientbirthdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientbirthdate_;
    patientbirthdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientage = 41;
inline bool RtTpsProtoSeries::has_patientage() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientage() {
  _has_bits_[1] |= 0x00000100u;
}
inline void RtTpsProtoSeries::clear_has_patientage() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void RtTpsProtoSeries::clear_patientage() {
  if (patientage_ != &::google::protobuf::internal::kEmptyString) {
    patientage_->clear();
  }
  clear_has_patientage();
}
inline const ::std::string& RtTpsProtoSeries::patientage() const {
  return *patientage_;
}
inline void RtTpsProtoSeries::set_patientage(const ::std::string& value) {
  set_has_patientage();
  if (patientage_ == &::google::protobuf::internal::kEmptyString) {
    patientage_ = new ::std::string;
  }
  patientage_->assign(value);
}
inline void RtTpsProtoSeries::set_patientage(const char* value) {
  set_has_patientage();
  if (patientage_ == &::google::protobuf::internal::kEmptyString) {
    patientage_ = new ::std::string;
  }
  patientage_->assign(value);
}
inline void RtTpsProtoSeries::set_patientage(const char* value, size_t size) {
  set_has_patientage();
  if (patientage_ == &::google::protobuf::internal::kEmptyString) {
    patientage_ = new ::std::string;
  }
  patientage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientage() {
  set_has_patientage();
  if (patientage_ == &::google::protobuf::internal::kEmptyString) {
    patientage_ = new ::std::string;
  }
  return patientage_;
}
inline ::std::string* RtTpsProtoSeries::release_patientage() {
  clear_has_patientage();
  if (patientage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientage_;
    patientage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string patientsex = 42;
inline bool RtTpsProtoSeries::has_patientsex() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientsex() {
  _has_bits_[1] |= 0x00000200u;
}
inline void RtTpsProtoSeries::clear_has_patientsex() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void RtTpsProtoSeries::clear_patientsex() {
  if (patientsex_ != &::google::protobuf::internal::kEmptyString) {
    patientsex_->clear();
  }
  clear_has_patientsex();
}
inline const ::std::string& RtTpsProtoSeries::patientsex() const {
  return *patientsex_;
}
inline void RtTpsProtoSeries::set_patientsex(const ::std::string& value) {
  set_has_patientsex();
  if (patientsex_ == &::google::protobuf::internal::kEmptyString) {
    patientsex_ = new ::std::string;
  }
  patientsex_->assign(value);
}
inline void RtTpsProtoSeries::set_patientsex(const char* value) {
  set_has_patientsex();
  if (patientsex_ == &::google::protobuf::internal::kEmptyString) {
    patientsex_ = new ::std::string;
  }
  patientsex_->assign(value);
}
inline void RtTpsProtoSeries::set_patientsex(const char* value, size_t size) {
  set_has_patientsex();
  if (patientsex_ == &::google::protobuf::internal::kEmptyString) {
    patientsex_ = new ::std::string;
  }
  patientsex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientsex() {
  set_has_patientsex();
  if (patientsex_ == &::google::protobuf::internal::kEmptyString) {
    patientsex_ = new ::std::string;
  }
  return patientsex_;
}
inline ::std::string* RtTpsProtoSeries::release_patientsex() {
  clear_has_patientsex();
  if (patientsex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientsex_;
    patientsex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string institutionname = 43;
inline bool RtTpsProtoSeries::has_institutionname() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void RtTpsProtoSeries::set_has_institutionname() {
  _has_bits_[1] |= 0x00000400u;
}
inline void RtTpsProtoSeries::clear_has_institutionname() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void RtTpsProtoSeries::clear_institutionname() {
  if (institutionname_ != &::google::protobuf::internal::kEmptyString) {
    institutionname_->clear();
  }
  clear_has_institutionname();
}
inline const ::std::string& RtTpsProtoSeries::institutionname() const {
  return *institutionname_;
}
inline void RtTpsProtoSeries::set_institutionname(const ::std::string& value) {
  set_has_institutionname();
  if (institutionname_ == &::google::protobuf::internal::kEmptyString) {
    institutionname_ = new ::std::string;
  }
  institutionname_->assign(value);
}
inline void RtTpsProtoSeries::set_institutionname(const char* value) {
  set_has_institutionname();
  if (institutionname_ == &::google::protobuf::internal::kEmptyString) {
    institutionname_ = new ::std::string;
  }
  institutionname_->assign(value);
}
inline void RtTpsProtoSeries::set_institutionname(const char* value, size_t size) {
  set_has_institutionname();
  if (institutionname_ == &::google::protobuf::internal::kEmptyString) {
    institutionname_ = new ::std::string;
  }
  institutionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_institutionname() {
  set_has_institutionname();
  if (institutionname_ == &::google::protobuf::internal::kEmptyString) {
    institutionname_ = new ::std::string;
  }
  return institutionname_;
}
inline ::std::string* RtTpsProtoSeries::release_institutionname() {
  clear_has_institutionname();
  if (institutionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = institutionname_;
    institutionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string manufacturer = 44;
inline bool RtTpsProtoSeries::has_manufacturer() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void RtTpsProtoSeries::set_has_manufacturer() {
  _has_bits_[1] |= 0x00000800u;
}
inline void RtTpsProtoSeries::clear_has_manufacturer() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void RtTpsProtoSeries::clear_manufacturer() {
  if (manufacturer_ != &::google::protobuf::internal::kEmptyString) {
    manufacturer_->clear();
  }
  clear_has_manufacturer();
}
inline const ::std::string& RtTpsProtoSeries::manufacturer() const {
  return *manufacturer_;
}
inline void RtTpsProtoSeries::set_manufacturer(const ::std::string& value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void RtTpsProtoSeries::set_manufacturer(const char* value) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(value);
}
inline void RtTpsProtoSeries::set_manufacturer(const char* value, size_t size) {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  manufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_manufacturer() {
  set_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    manufacturer_ = new ::std::string;
  }
  return manufacturer_;
}
inline ::std::string* RtTpsProtoSeries::release_manufacturer() {
  clear_has_manufacturer();
  if (manufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = manufacturer_;
    manufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ct2densityUID = 45;
inline bool RtTpsProtoSeries::has_ct2densityuid() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void RtTpsProtoSeries::set_has_ct2densityuid() {
  _has_bits_[1] |= 0x00001000u;
}
inline void RtTpsProtoSeries::clear_has_ct2densityuid() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void RtTpsProtoSeries::clear_ct2densityuid() {
  if (ct2densityuid_ != &::google::protobuf::internal::kEmptyString) {
    ct2densityuid_->clear();
  }
  clear_has_ct2densityuid();
}
inline const ::std::string& RtTpsProtoSeries::ct2densityuid() const {
  return *ct2densityuid_;
}
inline void RtTpsProtoSeries::set_ct2densityuid(const ::std::string& value) {
  set_has_ct2densityuid();
  if (ct2densityuid_ == &::google::protobuf::internal::kEmptyString) {
    ct2densityuid_ = new ::std::string;
  }
  ct2densityuid_->assign(value);
}
inline void RtTpsProtoSeries::set_ct2densityuid(const char* value) {
  set_has_ct2densityuid();
  if (ct2densityuid_ == &::google::protobuf::internal::kEmptyString) {
    ct2densityuid_ = new ::std::string;
  }
  ct2densityuid_->assign(value);
}
inline void RtTpsProtoSeries::set_ct2densityuid(const char* value, size_t size) {
  set_has_ct2densityuid();
  if (ct2densityuid_ == &::google::protobuf::internal::kEmptyString) {
    ct2densityuid_ = new ::std::string;
  }
  ct2densityuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_ct2densityuid() {
  set_has_ct2densityuid();
  if (ct2densityuid_ == &::google::protobuf::internal::kEmptyString) {
    ct2densityuid_ = new ::std::string;
  }
  return ct2densityuid_;
}
inline ::std::string* RtTpsProtoSeries::release_ct2densityuid() {
  clear_has_ct2densityuid();
  if (ct2densityuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ct2densityuid_;
    ct2densityuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .tps.proto.RtTpsProtoSeriesTable seriesTable = 46;
inline bool RtTpsProtoSeries::has_seriestable() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriestable() {
  _has_bits_[1] |= 0x00002000u;
}
inline void RtTpsProtoSeries::clear_has_seriestable() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void RtTpsProtoSeries::clear_seriestable() {
  if (seriestable_ != NULL) seriestable_->::tps::proto::RtTpsProtoSeriesTable::Clear();
  clear_has_seriestable();
}
inline const ::tps::proto::RtTpsProtoSeriesTable& RtTpsProtoSeries::seriestable() const {
  return seriestable_ != NULL ? *seriestable_ : *default_instance_->seriestable_;
}
inline ::tps::proto::RtTpsProtoSeriesTable* RtTpsProtoSeries::mutable_seriestable() {
  set_has_seriestable();
  if (seriestable_ == NULL) seriestable_ = new ::tps::proto::RtTpsProtoSeriesTable;
  return seriestable_;
}
inline ::tps::proto::RtTpsProtoSeriesTable* RtTpsProtoSeries::release_seriestable() {
  clear_has_seriestable();
  ::tps::proto::RtTpsProtoSeriesTable* temp = seriestable_;
  seriestable_ = NULL;
  return temp;
}

// optional string patientuid = 47;
inline bool RtTpsProtoSeries::has_patientuid() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void RtTpsProtoSeries::set_has_patientuid() {
  _has_bits_[1] |= 0x00004000u;
}
inline void RtTpsProtoSeries::clear_has_patientuid() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void RtTpsProtoSeries::clear_patientuid() {
  if (patientuid_ != &::google::protobuf::internal::kEmptyString) {
    patientuid_->clear();
  }
  clear_has_patientuid();
}
inline const ::std::string& RtTpsProtoSeries::patientuid() const {
  return *patientuid_;
}
inline void RtTpsProtoSeries::set_patientuid(const ::std::string& value) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(value);
}
inline void RtTpsProtoSeries::set_patientuid(const char* value) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(value);
}
inline void RtTpsProtoSeries::set_patientuid(const char* value, size_t size) {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  patientuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_patientuid() {
  set_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    patientuid_ = new ::std::string;
  }
  return patientuid_;
}
inline ::std::string* RtTpsProtoSeries::release_patientuid() {
  clear_has_patientuid();
  if (patientuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = patientuid_;
    patientuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string seriesname = 48;
inline bool RtTpsProtoSeries::has_seriesname() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void RtTpsProtoSeries::set_has_seriesname() {
  _has_bits_[1] |= 0x00008000u;
}
inline void RtTpsProtoSeries::clear_has_seriesname() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void RtTpsProtoSeries::clear_seriesname() {
  if (seriesname_ != &::google::protobuf::internal::kEmptyString) {
    seriesname_->clear();
  }
  clear_has_seriesname();
}
inline const ::std::string& RtTpsProtoSeries::seriesname() const {
  return *seriesname_;
}
inline void RtTpsProtoSeries::set_seriesname(const ::std::string& value) {
  set_has_seriesname();
  if (seriesname_ == &::google::protobuf::internal::kEmptyString) {
    seriesname_ = new ::std::string;
  }
  seriesname_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesname(const char* value) {
  set_has_seriesname();
  if (seriesname_ == &::google::protobuf::internal::kEmptyString) {
    seriesname_ = new ::std::string;
  }
  seriesname_->assign(value);
}
inline void RtTpsProtoSeries::set_seriesname(const char* value, size_t size) {
  set_has_seriesname();
  if (seriesname_ == &::google::protobuf::internal::kEmptyString) {
    seriesname_ = new ::std::string;
  }
  seriesname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RtTpsProtoSeries::mutable_seriesname() {
  set_has_seriesname();
  if (seriesname_ == &::google::protobuf::internal::kEmptyString) {
    seriesname_ = new ::std::string;
  }
  return seriesname_;
}
inline ::std::string* RtTpsProtoSeries::release_seriesname() {
  clear_has_seriesname();
  if (seriesname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = seriesname_;
    seriesname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isphantom = 49;
inline bool RtTpsProtoSeries::has_isphantom() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void RtTpsProtoSeries::set_has_isphantom() {
  _has_bits_[1] |= 0x00010000u;
}
inline void RtTpsProtoSeries::clear_has_isphantom() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void RtTpsProtoSeries::clear_isphantom() {
  isphantom_ = false;
  clear_has_isphantom();
}
inline bool RtTpsProtoSeries::isphantom() const {
  return isphantom_;
}
inline void RtTpsProtoSeries::set_isphantom(bool value) {
  set_has_isphantom();
  isphantom_ = value;
}

// repeated .tps.proto.RtTpsProtoPoi poiList = 50;
inline int RtTpsProtoSeries::poilist_size() const {
  return poilist_.size();
}
inline void RtTpsProtoSeries::clear_poilist() {
  poilist_.Clear();
}
inline const ::tps::proto::RtTpsProtoPoi& RtTpsProtoSeries::poilist(int index) const {
  return poilist_.Get(index);
}
inline ::tps::proto::RtTpsProtoPoi* RtTpsProtoSeries::mutable_poilist(int index) {
  return poilist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoPoi* RtTpsProtoSeries::add_poilist() {
  return poilist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >&
RtTpsProtoSeries::poilist() const {
  return poilist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoPoi >*
RtTpsProtoSeries::mutable_poilist() {
  return &poilist_;
}

// -------------------------------------------------------------------

// RtTpsProtoRepeatedSeries

// repeated .tps.proto.RtTpsProtoSeries seriesList = 1;
inline int RtTpsProtoRepeatedSeries::serieslist_size() const {
  return serieslist_.size();
}
inline void RtTpsProtoRepeatedSeries::clear_serieslist() {
  serieslist_.Clear();
}
inline const ::tps::proto::RtTpsProtoSeries& RtTpsProtoRepeatedSeries::serieslist(int index) const {
  return serieslist_.Get(index);
}
inline ::tps::proto::RtTpsProtoSeries* RtTpsProtoRepeatedSeries::mutable_serieslist(int index) {
  return serieslist_.Mutable(index);
}
inline ::tps::proto::RtTpsProtoSeries* RtTpsProtoRepeatedSeries::add_serieslist() {
  return serieslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSeries >&
RtTpsProtoRepeatedSeries::serieslist() const {
  return serieslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::tps::proto::RtTpsProtoSeries >*
RtTpsProtoRepeatedSeries::mutable_serieslist() {
  return &serieslist_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tps

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5ftps_5fproto_5fseries_2eproto__INCLUDED
