// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rt_ms_montecarlo.proto

#ifndef PROTOBUF_rt_5fms_5fmontecarlo_2eproto__INCLUDED
#define PROTOBUF_rt_5fms_5fmontecarlo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace ms {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();

class RT_MS_Spectrum;
class RT_MS_FieldSize;
class RT_MS_ContourVerter;
class RT_MS_MonteCarloVirtualWedgeField;
class RT_MS_MonteCarloVirtualWedgeInfo;
class RT_MS_MonteCarloPhysicalWedgeField;
class RT_MS_MonteCarlo;

// ===================================================================

class RT_MS_Spectrum : public ::google::protobuf::Message {
 public:
  RT_MS_Spectrum();
  virtual ~RT_MS_Spectrum();
  
  RT_MS_Spectrum(const RT_MS_Spectrum& from);
  
  inline RT_MS_Spectrum& operator=(const RT_MS_Spectrum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_Spectrum& default_instance();
  
  void Swap(RT_MS_Spectrum* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_Spectrum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_Spectrum& from);
  void MergeFrom(const RT_MS_Spectrum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float energy = 2;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 2;
  inline float energy() const;
  inline void set_energy(float value);
  
  // optional float weight = 3;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 3;
  inline float weight() const;
  inline void set_weight(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_Spectrum)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_weight();
  inline void clear_has_weight();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float energy_;
  float weight_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_Spectrum* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_FieldSize : public ::google::protobuf::Message {
 public:
  RT_MS_FieldSize();
  virtual ~RT_MS_FieldSize();
  
  RT_MS_FieldSize(const RT_MS_FieldSize& from);
  
  inline RT_MS_FieldSize& operator=(const RT_MS_FieldSize& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_FieldSize& default_instance();
  
  void Swap(RT_MS_FieldSize* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_FieldSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_FieldSize& from);
  void MergeFrom(const RT_MS_FieldSize& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float fieldSize = 2;
  inline bool has_fieldsize() const;
  inline void clear_fieldsize();
  static const int kFieldSizeFieldNumber = 2;
  inline float fieldsize() const;
  inline void set_fieldsize(float value);
  
  // optional float absoluteFactor = 3;
  inline bool has_absolutefactor() const;
  inline void clear_absolutefactor();
  static const int kAbsoluteFactorFieldNumber = 3;
  inline float absolutefactor() const;
  inline void set_absolutefactor(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_FieldSize)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_fieldsize();
  inline void clear_has_fieldsize();
  inline void set_has_absolutefactor();
  inline void clear_has_absolutefactor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float fieldsize_;
  float absolutefactor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_FieldSize* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_ContourVerter : public ::google::protobuf::Message {
 public:
  RT_MS_ContourVerter();
  virtual ~RT_MS_ContourVerter();
  
  RT_MS_ContourVerter(const RT_MS_ContourVerter& from);
  
  inline RT_MS_ContourVerter& operator=(const RT_MS_ContourVerter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_ContourVerter& default_instance();
  
  void Swap(RT_MS_ContourVerter* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_ContourVerter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_ContourVerter& from);
  void MergeFrom(const RT_MS_ContourVerter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float ContourVerterx = 2;
  inline bool has_contourverterx() const;
  inline void clear_contourverterx();
  static const int kContourVerterxFieldNumber = 2;
  inline float contourverterx() const;
  inline void set_contourverterx(float value);
  
  // optional float ContourVertery = 3;
  inline bool has_contourvertery() const;
  inline void clear_contourvertery();
  static const int kContourVerteryFieldNumber = 3;
  inline float contourvertery() const;
  inline void set_contourvertery(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_ContourVerter)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_contourverterx();
  inline void clear_has_contourverterx();
  inline void set_has_contourvertery();
  inline void clear_has_contourvertery();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float contourverterx_;
  float contourvertery_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_ContourVerter* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MonteCarloVirtualWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_MonteCarloVirtualWedgeField();
  virtual ~RT_MS_MonteCarloVirtualWedgeField();
  
  RT_MS_MonteCarloVirtualWedgeField(const RT_MS_MonteCarloVirtualWedgeField& from);
  
  inline RT_MS_MonteCarloVirtualWedgeField& operator=(const RT_MS_MonteCarloVirtualWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MonteCarloVirtualWedgeField& default_instance();
  
  void Swap(RT_MS_MonteCarloVirtualWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MonteCarloVirtualWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MonteCarloVirtualWedgeField& from);
  void MergeFrom(const RT_MS_MonteCarloVirtualWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional float collimatorX1Position = 2;
  inline bool has_collimatorx1position() const;
  inline void clear_collimatorx1position();
  static const int kCollimatorX1PositionFieldNumber = 2;
  inline float collimatorx1position() const;
  inline void set_collimatorx1position(float value);
  
  // optional float collimatorX2Position = 3;
  inline bool has_collimatorx2position() const;
  inline void clear_collimatorx2position();
  static const int kCollimatorX2PositionFieldNumber = 3;
  inline float collimatorx2position() const;
  inline void set_collimatorx2position(float value);
  
  // optional float relativeMU = 4;
  inline bool has_relativemu() const;
  inline void clear_relativemu();
  static const int kRelativeMUFieldNumber = 4;
  inline float relativemu() const;
  inline void set_relativemu(float value);
  
  // optional float correctionFactor = 5;
  inline bool has_correctionfactor() const;
  inline void clear_correctionfactor();
  static const int kCorrectionFactorFieldNumber = 5;
  inline float correctionfactor() const;
  inline void set_correctionfactor(float value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MonteCarloVirtualWedgeField)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_collimatorx1position();
  inline void clear_has_collimatorx1position();
  inline void set_has_collimatorx2position();
  inline void clear_has_collimatorx2position();
  inline void set_has_relativemu();
  inline void clear_has_relativemu();
  inline void set_has_correctionfactor();
  inline void clear_has_correctionfactor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  float collimatorx1position_;
  float collimatorx2position_;
  float relativemu_;
  float correctionfactor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MonteCarloVirtualWedgeField* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MonteCarloVirtualWedgeInfo : public ::google::protobuf::Message {
 public:
  RT_MS_MonteCarloVirtualWedgeInfo();
  virtual ~RT_MS_MonteCarloVirtualWedgeInfo();
  
  RT_MS_MonteCarloVirtualWedgeInfo(const RT_MS_MonteCarloVirtualWedgeInfo& from);
  
  inline RT_MS_MonteCarloVirtualWedgeInfo& operator=(const RT_MS_MonteCarloVirtualWedgeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MonteCarloVirtualWedgeInfo& default_instance();
  
  void Swap(RT_MS_MonteCarloVirtualWedgeInfo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MonteCarloVirtualWedgeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MonteCarloVirtualWedgeInfo& from);
  void MergeFrom(const RT_MS_MonteCarloVirtualWedgeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string virtualUid = 1;
  inline bool has_virtualuid() const;
  inline void clear_virtualuid();
  static const int kVirtualUidFieldNumber = 1;
  inline const ::std::string& virtualuid() const;
  inline void set_virtualuid(const ::std::string& value);
  inline void set_virtualuid(const char* value);
  inline void set_virtualuid(const char* value, size_t size);
  inline ::std::string* mutable_virtualuid();
  inline ::std::string* release_virtualuid();
  
  // optional string goldenUID = 2;
  inline bool has_goldenuid() const;
  inline void clear_goldenuid();
  static const int kGoldenUIDFieldNumber = 2;
  inline const ::std::string& goldenuid() const;
  inline void set_goldenuid(const ::std::string& value);
  inline void set_goldenuid(const char* value);
  inline void set_goldenuid(const char* value, size_t size);
  inline ::std::string* mutable_goldenuid();
  inline ::std::string* release_goldenuid();
  
  // repeated .ms.proto.RT_MS_MonteCarloVirtualWedgeField virtualWedgeFieldList = 3;
  inline int virtualwedgefieldlist_size() const;
  inline void clear_virtualwedgefieldlist();
  static const int kVirtualWedgeFieldListFieldNumber = 3;
  inline const ::ms::proto::RT_MS_MonteCarloVirtualWedgeField& virtualwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeField* mutable_virtualwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeField* add_virtualwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeField >&
      virtualwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeField >*
      mutable_virtualwedgefieldlist();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MonteCarloVirtualWedgeInfo)
 private:
  inline void set_has_virtualuid();
  inline void clear_has_virtualuid();
  inline void set_has_goldenuid();
  inline void clear_has_goldenuid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* virtualuid_;
  ::std::string* goldenuid_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeField > virtualwedgefieldlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MonteCarloVirtualWedgeInfo* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MonteCarloPhysicalWedgeField : public ::google::protobuf::Message {
 public:
  RT_MS_MonteCarloPhysicalWedgeField();
  virtual ~RT_MS_MonteCarloPhysicalWedgeField();
  
  RT_MS_MonteCarloPhysicalWedgeField(const RT_MS_MonteCarloPhysicalWedgeField& from);
  
  inline RT_MS_MonteCarloPhysicalWedgeField& operator=(const RT_MS_MonteCarloPhysicalWedgeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MonteCarloPhysicalWedgeField& default_instance();
  
  void Swap(RT_MS_MonteCarloPhysicalWedgeField* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MonteCarloPhysicalWedgeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MonteCarloPhysicalWedgeField& from);
  void MergeFrom(const RT_MS_MonteCarloPhysicalWedgeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string wedgeId = 1;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 1;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional string wedgeType = 2;
  inline bool has_wedgetype() const;
  inline void clear_wedgetype();
  static const int kWedgeTypeFieldNumber = 2;
  inline const ::std::string& wedgetype() const;
  inline void set_wedgetype(const ::std::string& value);
  inline void set_wedgetype(const char* value);
  inline void set_wedgetype(const char* value, size_t size);
  inline ::std::string* mutable_wedgetype();
  inline ::std::string* release_wedgetype();
  
  // optional float mu = 3;
  inline bool has_mu() const;
  inline void clear_mu();
  static const int kMuFieldNumber = 3;
  inline float mu() const;
  inline void set_mu(float value);
  
  // optional float dmudx = 4;
  inline bool has_dmudx() const;
  inline void clear_dmudx();
  static const int kDmudxFieldNumber = 4;
  inline float dmudx() const;
  inline void set_dmudx(float value);
  
  // optional float dmudr = 5;
  inline bool has_dmudr() const;
  inline void clear_dmudr();
  static const int kDmudrFieldNumber = 5;
  inline float dmudr() const;
  inline void set_dmudr(float value);
  
  // optional float dmuda = 6;
  inline bool has_dmuda() const;
  inline void clear_dmuda();
  static const int kDmudaFieldNumber = 6;
  inline float dmuda() const;
  inline void set_dmuda(float value);
  
  // optional float hvlSlope = 7;
  inline bool has_hvlslope() const;
  inline void clear_hvlslope();
  static const int kHvlSlopeFieldNumber = 7;
  inline float hvlslope() const;
  inline void set_hvlslope(float value);
  
  // optional float Carriermu = 8;
  inline bool has_carriermu() const;
  inline void clear_carriermu();
  static const int kCarriermuFieldNumber = 8;
  inline float carriermu() const;
  inline void set_carriermu(float value);
  
  // optional float Carrierdmudx = 9;
  inline bool has_carrierdmudx() const;
  inline void clear_carrierdmudx();
  static const int kCarrierdmudxFieldNumber = 9;
  inline float carrierdmudx() const;
  inline void set_carrierdmudx(float value);
  
  // optional float Carrierdmudr = 10;
  inline bool has_carrierdmudr() const;
  inline void clear_carrierdmudr();
  static const int kCarrierdmudrFieldNumber = 10;
  inline float carrierdmudr() const;
  inline void set_carrierdmudr(float value);
  
  // optional float Carrierdmuda = 11;
  inline bool has_carrierdmuda() const;
  inline void clear_carrierdmuda();
  static const int kCarrierdmudaFieldNumber = 11;
  inline float carrierdmuda() const;
  inline void set_carrierdmuda(float value);
  
  // optional float CarrierhvlSlope = 12;
  inline bool has_carrierhvlslope() const;
  inline void clear_carrierhvlslope();
  static const int kCarrierhvlSlopeFieldNumber = 12;
  inline float carrierhvlslope() const;
  inline void set_carrierhvlslope(float value);
  
  // optional float wedgeThick = 13;
  inline bool has_wedgethick() const;
  inline void clear_wedgethick();
  static const int kWedgeThickFieldNumber = 13;
  inline float wedgethick() const;
  inline void set_wedgethick(float value);
  
  // optional float carrierThick = 14;
  inline bool has_carrierthick() const;
  inline void clear_carrierthick();
  static const int kCarrierThickFieldNumber = 14;
  inline float carrierthick() const;
  inline void set_carrierthick(float value);
  
  // repeated .ms.proto.RT_MS_ContourVerter weightContourVerterList = 15;
  inline int weightcontourverterlist_size() const;
  inline void clear_weightcontourverterlist();
  static const int kWeightContourVerterListFieldNumber = 15;
  inline const ::ms::proto::RT_MS_ContourVerter& weightcontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_ContourVerter* mutable_weightcontourverterlist(int index);
  inline ::ms::proto::RT_MS_ContourVerter* add_weightcontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >&
      weightcontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >*
      mutable_weightcontourverterlist();
  
  // repeated .ms.proto.RT_MS_ContourVerter carrierContourVerterList = 16;
  inline int carriercontourverterlist_size() const;
  inline void clear_carriercontourverterlist();
  static const int kCarrierContourVerterListFieldNumber = 16;
  inline const ::ms::proto::RT_MS_ContourVerter& carriercontourverterlist(int index) const;
  inline ::ms::proto::RT_MS_ContourVerter* mutable_carriercontourverterlist(int index);
  inline ::ms::proto::RT_MS_ContourVerter* add_carriercontourverterlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >&
      carriercontourverterlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >*
      mutable_carriercontourverterlist();
  
  // optional string wedgeUID = 17;
  inline bool has_wedgeuid() const;
  inline void clear_wedgeuid();
  static const int kWedgeUIDFieldNumber = 17;
  inline const ::std::string& wedgeuid() const;
  inline void set_wedgeuid(const ::std::string& value);
  inline void set_wedgeuid(const char* value);
  inline void set_wedgeuid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeuid();
  inline ::std::string* release_wedgeuid();
  
  // optional string carrierUID = 18;
  inline bool has_carrieruid() const;
  inline void clear_carrieruid();
  static const int kCarrierUIDFieldNumber = 18;
  inline const ::std::string& carrieruid() const;
  inline void set_carrieruid(const ::std::string& value);
  inline void set_carrieruid(const char* value);
  inline void set_carrieruid(const char* value, size_t size);
  inline ::std::string* mutable_carrieruid();
  inline ::std::string* release_carrieruid();
  
  // optional string contourUID1 = 19;
  inline bool has_contouruid1() const;
  inline void clear_contouruid1();
  static const int kContourUID1FieldNumber = 19;
  inline const ::std::string& contouruid1() const;
  inline void set_contouruid1(const ::std::string& value);
  inline void set_contouruid1(const char* value);
  inline void set_contouruid1(const char* value, size_t size);
  inline ::std::string* mutable_contouruid1();
  inline ::std::string* release_contouruid1();
  
  // optional string contourUID2 = 20;
  inline bool has_contouruid2() const;
  inline void clear_contouruid2();
  static const int kContourUID2FieldNumber = 20;
  inline const ::std::string& contouruid2() const;
  inline void set_contouruid2(const ::std::string& value);
  inline void set_contouruid2(const char* value);
  inline void set_contouruid2(const char* value, size_t size);
  inline ::std::string* mutable_contouruid2();
  inline ::std::string* release_contouruid2();
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MonteCarloPhysicalWedgeField)
 private:
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_wedgetype();
  inline void clear_has_wedgetype();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_dmudx();
  inline void clear_has_dmudx();
  inline void set_has_dmudr();
  inline void clear_has_dmudr();
  inline void set_has_dmuda();
  inline void clear_has_dmuda();
  inline void set_has_hvlslope();
  inline void clear_has_hvlslope();
  inline void set_has_carriermu();
  inline void clear_has_carriermu();
  inline void set_has_carrierdmudx();
  inline void clear_has_carrierdmudx();
  inline void set_has_carrierdmudr();
  inline void clear_has_carrierdmudr();
  inline void set_has_carrierdmuda();
  inline void clear_has_carrierdmuda();
  inline void set_has_carrierhvlslope();
  inline void clear_has_carrierhvlslope();
  inline void set_has_wedgethick();
  inline void clear_has_wedgethick();
  inline void set_has_carrierthick();
  inline void clear_has_carrierthick();
  inline void set_has_wedgeuid();
  inline void clear_has_wedgeuid();
  inline void set_has_carrieruid();
  inline void clear_has_carrieruid();
  inline void set_has_contouruid1();
  inline void clear_has_contouruid1();
  inline void set_has_contouruid2();
  inline void clear_has_contouruid2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* wedgeid_;
  ::std::string* wedgetype_;
  float mu_;
  float dmudx_;
  float dmudr_;
  float dmuda_;
  float hvlslope_;
  float carriermu_;
  float carrierdmudx_;
  float carrierdmudr_;
  float carrierdmuda_;
  float carrierhvlslope_;
  float wedgethick_;
  float carrierthick_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter > weightcontourverterlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter > carriercontourverterlist_;
  ::std::string* wedgeuid_;
  ::std::string* carrieruid_;
  ::std::string* contouruid1_;
  ::std::string* contouruid2_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MonteCarloPhysicalWedgeField* default_instance_;
};
// -------------------------------------------------------------------

class RT_MS_MonteCarlo : public ::google::protobuf::Message {
 public:
  RT_MS_MonteCarlo();
  virtual ~RT_MS_MonteCarlo();
  
  RT_MS_MonteCarlo(const RT_MS_MonteCarlo& from);
  
  inline RT_MS_MonteCarlo& operator=(const RT_MS_MonteCarlo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RT_MS_MonteCarlo& default_instance();
  
  void Swap(RT_MS_MonteCarlo* other);
  
  // implements Message ----------------------------------------------
  
  RT_MS_MonteCarlo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RT_MS_MonteCarlo& from);
  void MergeFrom(const RT_MS_MonteCarlo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string parentuid = 2;
  inline bool has_parentuid() const;
  inline void clear_parentuid();
  static const int kParentuidFieldNumber = 2;
  inline const ::std::string& parentuid() const;
  inline void set_parentuid(const ::std::string& value);
  inline void set_parentuid(const char* value);
  inline void set_parentuid(const char* value, size_t size);
  inline ::std::string* mutable_parentuid();
  inline ::std::string* release_parentuid();
  
  // optional float xJawTopPosition = 3;
  inline bool has_xjawtopposition() const;
  inline void clear_xjawtopposition();
  static const int kXJawTopPositionFieldNumber = 3;
  inline float xjawtopposition() const;
  inline void set_xjawtopposition(float value);
  
  // optional float yJawTopPosition = 4;
  inline bool has_yjawtopposition() const;
  inline void clear_yjawtopposition();
  static const int kYJawTopPositionFieldNumber = 4;
  inline float yjawtopposition() const;
  inline void set_yjawtopposition(float value);
  
  // optional float xJawThickness = 5;
  inline bool has_xjawthickness() const;
  inline void clear_xjawthickness();
  static const int kXJawThicknessFieldNumber = 5;
  inline float xjawthickness() const;
  inline void set_xjawthickness(float value);
  
  // optional float yJawThickness = 6;
  inline bool has_yjawthickness() const;
  inline void clear_yjawthickness();
  static const int kYJawThicknessFieldNumber = 6;
  inline float yjawthickness() const;
  inline void set_yjawthickness(float value);
  
  // optional float mlcCenterPosition = 7;
  inline bool has_mlccenterposition() const;
  inline void clear_mlccenterposition();
  static const int kMlcCenterPositionFieldNumber = 7;
  inline float mlccenterposition() const;
  inline void set_mlccenterposition(float value);
  
  // optional float mlcThickness = 8;
  inline bool has_mlcthickness() const;
  inline void clear_mlcthickness();
  static const int kMlcThicknessFieldNumber = 8;
  inline float mlcthickness() const;
  inline void set_mlcthickness(float value);
  
  // optional float mlcLeafendRadius = 9;
  inline bool has_mlcleafendradius() const;
  inline void clear_mlcleafendradius();
  static const int kMlcLeafendRadiusFieldNumber = 9;
  inline float mlcleafendradius() const;
  inline void set_mlcleafendradius(float value);
  
  // optional float airGapWidth = 10;
  inline bool has_airgapwidth() const;
  inline void clear_airgapwidth();
  static const int kAirGapWidthFieldNumber = 10;
  inline float airgapwidth() const;
  inline void set_airgapwidth(float value);
  
  // optional float tongueGrooveWidth = 11;
  inline bool has_tonguegroovewidth() const;
  inline void clear_tonguegroovewidth();
  static const int kTongueGrooveWidthFieldNumber = 11;
  inline float tonguegroovewidth() const;
  inline void set_tonguegroovewidth(float value);
  
  // optional float muCorrectionFactor = 12;
  inline bool has_mucorrectionfactor() const;
  inline void clear_mucorrectionfactor();
  static const int kMuCorrectionFactorFieldNumber = 12;
  inline float mucorrectionfactor() const;
  inline void set_mucorrectionfactor(float value);
  
  // optional float minElectronEnergy = 13;
  inline bool has_minelectronenergy() const;
  inline void clear_minelectronenergy();
  static const int kMinElectronEnergyFieldNumber = 13;
  inline float minelectronenergy() const;
  inline void set_minelectronenergy(float value);
  
  // optional float maxElectronEnergy = 14;
  inline bool has_maxelectronenergy() const;
  inline void clear_maxelectronenergy();
  static const int kMaxElectronEnergyFieldNumber = 14;
  inline float maxelectronenergy() const;
  inline void set_maxelectronenergy(float value);
  
  // optional float normTen = 15;
  inline bool has_normten() const;
  inline void clear_normten();
  static const int kNormTenFieldNumber = 15;
  inline float normten() const;
  inline void set_normten(float value);
  
  // optional string oarDepth1 = 16;
  inline bool has_oardepth1() const;
  inline void clear_oardepth1();
  static const int kOarDepth1FieldNumber = 16;
  inline const ::std::string& oardepth1() const;
  inline void set_oardepth1(const ::std::string& value);
  inline void set_oardepth1(const char* value);
  inline void set_oardepth1(const char* value, size_t size);
  inline ::std::string* mutable_oardepth1();
  inline ::std::string* release_oardepth1();
  
  // optional string oarDepth2 = 17;
  inline bool has_oardepth2() const;
  inline void clear_oardepth2();
  static const int kOarDepth2FieldNumber = 17;
  inline const ::std::string& oardepth2() const;
  inline void set_oardepth2(const ::std::string& value);
  inline void set_oardepth2(const char* value);
  inline void set_oardepth2(const char* value, size_t size);
  inline ::std::string* mutable_oardepth2();
  inline ::std::string* release_oardepth2();
  
  // optional string energyValue = 18;
  inline bool has_energyvalue() const;
  inline void clear_energyvalue();
  static const int kEnergyValueFieldNumber = 18;
  inline const ::std::string& energyvalue() const;
  inline void set_energyvalue(const ::std::string& value);
  inline void set_energyvalue(const char* value);
  inline void set_energyvalue(const char* value, size_t size);
  inline ::std::string* mutable_energyvalue();
  inline ::std::string* release_energyvalue();
  
  // optional bool electronContaminationFlag = 19;
  inline bool has_electroncontaminationflag() const;
  inline void clear_electroncontaminationflag();
  static const int kElectronContaminationFlagFieldNumber = 19;
  inline bool electroncontaminationflag() const;
  inline void set_electroncontaminationflag(bool value);
  
  // optional float electronMaxDepth = 20;
  inline bool has_electronmaxdepth() const;
  inline void clear_electronmaxdepth();
  static const int kElectronMaxDepthFieldNumber = 20;
  inline float electronmaxdepth() const;
  inline void set_electronmaxdepth(float value);
  
  // optional float surfaceDose = 21;
  inline bool has_surfacedose() const;
  inline void clear_surfacedose();
  static const int kSurfaceDoseFieldNumber = 21;
  inline float surfacedose() const;
  inline void set_surfacedose(float value);
  
  // optional float depthCoefficientK = 22;
  inline bool has_depthcoefficientk() const;
  inline void clear_depthcoefficientk();
  static const int kDepthCoefficientKFieldNumber = 22;
  inline float depthcoefficientk() const;
  inline void set_depthcoefficientk(float value);
  
  // optional float offaxisCoefficientA = 23;
  inline bool has_offaxiscoefficienta() const;
  inline void clear_offaxiscoefficienta();
  static const int kOffaxisCoefficientAFieldNumber = 23;
  inline float offaxiscoefficienta() const;
  inline void set_offaxiscoefficienta(float value);
  
  // optional float df = 24;
  inline bool has_df() const;
  inline void clear_df();
  static const int kDfFieldNumber = 24;
  inline float df() const;
  inline void set_df(float value);
  
  // optional float sf = 25;
  inline bool has_sf() const;
  inline void clear_sf();
  static const int kSfFieldNumber = 25;
  inline float sf() const;
  inline void set_sf(float value);
  
  // optional float cOne = 26;
  inline bool has_cone() const;
  inline void clear_cone();
  static const int kCOneFieldNumber = 26;
  inline float cone() const;
  inline void set_cone(float value);
  
  // optional float cTwo = 27;
  inline bool has_ctwo() const;
  inline void clear_ctwo();
  static const int kCTwoFieldNumber = 27;
  inline float ctwo() const;
  inline void set_ctwo(float value);
  
  // optional float cThree = 28;
  inline bool has_cthree() const;
  inline void clear_cthree();
  static const int kCThreeFieldNumber = 28;
  inline float cthree() const;
  inline void set_cthree(float value);
  
  // repeated .ms.proto.RT_MS_Spectrum spectrumList = 29;
  inline int spectrumlist_size() const;
  inline void clear_spectrumlist();
  static const int kSpectrumListFieldNumber = 29;
  inline const ::ms::proto::RT_MS_Spectrum& spectrumlist(int index) const;
  inline ::ms::proto::RT_MS_Spectrum* mutable_spectrumlist(int index);
  inline ::ms::proto::RT_MS_Spectrum* add_spectrumlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_Spectrum >&
      spectrumlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_Spectrum >*
      mutable_spectrumlist();
  
  // repeated .ms.proto.RT_MS_FieldSize fieldSizeList = 30;
  inline int fieldsizelist_size() const;
  inline void clear_fieldsizelist();
  static const int kFieldSizeListFieldNumber = 30;
  inline const ::ms::proto::RT_MS_FieldSize& fieldsizelist(int index) const;
  inline ::ms::proto::RT_MS_FieldSize* mutable_fieldsizelist(int index);
  inline ::ms::proto::RT_MS_FieldSize* add_fieldsizelist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_FieldSize >&
      fieldsizelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_FieldSize >*
      mutable_fieldsizelist();
  
  // repeated .ms.proto.RT_MS_MonteCarloPhysicalWedgeField physicalWedgeFieldList = 31;
  inline int physicalwedgefieldlist_size() const;
  inline void clear_physicalwedgefieldlist();
  static const int kPhysicalWedgeFieldListFieldNumber = 31;
  inline const ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField& physicalwedgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField* mutable_physicalwedgefieldlist(int index);
  inline ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField* add_physicalwedgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField >&
      physicalwedgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField >*
      mutable_physicalwedgefieldlist();
  
  // repeated .ms.proto.RT_MS_MonteCarloVirtualWedgeInfo virtualWeidgeFieldList = 32;
  inline int virtualweidgefieldlist_size() const;
  inline void clear_virtualweidgefieldlist();
  static const int kVirtualWeidgeFieldListFieldNumber = 32;
  inline const ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo& virtualweidgefieldlist(int index) const;
  inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo* mutable_virtualweidgefieldlist(int index);
  inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo* add_virtualweidgefieldlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo >&
      virtualweidgefieldlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo >*
      mutable_virtualweidgefieldlist();
  
  // optional string monterCarloName = 33;
  inline bool has_montercarloname() const;
  inline void clear_montercarloname();
  static const int kMonterCarloNameFieldNumber = 33;
  inline const ::std::string& montercarloname() const;
  inline void set_montercarloname(const ::std::string& value);
  inline void set_montercarloname(const char* value);
  inline void set_montercarloname(const char* value, size_t size);
  inline ::std::string* mutable_montercarloname();
  inline ::std::string* release_montercarloname();
  
  // optional string wedgeId = 34;
  inline bool has_wedgeid() const;
  inline void clear_wedgeid();
  static const int kWedgeIdFieldNumber = 34;
  inline const ::std::string& wedgeid() const;
  inline void set_wedgeid(const ::std::string& value);
  inline void set_wedgeid(const char* value);
  inline void set_wedgeid(const char* value, size_t size);
  inline ::std::string* mutable_wedgeid();
  inline ::std::string* release_wedgeid();
  
  // optional string filePath = 35;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilePathFieldNumber = 35;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  
  // optional string accessoryUID = 36;
  inline bool has_accessoryuid() const;
  inline void clear_accessoryuid();
  static const int kAccessoryUIDFieldNumber = 36;
  inline const ::std::string& accessoryuid() const;
  inline void set_accessoryuid(const ::std::string& value);
  inline void set_accessoryuid(const char* value);
  inline void set_accessoryuid(const char* value, size_t size);
  inline ::std::string* mutable_accessoryuid();
  inline ::std::string* release_accessoryuid();
  
  // optional int32 algType = 37;
  inline bool has_algtype() const;
  inline void clear_algtype();
  static const int kAlgTypeFieldNumber = 37;
  inline ::google::protobuf::int32 algtype() const;
  inline void set_algtype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:ms.proto.RT_MS_MonteCarlo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_parentuid();
  inline void clear_has_parentuid();
  inline void set_has_xjawtopposition();
  inline void clear_has_xjawtopposition();
  inline void set_has_yjawtopposition();
  inline void clear_has_yjawtopposition();
  inline void set_has_xjawthickness();
  inline void clear_has_xjawthickness();
  inline void set_has_yjawthickness();
  inline void clear_has_yjawthickness();
  inline void set_has_mlccenterposition();
  inline void clear_has_mlccenterposition();
  inline void set_has_mlcthickness();
  inline void clear_has_mlcthickness();
  inline void set_has_mlcleafendradius();
  inline void clear_has_mlcleafendradius();
  inline void set_has_airgapwidth();
  inline void clear_has_airgapwidth();
  inline void set_has_tonguegroovewidth();
  inline void clear_has_tonguegroovewidth();
  inline void set_has_mucorrectionfactor();
  inline void clear_has_mucorrectionfactor();
  inline void set_has_minelectronenergy();
  inline void clear_has_minelectronenergy();
  inline void set_has_maxelectronenergy();
  inline void clear_has_maxelectronenergy();
  inline void set_has_normten();
  inline void clear_has_normten();
  inline void set_has_oardepth1();
  inline void clear_has_oardepth1();
  inline void set_has_oardepth2();
  inline void clear_has_oardepth2();
  inline void set_has_energyvalue();
  inline void clear_has_energyvalue();
  inline void set_has_electroncontaminationflag();
  inline void clear_has_electroncontaminationflag();
  inline void set_has_electronmaxdepth();
  inline void clear_has_electronmaxdepth();
  inline void set_has_surfacedose();
  inline void clear_has_surfacedose();
  inline void set_has_depthcoefficientk();
  inline void clear_has_depthcoefficientk();
  inline void set_has_offaxiscoefficienta();
  inline void clear_has_offaxiscoefficienta();
  inline void set_has_df();
  inline void clear_has_df();
  inline void set_has_sf();
  inline void clear_has_sf();
  inline void set_has_cone();
  inline void clear_has_cone();
  inline void set_has_ctwo();
  inline void clear_has_ctwo();
  inline void set_has_cthree();
  inline void clear_has_cthree();
  inline void set_has_montercarloname();
  inline void clear_has_montercarloname();
  inline void set_has_wedgeid();
  inline void clear_has_wedgeid();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_accessoryuid();
  inline void clear_has_accessoryuid();
  inline void set_has_algtype();
  inline void clear_has_algtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* uid_;
  ::std::string* parentuid_;
  float xjawtopposition_;
  float yjawtopposition_;
  float xjawthickness_;
  float yjawthickness_;
  float mlccenterposition_;
  float mlcthickness_;
  float mlcleafendradius_;
  float airgapwidth_;
  float tonguegroovewidth_;
  float mucorrectionfactor_;
  float minelectronenergy_;
  float maxelectronenergy_;
  ::std::string* oardepth1_;
  ::std::string* oardepth2_;
  float normten_;
  bool electroncontaminationflag_;
  ::std::string* energyvalue_;
  float electronmaxdepth_;
  float surfacedose_;
  float depthcoefficientk_;
  float offaxiscoefficienta_;
  float df_;
  float sf_;
  float cone_;
  float ctwo_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_Spectrum > spectrumlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_FieldSize > fieldsizelist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField > physicalwedgefieldlist_;
  ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo > virtualweidgefieldlist_;
  float cthree_;
  ::google::protobuf::int32 algtype_;
  ::std::string* montercarloname_;
  ::std::string* wedgeid_;
  ::std::string* filepath_;
  ::std::string* accessoryuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];
  
  friend void  protobuf_AddDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_AssignDesc_rt_5fms_5fmontecarlo_2eproto();
  friend void protobuf_ShutdownFile_rt_5fms_5fmontecarlo_2eproto();
  
  void InitAsDefaultInstance();
  static RT_MS_MonteCarlo* default_instance_;
};
// ===================================================================


// ===================================================================

// RT_MS_Spectrum

// optional string uid = 1;
inline bool RT_MS_Spectrum::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_Spectrum::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_Spectrum::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_Spectrum::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_Spectrum::uid() const {
  return *uid_;
}
inline void RT_MS_Spectrum::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_Spectrum::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_Spectrum::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_Spectrum::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_Spectrum::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float energy = 2;
inline bool RT_MS_Spectrum::has_energy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_Spectrum::set_has_energy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_Spectrum::clear_has_energy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_Spectrum::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float RT_MS_Spectrum::energy() const {
  return energy_;
}
inline void RT_MS_Spectrum::set_energy(float value) {
  set_has_energy();
  energy_ = value;
}

// optional float weight = 3;
inline bool RT_MS_Spectrum::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_Spectrum::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_Spectrum::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_Spectrum::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float RT_MS_Spectrum::weight() const {
  return weight_;
}
inline void RT_MS_Spectrum::set_weight(float value) {
  set_has_weight();
  weight_ = value;
}

// -------------------------------------------------------------------

// RT_MS_FieldSize

// optional string uid = 1;
inline bool RT_MS_FieldSize::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_FieldSize::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_FieldSize::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_FieldSize::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_FieldSize::uid() const {
  return *uid_;
}
inline void RT_MS_FieldSize::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_FieldSize::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_FieldSize::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_FieldSize::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_FieldSize::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float fieldSize = 2;
inline bool RT_MS_FieldSize::has_fieldsize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_FieldSize::set_has_fieldsize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_FieldSize::clear_has_fieldsize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_FieldSize::clear_fieldsize() {
  fieldsize_ = 0;
  clear_has_fieldsize();
}
inline float RT_MS_FieldSize::fieldsize() const {
  return fieldsize_;
}
inline void RT_MS_FieldSize::set_fieldsize(float value) {
  set_has_fieldsize();
  fieldsize_ = value;
}

// optional float absoluteFactor = 3;
inline bool RT_MS_FieldSize::has_absolutefactor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_FieldSize::set_has_absolutefactor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_FieldSize::clear_has_absolutefactor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_FieldSize::clear_absolutefactor() {
  absolutefactor_ = 0;
  clear_has_absolutefactor();
}
inline float RT_MS_FieldSize::absolutefactor() const {
  return absolutefactor_;
}
inline void RT_MS_FieldSize::set_absolutefactor(float value) {
  set_has_absolutefactor();
  absolutefactor_ = value;
}

// -------------------------------------------------------------------

// RT_MS_ContourVerter

// optional string uid = 1;
inline bool RT_MS_ContourVerter::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_ContourVerter::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_ContourVerter::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_ContourVerter::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_ContourVerter::uid() const {
  return *uid_;
}
inline void RT_MS_ContourVerter::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_ContourVerter::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_ContourVerter::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_ContourVerter::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_ContourVerter::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float ContourVerterx = 2;
inline bool RT_MS_ContourVerter::has_contourverterx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_ContourVerter::set_has_contourverterx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_ContourVerter::clear_has_contourverterx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_ContourVerter::clear_contourverterx() {
  contourverterx_ = 0;
  clear_has_contourverterx();
}
inline float RT_MS_ContourVerter::contourverterx() const {
  return contourverterx_;
}
inline void RT_MS_ContourVerter::set_contourverterx(float value) {
  set_has_contourverterx();
  contourverterx_ = value;
}

// optional float ContourVertery = 3;
inline bool RT_MS_ContourVerter::has_contourvertery() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_ContourVerter::set_has_contourvertery() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_ContourVerter::clear_has_contourvertery() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_ContourVerter::clear_contourvertery() {
  contourvertery_ = 0;
  clear_has_contourvertery();
}
inline float RT_MS_ContourVerter::contourvertery() const {
  return contourvertery_;
}
inline void RT_MS_ContourVerter::set_contourvertery(float value) {
  set_has_contourvertery();
  contourvertery_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MonteCarloVirtualWedgeField

// optional string uid = 1;
inline bool RT_MS_MonteCarloVirtualWedgeField::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_MonteCarloVirtualWedgeField::uid() const {
  return *uid_;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeField::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeField::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float collimatorX1Position = 2;
inline bool RT_MS_MonteCarloVirtualWedgeField::has_collimatorx1position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_has_collimatorx1position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_has_collimatorx1position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_collimatorx1position() {
  collimatorx1position_ = 0;
  clear_has_collimatorx1position();
}
inline float RT_MS_MonteCarloVirtualWedgeField::collimatorx1position() const {
  return collimatorx1position_;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_collimatorx1position(float value) {
  set_has_collimatorx1position();
  collimatorx1position_ = value;
}

// optional float collimatorX2Position = 3;
inline bool RT_MS_MonteCarloVirtualWedgeField::has_collimatorx2position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_has_collimatorx2position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_has_collimatorx2position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_collimatorx2position() {
  collimatorx2position_ = 0;
  clear_has_collimatorx2position();
}
inline float RT_MS_MonteCarloVirtualWedgeField::collimatorx2position() const {
  return collimatorx2position_;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_collimatorx2position(float value) {
  set_has_collimatorx2position();
  collimatorx2position_ = value;
}

// optional float relativeMU = 4;
inline bool RT_MS_MonteCarloVirtualWedgeField::has_relativemu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_has_relativemu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_has_relativemu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_relativemu() {
  relativemu_ = 0;
  clear_has_relativemu();
}
inline float RT_MS_MonteCarloVirtualWedgeField::relativemu() const {
  return relativemu_;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_relativemu(float value) {
  set_has_relativemu();
  relativemu_ = value;
}

// optional float correctionFactor = 5;
inline bool RT_MS_MonteCarloVirtualWedgeField::has_correctionfactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_has_correctionfactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_has_correctionfactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MonteCarloVirtualWedgeField::clear_correctionfactor() {
  correctionfactor_ = 0;
  clear_has_correctionfactor();
}
inline float RT_MS_MonteCarloVirtualWedgeField::correctionfactor() const {
  return correctionfactor_;
}
inline void RT_MS_MonteCarloVirtualWedgeField::set_correctionfactor(float value) {
  set_has_correctionfactor();
  correctionfactor_ = value;
}

// -------------------------------------------------------------------

// RT_MS_MonteCarloVirtualWedgeInfo

// optional string virtualUid = 1;
inline bool RT_MS_MonteCarloVirtualWedgeInfo::has_virtualuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_has_virtualuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::clear_has_virtualuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::clear_virtualuid() {
  if (virtualuid_ != &::google::protobuf::internal::kEmptyString) {
    virtualuid_->clear();
  }
  clear_has_virtualuid();
}
inline const ::std::string& RT_MS_MonteCarloVirtualWedgeInfo::virtualuid() const {
  return *virtualuid_;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_virtualuid(const ::std::string& value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_virtualuid(const char* value) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_virtualuid(const char* value, size_t size) {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  virtualuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeInfo::mutable_virtualuid() {
  set_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    virtualuid_ = new ::std::string;
  }
  return virtualuid_;
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeInfo::release_virtualuid() {
  clear_has_virtualuid();
  if (virtualuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = virtualuid_;
    virtualuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string goldenUID = 2;
inline bool RT_MS_MonteCarloVirtualWedgeInfo::has_goldenuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_has_goldenuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::clear_has_goldenuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::clear_goldenuid() {
  if (goldenuid_ != &::google::protobuf::internal::kEmptyString) {
    goldenuid_->clear();
  }
  clear_has_goldenuid();
}
inline const ::std::string& RT_MS_MonteCarloVirtualWedgeInfo::goldenuid() const {
  return *goldenuid_;
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_goldenuid(const ::std::string& value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_goldenuid(const char* value) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(value);
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::set_goldenuid(const char* value, size_t size) {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  goldenuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeInfo::mutable_goldenuid() {
  set_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    goldenuid_ = new ::std::string;
  }
  return goldenuid_;
}
inline ::std::string* RT_MS_MonteCarloVirtualWedgeInfo::release_goldenuid() {
  clear_has_goldenuid();
  if (goldenuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = goldenuid_;
    goldenuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .ms.proto.RT_MS_MonteCarloVirtualWedgeField virtualWedgeFieldList = 3;
inline int RT_MS_MonteCarloVirtualWedgeInfo::virtualwedgefieldlist_size() const {
  return virtualwedgefieldlist_.size();
}
inline void RT_MS_MonteCarloVirtualWedgeInfo::clear_virtualwedgefieldlist() {
  virtualwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_MonteCarloVirtualWedgeField& RT_MS_MonteCarloVirtualWedgeInfo::virtualwedgefieldlist(int index) const {
  return virtualwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeField* RT_MS_MonteCarloVirtualWedgeInfo::mutable_virtualwedgefieldlist(int index) {
  return virtualwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeField* RT_MS_MonteCarloVirtualWedgeInfo::add_virtualwedgefieldlist() {
  return virtualwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeField >&
RT_MS_MonteCarloVirtualWedgeInfo::virtualwedgefieldlist() const {
  return virtualwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeField >*
RT_MS_MonteCarloVirtualWedgeInfo::mutable_virtualwedgefieldlist() {
  return &virtualwedgefieldlist_;
}

// -------------------------------------------------------------------

// RT_MS_MonteCarloPhysicalWedgeField

// optional string wedgeId = 1;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_wedgeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_wedgeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_wedgeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeType = 2;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_wedgetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_wedgetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_wedgetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_wedgetype() {
  if (wedgetype_ != &::google::protobuf::internal::kEmptyString) {
    wedgetype_->clear();
  }
  clear_has_wedgetype();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::wedgetype() const {
  return *wedgetype_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgetype(const ::std::string& value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgetype(const char* value) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgetype(const char* value, size_t size) {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  wedgetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_wedgetype() {
  set_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    wedgetype_ = new ::std::string;
  }
  return wedgetype_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_wedgetype() {
  clear_has_wedgetype();
  if (wedgetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgetype_;
    wedgetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float mu = 3;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_mu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_mu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_mu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_mu() {
  mu_ = 0;
  clear_has_mu();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::mu() const {
  return mu_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_mu(float value) {
  set_has_mu();
  mu_ = value;
}

// optional float dmudx = 4;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_dmudx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_dmudx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_dmudx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_dmudx() {
  dmudx_ = 0;
  clear_has_dmudx();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::dmudx() const {
  return dmudx_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_dmudx(float value) {
  set_has_dmudx();
  dmudx_ = value;
}

// optional float dmudr = 5;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_dmudr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_dmudr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_dmudr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_dmudr() {
  dmudr_ = 0;
  clear_has_dmudr();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::dmudr() const {
  return dmudr_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_dmudr(float value) {
  set_has_dmudr();
  dmudr_ = value;
}

// optional float dmuda = 6;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_dmuda() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_dmuda() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_dmuda() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_dmuda() {
  dmuda_ = 0;
  clear_has_dmuda();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::dmuda() const {
  return dmuda_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_dmuda(float value) {
  set_has_dmuda();
  dmuda_ = value;
}

// optional float hvlSlope = 7;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_hvlslope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_hvlslope() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_hvlslope() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_hvlslope() {
  hvlslope_ = 0;
  clear_has_hvlslope();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::hvlslope() const {
  return hvlslope_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_hvlslope(float value) {
  set_has_hvlslope();
  hvlslope_ = value;
}

// optional float Carriermu = 8;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carriermu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carriermu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carriermu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carriermu() {
  carriermu_ = 0;
  clear_has_carriermu();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carriermu() const {
  return carriermu_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carriermu(float value) {
  set_has_carriermu();
  carriermu_ = value;
}

// optional float Carrierdmudx = 9;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrierdmudx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrierdmudx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrierdmudx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrierdmudx() {
  carrierdmudx_ = 0;
  clear_has_carrierdmudx();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carrierdmudx() const {
  return carrierdmudx_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrierdmudx(float value) {
  set_has_carrierdmudx();
  carrierdmudx_ = value;
}

// optional float Carrierdmudr = 10;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrierdmudr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrierdmudr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrierdmudr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrierdmudr() {
  carrierdmudr_ = 0;
  clear_has_carrierdmudr();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carrierdmudr() const {
  return carrierdmudr_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrierdmudr(float value) {
  set_has_carrierdmudr();
  carrierdmudr_ = value;
}

// optional float Carrierdmuda = 11;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrierdmuda() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrierdmuda() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrierdmuda() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrierdmuda() {
  carrierdmuda_ = 0;
  clear_has_carrierdmuda();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carrierdmuda() const {
  return carrierdmuda_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrierdmuda(float value) {
  set_has_carrierdmuda();
  carrierdmuda_ = value;
}

// optional float CarrierhvlSlope = 12;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrierhvlslope() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrierhvlslope() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrierhvlslope() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrierhvlslope() {
  carrierhvlslope_ = 0;
  clear_has_carrierhvlslope();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carrierhvlslope() const {
  return carrierhvlslope_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrierhvlslope(float value) {
  set_has_carrierhvlslope();
  carrierhvlslope_ = value;
}

// optional float wedgeThick = 13;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_wedgethick() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_wedgethick() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_wedgethick() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_wedgethick() {
  wedgethick_ = 0;
  clear_has_wedgethick();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::wedgethick() const {
  return wedgethick_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgethick(float value) {
  set_has_wedgethick();
  wedgethick_ = value;
}

// optional float carrierThick = 14;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrierthick() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrierthick() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrierthick() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrierthick() {
  carrierthick_ = 0;
  clear_has_carrierthick();
}
inline float RT_MS_MonteCarloPhysicalWedgeField::carrierthick() const {
  return carrierthick_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrierthick(float value) {
  set_has_carrierthick();
  carrierthick_ = value;
}

// repeated .ms.proto.RT_MS_ContourVerter weightContourVerterList = 15;
inline int RT_MS_MonteCarloPhysicalWedgeField::weightcontourverterlist_size() const {
  return weightcontourverterlist_.size();
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_weightcontourverterlist() {
  weightcontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_ContourVerter& RT_MS_MonteCarloPhysicalWedgeField::weightcontourverterlist(int index) const {
  return weightcontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_ContourVerter* RT_MS_MonteCarloPhysicalWedgeField::mutable_weightcontourverterlist(int index) {
  return weightcontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_ContourVerter* RT_MS_MonteCarloPhysicalWedgeField::add_weightcontourverterlist() {
  return weightcontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >&
RT_MS_MonteCarloPhysicalWedgeField::weightcontourverterlist() const {
  return weightcontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >*
RT_MS_MonteCarloPhysicalWedgeField::mutable_weightcontourverterlist() {
  return &weightcontourverterlist_;
}

// repeated .ms.proto.RT_MS_ContourVerter carrierContourVerterList = 16;
inline int RT_MS_MonteCarloPhysicalWedgeField::carriercontourverterlist_size() const {
  return carriercontourverterlist_.size();
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carriercontourverterlist() {
  carriercontourverterlist_.Clear();
}
inline const ::ms::proto::RT_MS_ContourVerter& RT_MS_MonteCarloPhysicalWedgeField::carriercontourverterlist(int index) const {
  return carriercontourverterlist_.Get(index);
}
inline ::ms::proto::RT_MS_ContourVerter* RT_MS_MonteCarloPhysicalWedgeField::mutable_carriercontourverterlist(int index) {
  return carriercontourverterlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_ContourVerter* RT_MS_MonteCarloPhysicalWedgeField::add_carriercontourverterlist() {
  return carriercontourverterlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >&
RT_MS_MonteCarloPhysicalWedgeField::carriercontourverterlist() const {
  return carriercontourverterlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_ContourVerter >*
RT_MS_MonteCarloPhysicalWedgeField::mutable_carriercontourverterlist() {
  return &carriercontourverterlist_;
}

// optional string wedgeUID = 17;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_wedgeuid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_wedgeuid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_wedgeuid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_wedgeuid() {
  if (wedgeuid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeuid_->clear();
  }
  clear_has_wedgeuid();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::wedgeuid() const {
  return *wedgeuid_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeuid(const ::std::string& value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeuid(const char* value) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_wedgeuid(const char* value, size_t size) {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  wedgeuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_wedgeuid() {
  set_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeuid_ = new ::std::string;
  }
  return wedgeuid_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_wedgeuid() {
  clear_has_wedgeuid();
  if (wedgeuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeuid_;
    wedgeuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string carrierUID = 18;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_carrieruid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_carrieruid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_carrieruid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_carrieruid() {
  if (carrieruid_ != &::google::protobuf::internal::kEmptyString) {
    carrieruid_->clear();
  }
  clear_has_carrieruid();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::carrieruid() const {
  return *carrieruid_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrieruid(const ::std::string& value) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrieruid(const char* value) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_carrieruid(const char* value, size_t size) {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  carrieruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_carrieruid() {
  set_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    carrieruid_ = new ::std::string;
  }
  return carrieruid_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_carrieruid() {
  clear_has_carrieruid();
  if (carrieruid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carrieruid_;
    carrieruid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contourUID1 = 19;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_contouruid1() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_contouruid1() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_contouruid1() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_contouruid1() {
  if (contouruid1_ != &::google::protobuf::internal::kEmptyString) {
    contouruid1_->clear();
  }
  clear_has_contouruid1();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::contouruid1() const {
  return *contouruid1_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid1(const ::std::string& value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid1(const char* value) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid1(const char* value, size_t size) {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  contouruid1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_contouruid1() {
  set_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    contouruid1_ = new ::std::string;
  }
  return contouruid1_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_contouruid1() {
  clear_has_contouruid1();
  if (contouruid1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid1_;
    contouruid1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string contourUID2 = 20;
inline bool RT_MS_MonteCarloPhysicalWedgeField::has_contouruid2() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_has_contouruid2() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_has_contouruid2() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::clear_contouruid2() {
  if (contouruid2_ != &::google::protobuf::internal::kEmptyString) {
    contouruid2_->clear();
  }
  clear_has_contouruid2();
}
inline const ::std::string& RT_MS_MonteCarloPhysicalWedgeField::contouruid2() const {
  return *contouruid2_;
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid2(const ::std::string& value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid2(const char* value) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(value);
}
inline void RT_MS_MonteCarloPhysicalWedgeField::set_contouruid2(const char* value, size_t size) {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  contouruid2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::mutable_contouruid2() {
  set_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    contouruid2_ = new ::std::string;
  }
  return contouruid2_;
}
inline ::std::string* RT_MS_MonteCarloPhysicalWedgeField::release_contouruid2() {
  clear_has_contouruid2();
  if (contouruid2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contouruid2_;
    contouruid2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RT_MS_MonteCarlo

// optional string uid = 1;
inline bool RT_MS_MonteCarlo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RT_MS_MonteCarlo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RT_MS_MonteCarlo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RT_MS_MonteCarlo::uid() const {
  return *uid_;
}
inline void RT_MS_MonteCarlo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RT_MS_MonteCarlo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string parentuid = 2;
inline bool RT_MS_MonteCarlo::has_parentuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_parentuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RT_MS_MonteCarlo::clear_has_parentuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RT_MS_MonteCarlo::clear_parentuid() {
  if (parentuid_ != &::google::protobuf::internal::kEmptyString) {
    parentuid_->clear();
  }
  clear_has_parentuid();
}
inline const ::std::string& RT_MS_MonteCarlo::parentuid() const {
  return *parentuid_;
}
inline void RT_MS_MonteCarlo::set_parentuid(const ::std::string& value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_parentuid(const char* value) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_parentuid(const char* value, size_t size) {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  parentuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_parentuid() {
  set_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    parentuid_ = new ::std::string;
  }
  return parentuid_;
}
inline ::std::string* RT_MS_MonteCarlo::release_parentuid() {
  clear_has_parentuid();
  if (parentuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = parentuid_;
    parentuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float xJawTopPosition = 3;
inline bool RT_MS_MonteCarlo::has_xjawtopposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_xjawtopposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RT_MS_MonteCarlo::clear_has_xjawtopposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RT_MS_MonteCarlo::clear_xjawtopposition() {
  xjawtopposition_ = 0;
  clear_has_xjawtopposition();
}
inline float RT_MS_MonteCarlo::xjawtopposition() const {
  return xjawtopposition_;
}
inline void RT_MS_MonteCarlo::set_xjawtopposition(float value) {
  set_has_xjawtopposition();
  xjawtopposition_ = value;
}

// optional float yJawTopPosition = 4;
inline bool RT_MS_MonteCarlo::has_yjawtopposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_yjawtopposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RT_MS_MonteCarlo::clear_has_yjawtopposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RT_MS_MonteCarlo::clear_yjawtopposition() {
  yjawtopposition_ = 0;
  clear_has_yjawtopposition();
}
inline float RT_MS_MonteCarlo::yjawtopposition() const {
  return yjawtopposition_;
}
inline void RT_MS_MonteCarlo::set_yjawtopposition(float value) {
  set_has_yjawtopposition();
  yjawtopposition_ = value;
}

// optional float xJawThickness = 5;
inline bool RT_MS_MonteCarlo::has_xjawthickness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_xjawthickness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RT_MS_MonteCarlo::clear_has_xjawthickness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RT_MS_MonteCarlo::clear_xjawthickness() {
  xjawthickness_ = 0;
  clear_has_xjawthickness();
}
inline float RT_MS_MonteCarlo::xjawthickness() const {
  return xjawthickness_;
}
inline void RT_MS_MonteCarlo::set_xjawthickness(float value) {
  set_has_xjawthickness();
  xjawthickness_ = value;
}

// optional float yJawThickness = 6;
inline bool RT_MS_MonteCarlo::has_yjawthickness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_yjawthickness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RT_MS_MonteCarlo::clear_has_yjawthickness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RT_MS_MonteCarlo::clear_yjawthickness() {
  yjawthickness_ = 0;
  clear_has_yjawthickness();
}
inline float RT_MS_MonteCarlo::yjawthickness() const {
  return yjawthickness_;
}
inline void RT_MS_MonteCarlo::set_yjawthickness(float value) {
  set_has_yjawthickness();
  yjawthickness_ = value;
}

// optional float mlcCenterPosition = 7;
inline bool RT_MS_MonteCarlo::has_mlccenterposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_mlccenterposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RT_MS_MonteCarlo::clear_has_mlccenterposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RT_MS_MonteCarlo::clear_mlccenterposition() {
  mlccenterposition_ = 0;
  clear_has_mlccenterposition();
}
inline float RT_MS_MonteCarlo::mlccenterposition() const {
  return mlccenterposition_;
}
inline void RT_MS_MonteCarlo::set_mlccenterposition(float value) {
  set_has_mlccenterposition();
  mlccenterposition_ = value;
}

// optional float mlcThickness = 8;
inline bool RT_MS_MonteCarlo::has_mlcthickness() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_mlcthickness() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RT_MS_MonteCarlo::clear_has_mlcthickness() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RT_MS_MonteCarlo::clear_mlcthickness() {
  mlcthickness_ = 0;
  clear_has_mlcthickness();
}
inline float RT_MS_MonteCarlo::mlcthickness() const {
  return mlcthickness_;
}
inline void RT_MS_MonteCarlo::set_mlcthickness(float value) {
  set_has_mlcthickness();
  mlcthickness_ = value;
}

// optional float mlcLeafendRadius = 9;
inline bool RT_MS_MonteCarlo::has_mlcleafendradius() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_mlcleafendradius() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RT_MS_MonteCarlo::clear_has_mlcleafendradius() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RT_MS_MonteCarlo::clear_mlcleafendradius() {
  mlcleafendradius_ = 0;
  clear_has_mlcleafendradius();
}
inline float RT_MS_MonteCarlo::mlcleafendradius() const {
  return mlcleafendradius_;
}
inline void RT_MS_MonteCarlo::set_mlcleafendradius(float value) {
  set_has_mlcleafendradius();
  mlcleafendradius_ = value;
}

// optional float airGapWidth = 10;
inline bool RT_MS_MonteCarlo::has_airgapwidth() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_airgapwidth() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RT_MS_MonteCarlo::clear_has_airgapwidth() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RT_MS_MonteCarlo::clear_airgapwidth() {
  airgapwidth_ = 0;
  clear_has_airgapwidth();
}
inline float RT_MS_MonteCarlo::airgapwidth() const {
  return airgapwidth_;
}
inline void RT_MS_MonteCarlo::set_airgapwidth(float value) {
  set_has_airgapwidth();
  airgapwidth_ = value;
}

// optional float tongueGrooveWidth = 11;
inline bool RT_MS_MonteCarlo::has_tonguegroovewidth() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_tonguegroovewidth() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RT_MS_MonteCarlo::clear_has_tonguegroovewidth() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RT_MS_MonteCarlo::clear_tonguegroovewidth() {
  tonguegroovewidth_ = 0;
  clear_has_tonguegroovewidth();
}
inline float RT_MS_MonteCarlo::tonguegroovewidth() const {
  return tonguegroovewidth_;
}
inline void RT_MS_MonteCarlo::set_tonguegroovewidth(float value) {
  set_has_tonguegroovewidth();
  tonguegroovewidth_ = value;
}

// optional float muCorrectionFactor = 12;
inline bool RT_MS_MonteCarlo::has_mucorrectionfactor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_mucorrectionfactor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RT_MS_MonteCarlo::clear_has_mucorrectionfactor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RT_MS_MonteCarlo::clear_mucorrectionfactor() {
  mucorrectionfactor_ = 0;
  clear_has_mucorrectionfactor();
}
inline float RT_MS_MonteCarlo::mucorrectionfactor() const {
  return mucorrectionfactor_;
}
inline void RT_MS_MonteCarlo::set_mucorrectionfactor(float value) {
  set_has_mucorrectionfactor();
  mucorrectionfactor_ = value;
}

// optional float minElectronEnergy = 13;
inline bool RT_MS_MonteCarlo::has_minelectronenergy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_minelectronenergy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RT_MS_MonteCarlo::clear_has_minelectronenergy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RT_MS_MonteCarlo::clear_minelectronenergy() {
  minelectronenergy_ = 0;
  clear_has_minelectronenergy();
}
inline float RT_MS_MonteCarlo::minelectronenergy() const {
  return minelectronenergy_;
}
inline void RT_MS_MonteCarlo::set_minelectronenergy(float value) {
  set_has_minelectronenergy();
  minelectronenergy_ = value;
}

// optional float maxElectronEnergy = 14;
inline bool RT_MS_MonteCarlo::has_maxelectronenergy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_maxelectronenergy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RT_MS_MonteCarlo::clear_has_maxelectronenergy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RT_MS_MonteCarlo::clear_maxelectronenergy() {
  maxelectronenergy_ = 0;
  clear_has_maxelectronenergy();
}
inline float RT_MS_MonteCarlo::maxelectronenergy() const {
  return maxelectronenergy_;
}
inline void RT_MS_MonteCarlo::set_maxelectronenergy(float value) {
  set_has_maxelectronenergy();
  maxelectronenergy_ = value;
}

// optional float normTen = 15;
inline bool RT_MS_MonteCarlo::has_normten() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_normten() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RT_MS_MonteCarlo::clear_has_normten() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RT_MS_MonteCarlo::clear_normten() {
  normten_ = 0;
  clear_has_normten();
}
inline float RT_MS_MonteCarlo::normten() const {
  return normten_;
}
inline void RT_MS_MonteCarlo::set_normten(float value) {
  set_has_normten();
  normten_ = value;
}

// optional string oarDepth1 = 16;
inline bool RT_MS_MonteCarlo::has_oardepth1() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_oardepth1() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RT_MS_MonteCarlo::clear_has_oardepth1() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RT_MS_MonteCarlo::clear_oardepth1() {
  if (oardepth1_ != &::google::protobuf::internal::kEmptyString) {
    oardepth1_->clear();
  }
  clear_has_oardepth1();
}
inline const ::std::string& RT_MS_MonteCarlo::oardepth1() const {
  return *oardepth1_;
}
inline void RT_MS_MonteCarlo::set_oardepth1(const ::std::string& value) {
  set_has_oardepth1();
  if (oardepth1_ == &::google::protobuf::internal::kEmptyString) {
    oardepth1_ = new ::std::string;
  }
  oardepth1_->assign(value);
}
inline void RT_MS_MonteCarlo::set_oardepth1(const char* value) {
  set_has_oardepth1();
  if (oardepth1_ == &::google::protobuf::internal::kEmptyString) {
    oardepth1_ = new ::std::string;
  }
  oardepth1_->assign(value);
}
inline void RT_MS_MonteCarlo::set_oardepth1(const char* value, size_t size) {
  set_has_oardepth1();
  if (oardepth1_ == &::google::protobuf::internal::kEmptyString) {
    oardepth1_ = new ::std::string;
  }
  oardepth1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_oardepth1() {
  set_has_oardepth1();
  if (oardepth1_ == &::google::protobuf::internal::kEmptyString) {
    oardepth1_ = new ::std::string;
  }
  return oardepth1_;
}
inline ::std::string* RT_MS_MonteCarlo::release_oardepth1() {
  clear_has_oardepth1();
  if (oardepth1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oardepth1_;
    oardepth1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string oarDepth2 = 17;
inline bool RT_MS_MonteCarlo::has_oardepth2() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_oardepth2() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RT_MS_MonteCarlo::clear_has_oardepth2() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RT_MS_MonteCarlo::clear_oardepth2() {
  if (oardepth2_ != &::google::protobuf::internal::kEmptyString) {
    oardepth2_->clear();
  }
  clear_has_oardepth2();
}
inline const ::std::string& RT_MS_MonteCarlo::oardepth2() const {
  return *oardepth2_;
}
inline void RT_MS_MonteCarlo::set_oardepth2(const ::std::string& value) {
  set_has_oardepth2();
  if (oardepth2_ == &::google::protobuf::internal::kEmptyString) {
    oardepth2_ = new ::std::string;
  }
  oardepth2_->assign(value);
}
inline void RT_MS_MonteCarlo::set_oardepth2(const char* value) {
  set_has_oardepth2();
  if (oardepth2_ == &::google::protobuf::internal::kEmptyString) {
    oardepth2_ = new ::std::string;
  }
  oardepth2_->assign(value);
}
inline void RT_MS_MonteCarlo::set_oardepth2(const char* value, size_t size) {
  set_has_oardepth2();
  if (oardepth2_ == &::google::protobuf::internal::kEmptyString) {
    oardepth2_ = new ::std::string;
  }
  oardepth2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_oardepth2() {
  set_has_oardepth2();
  if (oardepth2_ == &::google::protobuf::internal::kEmptyString) {
    oardepth2_ = new ::std::string;
  }
  return oardepth2_;
}
inline ::std::string* RT_MS_MonteCarlo::release_oardepth2() {
  clear_has_oardepth2();
  if (oardepth2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oardepth2_;
    oardepth2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string energyValue = 18;
inline bool RT_MS_MonteCarlo::has_energyvalue() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_energyvalue() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RT_MS_MonteCarlo::clear_has_energyvalue() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RT_MS_MonteCarlo::clear_energyvalue() {
  if (energyvalue_ != &::google::protobuf::internal::kEmptyString) {
    energyvalue_->clear();
  }
  clear_has_energyvalue();
}
inline const ::std::string& RT_MS_MonteCarlo::energyvalue() const {
  return *energyvalue_;
}
inline void RT_MS_MonteCarlo::set_energyvalue(const ::std::string& value) {
  set_has_energyvalue();
  if (energyvalue_ == &::google::protobuf::internal::kEmptyString) {
    energyvalue_ = new ::std::string;
  }
  energyvalue_->assign(value);
}
inline void RT_MS_MonteCarlo::set_energyvalue(const char* value) {
  set_has_energyvalue();
  if (energyvalue_ == &::google::protobuf::internal::kEmptyString) {
    energyvalue_ = new ::std::string;
  }
  energyvalue_->assign(value);
}
inline void RT_MS_MonteCarlo::set_energyvalue(const char* value, size_t size) {
  set_has_energyvalue();
  if (energyvalue_ == &::google::protobuf::internal::kEmptyString) {
    energyvalue_ = new ::std::string;
  }
  energyvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_energyvalue() {
  set_has_energyvalue();
  if (energyvalue_ == &::google::protobuf::internal::kEmptyString) {
    energyvalue_ = new ::std::string;
  }
  return energyvalue_;
}
inline ::std::string* RT_MS_MonteCarlo::release_energyvalue() {
  clear_has_energyvalue();
  if (energyvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = energyvalue_;
    energyvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool electronContaminationFlag = 19;
inline bool RT_MS_MonteCarlo::has_electroncontaminationflag() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_electroncontaminationflag() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RT_MS_MonteCarlo::clear_has_electroncontaminationflag() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RT_MS_MonteCarlo::clear_electroncontaminationflag() {
  electroncontaminationflag_ = false;
  clear_has_electroncontaminationflag();
}
inline bool RT_MS_MonteCarlo::electroncontaminationflag() const {
  return electroncontaminationflag_;
}
inline void RT_MS_MonteCarlo::set_electroncontaminationflag(bool value) {
  set_has_electroncontaminationflag();
  electroncontaminationflag_ = value;
}

// optional float electronMaxDepth = 20;
inline bool RT_MS_MonteCarlo::has_electronmaxdepth() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_electronmaxdepth() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RT_MS_MonteCarlo::clear_has_electronmaxdepth() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RT_MS_MonteCarlo::clear_electronmaxdepth() {
  electronmaxdepth_ = 0;
  clear_has_electronmaxdepth();
}
inline float RT_MS_MonteCarlo::electronmaxdepth() const {
  return electronmaxdepth_;
}
inline void RT_MS_MonteCarlo::set_electronmaxdepth(float value) {
  set_has_electronmaxdepth();
  electronmaxdepth_ = value;
}

// optional float surfaceDose = 21;
inline bool RT_MS_MonteCarlo::has_surfacedose() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_surfacedose() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RT_MS_MonteCarlo::clear_has_surfacedose() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RT_MS_MonteCarlo::clear_surfacedose() {
  surfacedose_ = 0;
  clear_has_surfacedose();
}
inline float RT_MS_MonteCarlo::surfacedose() const {
  return surfacedose_;
}
inline void RT_MS_MonteCarlo::set_surfacedose(float value) {
  set_has_surfacedose();
  surfacedose_ = value;
}

// optional float depthCoefficientK = 22;
inline bool RT_MS_MonteCarlo::has_depthcoefficientk() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_depthcoefficientk() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RT_MS_MonteCarlo::clear_has_depthcoefficientk() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RT_MS_MonteCarlo::clear_depthcoefficientk() {
  depthcoefficientk_ = 0;
  clear_has_depthcoefficientk();
}
inline float RT_MS_MonteCarlo::depthcoefficientk() const {
  return depthcoefficientk_;
}
inline void RT_MS_MonteCarlo::set_depthcoefficientk(float value) {
  set_has_depthcoefficientk();
  depthcoefficientk_ = value;
}

// optional float offaxisCoefficientA = 23;
inline bool RT_MS_MonteCarlo::has_offaxiscoefficienta() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_offaxiscoefficienta() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RT_MS_MonteCarlo::clear_has_offaxiscoefficienta() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RT_MS_MonteCarlo::clear_offaxiscoefficienta() {
  offaxiscoefficienta_ = 0;
  clear_has_offaxiscoefficienta();
}
inline float RT_MS_MonteCarlo::offaxiscoefficienta() const {
  return offaxiscoefficienta_;
}
inline void RT_MS_MonteCarlo::set_offaxiscoefficienta(float value) {
  set_has_offaxiscoefficienta();
  offaxiscoefficienta_ = value;
}

// optional float df = 24;
inline bool RT_MS_MonteCarlo::has_df() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_df() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RT_MS_MonteCarlo::clear_has_df() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RT_MS_MonteCarlo::clear_df() {
  df_ = 0;
  clear_has_df();
}
inline float RT_MS_MonteCarlo::df() const {
  return df_;
}
inline void RT_MS_MonteCarlo::set_df(float value) {
  set_has_df();
  df_ = value;
}

// optional float sf = 25;
inline bool RT_MS_MonteCarlo::has_sf() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_sf() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RT_MS_MonteCarlo::clear_has_sf() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RT_MS_MonteCarlo::clear_sf() {
  sf_ = 0;
  clear_has_sf();
}
inline float RT_MS_MonteCarlo::sf() const {
  return sf_;
}
inline void RT_MS_MonteCarlo::set_sf(float value) {
  set_has_sf();
  sf_ = value;
}

// optional float cOne = 26;
inline bool RT_MS_MonteCarlo::has_cone() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_cone() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RT_MS_MonteCarlo::clear_has_cone() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RT_MS_MonteCarlo::clear_cone() {
  cone_ = 0;
  clear_has_cone();
}
inline float RT_MS_MonteCarlo::cone() const {
  return cone_;
}
inline void RT_MS_MonteCarlo::set_cone(float value) {
  set_has_cone();
  cone_ = value;
}

// optional float cTwo = 27;
inline bool RT_MS_MonteCarlo::has_ctwo() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_ctwo() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RT_MS_MonteCarlo::clear_has_ctwo() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RT_MS_MonteCarlo::clear_ctwo() {
  ctwo_ = 0;
  clear_has_ctwo();
}
inline float RT_MS_MonteCarlo::ctwo() const {
  return ctwo_;
}
inline void RT_MS_MonteCarlo::set_ctwo(float value) {
  set_has_ctwo();
  ctwo_ = value;
}

// optional float cThree = 28;
inline bool RT_MS_MonteCarlo::has_cthree() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_cthree() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RT_MS_MonteCarlo::clear_has_cthree() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RT_MS_MonteCarlo::clear_cthree() {
  cthree_ = 0;
  clear_has_cthree();
}
inline float RT_MS_MonteCarlo::cthree() const {
  return cthree_;
}
inline void RT_MS_MonteCarlo::set_cthree(float value) {
  set_has_cthree();
  cthree_ = value;
}

// repeated .ms.proto.RT_MS_Spectrum spectrumList = 29;
inline int RT_MS_MonteCarlo::spectrumlist_size() const {
  return spectrumlist_.size();
}
inline void RT_MS_MonteCarlo::clear_spectrumlist() {
  spectrumlist_.Clear();
}
inline const ::ms::proto::RT_MS_Spectrum& RT_MS_MonteCarlo::spectrumlist(int index) const {
  return spectrumlist_.Get(index);
}
inline ::ms::proto::RT_MS_Spectrum* RT_MS_MonteCarlo::mutable_spectrumlist(int index) {
  return spectrumlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_Spectrum* RT_MS_MonteCarlo::add_spectrumlist() {
  return spectrumlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_Spectrum >&
RT_MS_MonteCarlo::spectrumlist() const {
  return spectrumlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_Spectrum >*
RT_MS_MonteCarlo::mutable_spectrumlist() {
  return &spectrumlist_;
}

// repeated .ms.proto.RT_MS_FieldSize fieldSizeList = 30;
inline int RT_MS_MonteCarlo::fieldsizelist_size() const {
  return fieldsizelist_.size();
}
inline void RT_MS_MonteCarlo::clear_fieldsizelist() {
  fieldsizelist_.Clear();
}
inline const ::ms::proto::RT_MS_FieldSize& RT_MS_MonteCarlo::fieldsizelist(int index) const {
  return fieldsizelist_.Get(index);
}
inline ::ms::proto::RT_MS_FieldSize* RT_MS_MonteCarlo::mutable_fieldsizelist(int index) {
  return fieldsizelist_.Mutable(index);
}
inline ::ms::proto::RT_MS_FieldSize* RT_MS_MonteCarlo::add_fieldsizelist() {
  return fieldsizelist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_FieldSize >&
RT_MS_MonteCarlo::fieldsizelist() const {
  return fieldsizelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_FieldSize >*
RT_MS_MonteCarlo::mutable_fieldsizelist() {
  return &fieldsizelist_;
}

// repeated .ms.proto.RT_MS_MonteCarloPhysicalWedgeField physicalWedgeFieldList = 31;
inline int RT_MS_MonteCarlo::physicalwedgefieldlist_size() const {
  return physicalwedgefieldlist_.size();
}
inline void RT_MS_MonteCarlo::clear_physicalwedgefieldlist() {
  physicalwedgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField& RT_MS_MonteCarlo::physicalwedgefieldlist(int index) const {
  return physicalwedgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField* RT_MS_MonteCarlo::mutable_physicalwedgefieldlist(int index) {
  return physicalwedgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField* RT_MS_MonteCarlo::add_physicalwedgefieldlist() {
  return physicalwedgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField >&
RT_MS_MonteCarlo::physicalwedgefieldlist() const {
  return physicalwedgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloPhysicalWedgeField >*
RT_MS_MonteCarlo::mutable_physicalwedgefieldlist() {
  return &physicalwedgefieldlist_;
}

// repeated .ms.proto.RT_MS_MonteCarloVirtualWedgeInfo virtualWeidgeFieldList = 32;
inline int RT_MS_MonteCarlo::virtualweidgefieldlist_size() const {
  return virtualweidgefieldlist_.size();
}
inline void RT_MS_MonteCarlo::clear_virtualweidgefieldlist() {
  virtualweidgefieldlist_.Clear();
}
inline const ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo& RT_MS_MonteCarlo::virtualweidgefieldlist(int index) const {
  return virtualweidgefieldlist_.Get(index);
}
inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo* RT_MS_MonteCarlo::mutable_virtualweidgefieldlist(int index) {
  return virtualweidgefieldlist_.Mutable(index);
}
inline ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo* RT_MS_MonteCarlo::add_virtualweidgefieldlist() {
  return virtualweidgefieldlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo >&
RT_MS_MonteCarlo::virtualweidgefieldlist() const {
  return virtualweidgefieldlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ms::proto::RT_MS_MonteCarloVirtualWedgeInfo >*
RT_MS_MonteCarlo::mutable_virtualweidgefieldlist() {
  return &virtualweidgefieldlist_;
}

// optional string monterCarloName = 33;
inline bool RT_MS_MonteCarlo::has_montercarloname() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_montercarloname() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RT_MS_MonteCarlo::clear_has_montercarloname() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RT_MS_MonteCarlo::clear_montercarloname() {
  if (montercarloname_ != &::google::protobuf::internal::kEmptyString) {
    montercarloname_->clear();
  }
  clear_has_montercarloname();
}
inline const ::std::string& RT_MS_MonteCarlo::montercarloname() const {
  return *montercarloname_;
}
inline void RT_MS_MonteCarlo::set_montercarloname(const ::std::string& value) {
  set_has_montercarloname();
  if (montercarloname_ == &::google::protobuf::internal::kEmptyString) {
    montercarloname_ = new ::std::string;
  }
  montercarloname_->assign(value);
}
inline void RT_MS_MonteCarlo::set_montercarloname(const char* value) {
  set_has_montercarloname();
  if (montercarloname_ == &::google::protobuf::internal::kEmptyString) {
    montercarloname_ = new ::std::string;
  }
  montercarloname_->assign(value);
}
inline void RT_MS_MonteCarlo::set_montercarloname(const char* value, size_t size) {
  set_has_montercarloname();
  if (montercarloname_ == &::google::protobuf::internal::kEmptyString) {
    montercarloname_ = new ::std::string;
  }
  montercarloname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_montercarloname() {
  set_has_montercarloname();
  if (montercarloname_ == &::google::protobuf::internal::kEmptyString) {
    montercarloname_ = new ::std::string;
  }
  return montercarloname_;
}
inline ::std::string* RT_MS_MonteCarlo::release_montercarloname() {
  clear_has_montercarloname();
  if (montercarloname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = montercarloname_;
    montercarloname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string wedgeId = 34;
inline bool RT_MS_MonteCarlo::has_wedgeid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_wedgeid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RT_MS_MonteCarlo::clear_has_wedgeid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RT_MS_MonteCarlo::clear_wedgeid() {
  if (wedgeid_ != &::google::protobuf::internal::kEmptyString) {
    wedgeid_->clear();
  }
  clear_has_wedgeid();
}
inline const ::std::string& RT_MS_MonteCarlo::wedgeid() const {
  return *wedgeid_;
}
inline void RT_MS_MonteCarlo::set_wedgeid(const ::std::string& value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_wedgeid(const char* value) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_wedgeid(const char* value, size_t size) {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  wedgeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_wedgeid() {
  set_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    wedgeid_ = new ::std::string;
  }
  return wedgeid_;
}
inline ::std::string* RT_MS_MonteCarlo::release_wedgeid() {
  clear_has_wedgeid();
  if (wedgeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wedgeid_;
    wedgeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string filePath = 35;
inline bool RT_MS_MonteCarlo::has_filepath() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_filepath() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RT_MS_MonteCarlo::clear_has_filepath() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RT_MS_MonteCarlo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& RT_MS_MonteCarlo::filepath() const {
  return *filepath_;
}
inline void RT_MS_MonteCarlo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void RT_MS_MonteCarlo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void RT_MS_MonteCarlo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* RT_MS_MonteCarlo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string accessoryUID = 36;
inline bool RT_MS_MonteCarlo::has_accessoryuid() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_accessoryuid() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RT_MS_MonteCarlo::clear_has_accessoryuid() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RT_MS_MonteCarlo::clear_accessoryuid() {
  if (accessoryuid_ != &::google::protobuf::internal::kEmptyString) {
    accessoryuid_->clear();
  }
  clear_has_accessoryuid();
}
inline const ::std::string& RT_MS_MonteCarlo::accessoryuid() const {
  return *accessoryuid_;
}
inline void RT_MS_MonteCarlo::set_accessoryuid(const ::std::string& value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_accessoryuid(const char* value) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(value);
}
inline void RT_MS_MonteCarlo::set_accessoryuid(const char* value, size_t size) {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  accessoryuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RT_MS_MonteCarlo::mutable_accessoryuid() {
  set_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    accessoryuid_ = new ::std::string;
  }
  return accessoryuid_;
}
inline ::std::string* RT_MS_MonteCarlo::release_accessoryuid() {
  clear_has_accessoryuid();
  if (accessoryuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accessoryuid_;
    accessoryuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 algType = 37;
inline bool RT_MS_MonteCarlo::has_algtype() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void RT_MS_MonteCarlo::set_has_algtype() {
  _has_bits_[1] |= 0x00000010u;
}
inline void RT_MS_MonteCarlo::clear_has_algtype() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void RT_MS_MonteCarlo::clear_algtype() {
  algtype_ = 0;
  clear_has_algtype();
}
inline ::google::protobuf::int32 RT_MS_MonteCarlo::algtype() const {
  return algtype_;
}
inline void RT_MS_MonteCarlo::set_algtype(::google::protobuf::int32 value) {
  set_has_algtype();
  algtype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace ms

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rt_5fms_5fmontecarlo_2eproto__INCLUDED
