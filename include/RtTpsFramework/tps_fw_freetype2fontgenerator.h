////////////////////////////////////////////////////////////////
///  Copyright (c) Shanghai United Imaging Healthcare Inc., 2013
///  All rights reserved.
/// 
///  \author  SHI Chunhui  mailto:chunhui.shi@united-imaging.com
/// 
///  \file tps_fw_freetype2fontgenerator.h
/// 
///  \brief class Generate font using FreeType2 API
/// 
///  \version 1.1
/// 
///  \date    2014/12/28
////////////////////////////////////////////////////////////////
#ifndef TPS_FW_FREETYPE2STRINGGENERATOR_H_
#define TPS_FW_FREETYPE2STRINGGENERATOR_H_

#include <vector>
#include "tps_fw_defs.h"
#include "tps_singleton.h"
#include "ft2build.h"
#include FT_FREETYPE_H
#include FT_STROKER_H

#ifdef _MSC_VER
#define MIN __min
#define MAX __max
#else
#define MIN std::min
#define MAX std::max
#endif

#pragma warning(disable:4201)

TPS_BEGIN_NAMESPACE

// Define some fixed size types.
typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned int uint32;

union Pixel32
{
    Pixel32() : integer(0) { }
    Pixel32(uint8 bi, uint8 gi, uint8 ri, uint8 ai = 255)
    {
        b = bi;
        g = gi;
        r = ri;
        a = ai;
    }

    uint32 integer;

    struct
    {
#ifdef BIG_ENDIAN
        uint8 a, r, g, b;
#else // BIG_ENDIAN
        uint8 b, g, r, a;
#endif // BIG_ENDIAN
    };
};


#define PINK_VALUE Pixel32(255,192,203)
#define CRIMSON_VALUE Pixel32(220,20,60)
#define MAGENTA_VALUE Pixel32(255,192,203)
#define INDIGO_VALUE Pixel32(75,0,130)
#define PURPLE_VALUE Pixel32(128,0,128)
#define DARKBLUE_VALUE Pixel32(0,0,139)
#define NAVY_VALUE Pixel32(0,0,128)
#define DARKTURQUOISE_VALUE Pixel32(0,206,209)
#define GOLD_VALUE Pixel32(255,215,0)
#define ORANGE_VALUE Pixel32(255,165,0)
#define SIENNA_VALUE Pixel32(160,82,45)
#define SALMON_VALUE Pixel32(250,128,114)
#define TOMATO_VALUE Pixel32(255,99,71)
#define RED_VALUE Pixel32(255,0,0)
#define GREEN_VALUE Pixel32(0,255,0)
#define BLUE_VALUE Pixel32(0,0,255)
#define WHITE_VALUE Pixel32(255,255,255)
#define BLACK_VALUE Pixel32(0,0,0)
#define SILVER_VALUE Pixel32(192,192,192)


// A horizontal pixel span generated by the FreeType renderer.
struct Span
{
    Span() { }
    Span(int _x, int _y, int _width, int _coverage)
        : x(_x), y(_y), width(_width), coverage(_coverage) { }

    int x, y, width, coverage;
};

typedef std::vector<Span> Spans;

struct Vec2
{
    Vec2() { }
    Vec2(int a, int b)
        : x(a), y(b) { }

    int x, y;
};


struct Rect
{
    Rect() { }
    Rect(int left, int top, int right, int bottom)
        : xmin(left), xmax(right), ymin(top), ymax(bottom) { }

    void Include(const Vec2 &r)
    {
        xmin = MIN(xmin, r.x);
        ymin = MIN(ymin, r.y);
        xmax = MAX(xmax, r.x);
        ymax = MAX(ymax, r.y);
    }

    int Width() const { return xmax - xmin + 1; }
    int Height() const { return ymax - ymin + 1; }

    int xmin, xmax, ymin, ymax;
};

struct CharBuf{
public:
    CharBuf(){
        mBearingX = 0.0f;
        mBearingY = 0.0f;
        mAdvance = 0.0f;
        mKerning = 0.0f;
        mpcharBufData = nullptr;
        mcharRect.xmax = mcharRect.xmin = mcharRect.ymax = mcharRect.ymin= 0;
    }
    CharBuf(const Rect& rect, Pixel32* pBuf, float bearingX, float bearingY, float advance, float kerning, wchar_t chid){
            if (pBuf == nullptr) {
                return;
            }
            mcharRect = rect;
            int imgWidth = rect.Width();
            int imgHeight = rect.Height();
            int imgSize = imgWidth * imgHeight;
            if (imgSize==0) {
                imgSize = 512 * 384;
            }
            // Allocate data for our image and clear it out to transparent.
            mpcharBufData = new Pixel32[imgSize];
            memcpy(mpcharBufData, pBuf, sizeof(Pixel32) * imgSize);

            mBearingX = bearingX;
            mBearingY = bearingY;
            mAdvance = advance;
            mKerning = kerning;
            mChaId = chid;
    }

    ~CharBuf() {
        if (nullptr != mpcharBufData) {
            delete[] mpcharBufData;
            mpcharBufData = nullptr;
        }
    }

    // Member Variables
    wchar_t     mChaId;
    Rect        mcharRect;
    Pixel32*    mpcharBufData;
    float       mBearingX;
    float       mBearingY;
    float       mAdvance;
    float       mKerning;

};

class TPS_FW_DECLSPEC FTStringBufferGenerator {
    DECLARE_SINGLETON(FTStringBufferGenerator)
public:
    bool Init();

    void GenerateCharDictionary(int size, const Pixel32 &fontCol);

     bool GenerateRasterBuffer(const std::wstring& strText,
        Pixel32** pixBuf, int& bufWidth, int& bufHeight, 
        int fontSize = 12);

    bool GenerateRasterBuffer(const std::wstring& strText,
        Pixel32** pixBuf, int& bufWidth, int& bufHeight, 
        int fontSize, Pixel32 fontCol);


protected:
    void AssembleStringBuffer(const std::vector<CharBuf*>& stringBuf,
        Pixel32*& pixelBuf, int& bufWidth, int& bufHeight, int ymin, int ymax);


private:
    FTStringBufferGenerator();
    ~FTStringBufferGenerator();

private:
    std::wstring                        mStringText;
    FT_Library                          mLibrary;
    FT_Face                             mFace;
    unsigned char*                      mFontBuffer;
    Pixel32                             mFontCol;
    Pixel32                             mOutlineCol;
    float                               mOutlineWidth;
    int                                 mSize;
    int                                 mSpacing;
    bool                                mIsInited;
    boost::mutex                       mMutex;

    struct FontInfo
    {
        FontInfo(){};
        FontInfo(
            std::map<wchar_t, CharBuf*> charmap, 
            int size =12, 
            const Pixel32 &fontCol = Pixel32(255, 255, 255), 
            int ymin = 999, int ymax = -999) 
            : mFontCol(fontCol), mFontSize(size), mAlignYmin(ymin), mAlignYmax(ymax),mCharmap(charmap)
        {

        };

       ~FontInfo()
       {

       }

        int                                 mFontSize;
        Pixel32                            mFontCol;
        int                                 mAlignYmin;
        int                                 mAlignYmax;
        std::map<wchar_t, CharBuf*>      mCharmap;
    };

    FontInfo mNewGeneratedFont;
    std::multimap<int, FontInfo> mFontCollection;


    //TODO: disallow copy and assign
};

TPS_END_NAMESPACE

#endif
