//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_interface_object.h
///  \brief     This file was generated by CodeGenerater.exe 
///              From database version: 1.1.11
///
///  \version 1.0
///  \date    7/26/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#ifndef RT_TPS_DATABASE_INTERFACE_OBJECT_CONTOUR_H_
#define RT_TPS_DATABASE_INTERFACE_OBJECT_CONTOUR_H_

#include "RtTpsDatabaseWrapper/rt_tps_database_defs.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_base.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_common_enums.h"
#include "boost/date_time/gregorian/gregorian_types.hpp"
#include "boost/date_time/posix_time/posix_time_types.hpp"
#include "boost/archive/xml_iarchive.hpp"
#include "boost/archive/xml_oarchive.hpp"
#include "boost/date_time/posix_time/time_serialize.hpp"
#include <vector>
#include "RtTpsDatabaseWrapper/rt_tps_database_data.h"

RT_TPS_DATABASE_BEGIN_NAMESPACE;

enum CONTOUR_FIELD
{
    CONTOUR_UID = 0,
    CONTOUR_VOIUID,
    CONTOUR_SEGMENTUID,
    CONTOUR_IMAGEUID,
    CONTOUR_ACCESSORYCHUNKUID,
    CONTOUR_SLICEINDEX,
    CONTOUR_ACCURACY,
    CONTOUR_POINTS,
    CONTOUR_ISCOLLIMATEDOUTLINE,
    CONTOUR_CONTOURGEOMETRICTYPE,
    CONTOUR_THICKNESS,
    CONTOUR_UPDATETIME,
    CONTOUR_FIELD_MAX
};

static const char* ENUM2STRING_CONTOUR_FIELD[] =
{
    "UID",
    "VOIUID",
    "SEGMENTUID",
    "IMAGEUID",
    "ACCESSORYCHUNKUID",
    "SLICEINDEX",
    "ACCURACY",
    "POINTS",
    "ISCOLLIMATEDOUTLINE",
    "CONTOURGEOMETRICTYPE",
    "THICKNESS",
    "UPDATETIME",
    "CONTOUR_FIELD_MAX"
};

static const char* ENUM2STRING_CONTOUR_FIELD_NULL = "100000000001";

typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

class RtContourImp;

class RT_DB_EXPORT RtContour : public RtDatabaseObject
{
public:

    //default is false to improve performance
    RtContour(bool bGeneraterUid = false);

    ~RtContour();

    RtContour(const RtContour& contour);

    RtContour& operator = (const RtContour& contour);

    /*uid varchar
      PK*/
    std::string get_uid() const;
    void set_uid(const std::string& uid);

    /*voiuid varchar
      Related VOI UID*/
    std::string get_voiuid() const;
    void set_voiuid(const std::string& voiuid);

    /*segmentuid varchar
      segment uid*/
    std::string get_segmentuid() const;
    void set_segmentuid(const std::string& segmentuid);

    /*imageuid varchar
      关联的ImageUID*/
    std::string get_imageuid() const;
    void set_imageuid(const std::string& imageuid);

    /*accessorychunkuid varchar
      Add on 20140613 for find the related Accessorychunk*/
    std::string get_accessorychunkuid() const;
    void set_accessorychunkuid(const std::string& accessorychunkuid);

    /*sliceindex int
      关联的层号*/
    int get_sliceindex() const;
    void set_sliceindex(const int& sliceindex);

    /*accuracy int
      存储精度*/
    int get_accuracy() const;
    void set_accuracy(const int& accuracy);

    /*points mediumblob
      数据集合*/
    std::vector<db_Point3f> get_contour_points() const;
    std::vector<db_Point3f> get_contour_points();
    void set_contour_points(const std::vector<db_Point3f>& vPoints);

    /*iscollimatedoutline tinyint
       Added on 20140218 to identify the CollimatedOutline contour in segment*/
    bool get_iscollimatedoutline() const;
    void set_iscollimatedoutline(const bool& iscollimatedoutline);

    /*contourgeometrictype int
      Enum POINT, OPEN_PLANAR, OPEN_NONPLANAR, CLOSED_PLANAR*/
    int get_contourgeometrictype() const;
    void set_contourgeometrictype(const int& contourgeometrictype);

    /*thickness float
       厚度Add on 20140416 by Jingjie*/
    float get_thickness() const;
    void set_thickness(const float& thickness);

    /*updatetime timestamp
      时间戳*/
    DATETIME_BOOST get_updatetime() const;
    void set_updatetime(const DATETIME_BOOST& updatetime);


private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize( Archive &ar,const unsigned int version) {
  	  version;
	  ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(RtDatabaseObject);
  	  ar & BOOST_SERIALIZATION_NVP(m_pImp);
    }
    RtContourImp*                   m_pImp;
};


//////////////////////////////////////////////////////////////////////////
//for imp

class RtContourImp
{

public:
    //default is false to improve performance
    RT_DB_EXPORT RtContourImp(bool bGeneraterUid = false);

    virtual ~RtContourImp();

    RtContourImp(const RtContourImp& contour);

    RtContourImp& operator = (const RtContourImp& contour);

    //uid
    inline std::string get_uid() const { return m_uid;}
    inline void set_uid(const std::string& uid) { m_uid = uid;}

    //voiuid
    inline std::string get_voiuid() const { return m_voiuid;}
    inline void set_voiuid(const std::string& voiuid) { m_voiuid = voiuid;}

    //segmentuid
    inline std::string get_segmentuid() const { return m_segmentuid;}
    inline void set_segmentuid(const std::string& segmentuid) { m_segmentuid = segmentuid;}

    //imageuid
    inline std::string get_imageuid() const { return m_imageuid;}
    inline void set_imageuid(const std::string& imageuid) { m_imageuid = imageuid;}

    //accessorychunkuid
    inline std::string get_accessorychunkuid() const { return m_accessorychunkuid;}
    inline void set_accessorychunkuid(const std::string& accessorychunkuid) { m_accessorychunkuid = accessorychunkuid;}

    //sliceindex
    inline int get_sliceindex() const { return m_sliceindex;}
    inline void set_sliceindex(const int& sliceindex) { m_sliceindex = sliceindex;}

    //accuracy
    inline int get_accuracy() const { return m_accuracy;}
    inline void set_accuracy(const int& accuracy) { m_accuracy = accuracy;}

    //points
    inline std::vector<db_Point3f> get_contour_points() const { return m_contour_points;}
    inline std::vector<db_Point3f> get_contour_points() { return m_contour_points;}
    inline void set_contour_points(const std::vector<db_Point3f>& vPoints) { m_contour_points = vPoints;}

    //iscollimatedoutline
    inline bool get_iscollimatedoutline() const { return m_iscollimatedoutline;}
    inline void set_iscollimatedoutline(const bool& iscollimatedoutline) { m_iscollimatedoutline = iscollimatedoutline;}

    //contourgeometrictype
    inline int get_contourgeometrictype() const { return m_contourgeometrictype;}
    inline void set_contourgeometrictype(const int& contourgeometrictype) { m_contourgeometrictype = contourgeometrictype;}

    //thickness
    inline float get_thickness() const { return m_thickness;}
    inline void set_thickness(const float& thickness) { m_thickness = thickness;}

    //updatetime
    inline DATETIME_BOOST get_updatetime() const { return m_updatetime;}
    inline void set_updatetime(const DATETIME_BOOST& updatetime) { m_updatetime = updatetime;}

private:    //12 parameters
	friend class boost::serialization::access;
	template<class Archive>
	void serialize(Archive &ar, const unsigned int version) {
		version;
		ar & BOOST_SERIALIZATION_NVP(m_uid);
		ar & BOOST_SERIALIZATION_NVP(m_voiuid);
		ar & BOOST_SERIALIZATION_NVP(m_segmentuid);
		ar & BOOST_SERIALIZATION_NVP(m_imageuid);
		ar & BOOST_SERIALIZATION_NVP(m_accessorychunkuid);
		ar & BOOST_SERIALIZATION_NVP(m_sliceindex);
		ar & BOOST_SERIALIZATION_NVP(m_accuracy);
		ar & BOOST_SERIALIZATION_NVP(m_contour_points);
		ar & BOOST_SERIALIZATION_NVP(m_iscollimatedoutline);
		ar & BOOST_SERIALIZATION_NVP(m_contourgeometrictype);
		ar & BOOST_SERIALIZATION_NVP(m_thickness);
		ar & BOOST_SERIALIZATION_NVP(m_updatetime);
	}
    std::string						m_uid;
    std::string						m_voiuid;
    std::string						m_segmentuid;
    std::string						m_imageuid;
    std::string						m_accessorychunkuid;
    int								m_sliceindex;
    int								m_accuracy;
    std::vector<db_Point3f>         m_contour_points;
    bool							m_iscollimatedoutline;
    int								m_contourgeometrictype;
    float							m_thickness;
    DATETIME_BOOST					m_updatetime;
};

RT_TPS_DATABASE_END_NAMESPACE
#endif