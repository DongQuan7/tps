//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_interface_object.h
///  \brief     This file was generated by CodeGenerater.exe 
///              From database version: 1.1.11
///
///  \version 1.0
///  \date    7/26/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#ifndef RT_TPS_DATABASE_INTERFACE_OBJECT_MACHINE_H_
#define RT_TPS_DATABASE_INTERFACE_OBJECT_MACHINE_H_

#include "RtTpsDatabaseWrapper/rt_tps_database_defs.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_base.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_common_enums.h"
#include "boost/date_time/gregorian/gregorian_types.hpp"
#include "boost/date_time/posix_time/posix_time_types.hpp"
#include "boost/archive/xml_iarchive.hpp"
#include "boost/archive/xml_oarchive.hpp"
#include "boost/date_time/posix_time/time_serialize.hpp"

RT_TPS_DATABASE_BEGIN_NAMESPACE;

enum MACHINE_FIELD
{
    MACHINE_UID = 0,
    MACHINE_NAME,
    MACHINE_TYPE,
    MACHINE_MANUFACTURER,
    MACHINE_GANTRYMAX,
    MACHINE_GANTRYMIN,
    MACHINE_SAD,
    MACHINE_TABLELATERALMAX,
    MACHINE_TABLELATERALMIN,
    MACHINE_TABLELONGITUDINALMAX,
    MACHINE_TABLELONGITUDINALMIN,
    MACHINE_TABLEVERTICALMAX,
    MACHINE_TABLEVERTICALMIN,
    MACHINE_TABLEANGLEMAX,
    MACHINE_TABLEANGLEMIN,
    MACHINE_COLLIMATORDIRECTION,
    MACHINE_MLCDIRECTIONTYPE,
    MACHINE_JAWXISSYMMETRY,
    MACHINE_JAWYISSYMMETRY,
    MACHINE_XJAWNUM,
    MACHINE_YJAWNUM,
    MACHINE_LEAFNUM,
    MACHINE_LEAFBOUNDARIES,
    MACHINE_NEGATIVELEAFRANGEMIN,
    MACHINE_NEGATIVELEAFRANGEMAX,
    MACHINE_POSITIVELEAFRANGEMIN,
    MACHINE_POSITIVELEAFRANGEMAX,
    MACHINE_ISINTERDIGITATION,
    MACHINE_LEAFSPAN,
    MACHINE_MINLEAFENDGAP,
    MACHINE_SDD,
    MACHINE_SOURCETOBEAMLIMITINGDEVICEDISTANCE,
    MACHINE_XINDEPENDENT,
    MACHINE_XMIN_1,
    MACHINE_XMAX_1,
    MACHINE_XMIN_2,
    MACHINE_XMAX_2,
    MACHINE_XMIN_W,
    MACHINE_XMAX_W,
    MACHINE_XSDD,
    MACHINE_XNAME_1,
    MACHINE_XNAME_2,
    MACHINE_XISXJAWLIMIT,
    MACHINE_YINDEPENDENT,
    MACHINE_YMIN_1,
    MACHINE_YMAX_1,
    MACHINE_YMIN_2,
    MACHINE_YMAX_2,
    MACHINE_YMIN_W,
    MACHINE_YMAX_W,
    MACHINE_YSDD,
    MACHINE_YNAME_1,
    MACHINE_YNAME_2,
    MACHINE_YISXJAWLIMIT,
    MACHINE_MAXIMUMGANTRYSPEED_DEGREEPERSECOND,
    MACHINE_MAXIMUMLEAFSPEED_MMPERSECOND,
    MACHINE_DEVICEID,
    MACHINE_COMMENTS,
    MACHINE_COLLIMATORANGLEMIN,
    MACHINE_COLLIMATORANGLEMAX,
    MACHINE_GANTRYCLOCKWISERANGE,
    MACHINE_GANTRYCOUNTERCLOCKWISERANGE,
    MACHINE_AVAILABLEPLANTYPE,
    MACHINE_MAXIMUMJAWSPEED_MMPERSECOND,
    MACHINE_MINIMUMJAWGAP,
    MACHINE_DYNAMICTRACKINGJAWX,
    MACHINE_DYNAMICTRACKINGJAWY,
    MACHINE_SOURCETOMLCTOPDISTANCE,
    MACHINE_JAWTRACKINGGAP,
    MACHINE_SUPPORTAPETUREBLOCK,
    MACHINE_SUPPORTSHIELDBLOCK,
    MACHINE_SOURCETOBLOCKTRAYDISTANCE,
    MACHINE_BLOCKHEIGHT,
    MACHINE_MAXPATIENTPERHOUR,
    MACHINE_BLOCKTHICKNESS,
    MACHINE_SOURCETOWEDGETOPDISTANCE,
    MACHINE_SOURCETOAPPLICATORDISTANCE,
    MACHINE_CRC,
    MACHINE_STATE,
    MACHINE_FORCEJAWFOLLOW,
    MACHINE_INACTIVEREASON,
    MACHINE_INACTIVETIME,
    MACHINE_INACTIVEUSER,
    MACHINE_UPDATETIME,
    MACHINE_MINGANTRYSPEED_DEGREEPERSECOND,
    MACHINE_MAXLEAFACC_MMPERSEC2,
    MACHINE_FIELD_MAX
};

static const char* ENUM2STRING_MACHINE_FIELD[] =
{
    "UID",
    "NAME",
    "TYPE",
    "MANUFACTURER",
    "GANTRYMAX",
    "GANTRYMIN",
    "SAD",
    "TABLELATERALMAX",
    "TABLELATERALMIN",
    "TABLELONGITUDINALMAX",
    "TABLELONGITUDINALMIN",
    "TABLEVERTICALMAX",
    "TABLEVERTICALMIN",
    "TABLEANGLEMAX",
    "TABLEANGLEMIN",
    "COLLIMATORDIRECTION",
    "MLCDIRECTIONTYPE",
    "JAWXISSYMMETRY",
    "JAWYISSYMMETRY",
    "XJAWNUM",
    "YJAWNUM",
    "LEAFNUM",
    "LEAFBOUNDARIES",
    "NEGATIVELEAFRANGEMIN",
    "NEGATIVELEAFRANGEMAX",
    "POSITIVELEAFRANGEMIN",
    "POSITIVELEAFRANGEMAX",
    "ISINTERDIGITATION",
    "LEAFSPAN",
    "MINLEAFENDGAP",
    "SDD",
    "SOURCETOBEAMLIMITINGDEVICEDISTANCE",
    "XINDEPENDENT",
    "XMIN_1",
    "XMAX_1",
    "XMIN_2",
    "XMAX_2",
    "XMIN_W",
    "XMAX_W",
    "XSDD",
    "XNAME_1",
    "XNAME_2",
    "XISXJAWLIMIT",
    "YINDEPENDENT",
    "YMIN_1",
    "YMAX_1",
    "YMIN_2",
    "YMAX_2",
    "YMIN_W",
    "YMAX_W",
    "YSDD",
    "YNAME_1",
    "YNAME_2",
    "YISXJAWLIMIT",
    "MAXIMUMGANTRYSPEED_DEGREEPERSECOND",
    "MAXIMUMLEAFSPEED_MMPERSECOND",
    "DEVICEID",
    "COMMENTS",
    "COLLIMATORANGLEMIN",
    "COLLIMATORANGLEMAX",
    "GANTRYCLOCKWISERANGE",
    "GANTRYCOUNTERCLOCKWISERANGE",
    "AVAILABLEPLANTYPE",
    "MAXIMUMJAWSPEED_MMPERSECOND",
    "MINIMUMJAWGAP",
    "DYNAMICTRACKINGJAWX",
    "DYNAMICTRACKINGJAWY",
    "SOURCETOMLCTOPDISTANCE",
    "JAWTRACKINGGAP",
    "SUPPORTAPETUREBLOCK",
    "SUPPORTSHIELDBLOCK",
    "SOURCETOBLOCKTRAYDISTANCE",
    "BLOCKHEIGHT",
    "MAXPATIENTPERHOUR",
    "BLOCKTHICKNESS",
    "SOURCETOWEDGETOPDISTANCE",
    "SOURCETOAPPLICATORDISTANCE",
    "CRC",
    "STATE",
    "FORCEJAWFOLLOW",
    "INACTIVEREASON",
    "INACTIVETIME",
    "INACTIVEUSER",
    "UPDATETIME",
    "MINGANTRYSPEED_DEGREEPERSECOND",
    "MAXLEAFACC_MMPERSEC2",
    "MACHINE_FIELD_MAX"
};

static const char* ENUM2STRING_MACHINE_FIELD_NULL = "10000000000000000000000000000000000000000000000000000000000000000000000000000000000100";

typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

class RtMachineImp;

class RT_DB_EXPORT RtMachine : public RtDatabaseObject
{
public:

    //default is false to improve performance
    RtMachine(bool bGeneraterUid = false);

    ~RtMachine();

    RtMachine(const RtMachine& machine);

    RtMachine& operator = (const RtMachine& machine);

    /*uid varchar
      pk*/
    std::string get_uid() const;
    void set_uid(const std::string& uid);

    /*name varchar
      Treatment machine name*/
    std::string get_name() const;
    void set_name(const std::string& name);

    /*type varchar
      Treatment machine type*/
    std::string get_type() const;
    void set_type(const std::string& type);

    /*manufacturer varchar
      Treatment machine manufacturer*/
    std::string get_manufacturer() const;
    void set_manufacturer(const std::string& manufacturer);

    /*gantrymax double
      Gantry Angle Tolerance*/
    double get_gantrymax() const;
    void set_gantrymax(const double& gantrymax);

    /*gantrymin double
      Gantry Angle Tolerance*/
    double get_gantrymin() const;
    void set_gantrymin(const double& gantrymin);

    /*sad double
      (300A00B4):Radiation source to Gantry rotation axis distance of the equipment that is to be used for beam delivery (mm).*/
    double get_sad() const;
    void set_sad(const double& sad);

    /*tablelateralmax double
      Max value
            Table Top Lateral Position Tolerance*/
    double get_tablelateralmax() const;
    void set_tablelateralmax(const double& tablelateralmax);

    /*tablelateralmin double
      Min value
            Table Top Lateral Position Tolerance*/
    double get_tablelateralmin() const;
    void set_tablelateralmin(const double& tablelateralmin);

    /*tablelongitudinalmax double
      Max value
            Table Top Longitudinal Position Tolerance*/
    double get_tablelongitudinalmax() const;
    void set_tablelongitudinalmax(const double& tablelongitudinalmax);

    /*tablelongitudinalmin double
      Min value
            Table Top Longitudinal Position Tolerance*/
    double get_tablelongitudinalmin() const;
    void set_tablelongitudinalmin(const double& tablelongitudinalmin);

    /*tableverticalmax double
      Max value
            Table Top Vertical Position Tolerance*/
    double get_tableverticalmax() const;
    void set_tableverticalmax(const double& tableverticalmax);

    /*tableverticalmin double
      Min value
            Table Top Vertical Position Tolerance*/
    double get_tableverticalmin() const;
    void set_tableverticalmin(const double& tableverticalmin);

    /*tableanglemax double
      Max value
            Table Top Roll Angle Tolerance*/
    double get_tableanglemax() const;
    void set_tableanglemax(const double& tableanglemax);

    /*tableanglemin double
      Min value
            Table Top Roll Angle Tolerance*/
    double get_tableanglemin() const;
    void set_tableanglemin(const double& tableanglemin);

    /*collimatordirection int
      Enum CW ，CC*/
    int get_collimatordirection() const;
    void set_collimatordirection(const int& collimatordirection);

    /*mlcdirectiontype int
      MLCX_DIRECTION
            MLCY_DIRECTION,*/
    int get_mlcdirectiontype() const;
    void set_mlcdirectiontype(const int& mlcdirectiontype);

    /*jawxissymmetry tinyint
          JAW_X = 1,
                JAW_Y,
            JAW_X_Y,
            JAW_ASYMX,
            JAW_ASYMX_ASYMY,
            JAW_ASYMY,
            JAW_X_ASYMY,
            JAW_Y_ASYMX*/
    bool get_jawxissymmetry() const;
    void set_jawxissymmetry(const bool& jawxissymmetry);

    /*jawyissymmetry tinyint
      标志Yjaw是否为对称位*/
    bool get_jawyissymmetry() const;
    void set_jawyissymmetry(const bool& jawyissymmetry);

    /*xjawnum int
      X direction jaw number*/
    int get_xjawnum() const;
    void set_xjawnum(const int& xjawnum);

    /*yjawnum int
      Y direction jaw number*/
    int get_yjawnum() const;
    void set_yjawnum(const int& yjawnum);

    /*leafnum int
      leaf total count*/
    int get_leafnum() const;
    void set_leafnum(const int& leafnum);

    /*leafboundaries varchar
      Boundaries information of mlc. (Boundaries number = m_iLeaivesNum + 1)*/
    std::string get_leafboundaries() const;
    void set_leafboundaries(const std::string& leafbounds);
    std::vector<double> get_leafboundaries_list() const;
    void set_leafboundaries_list(const std::vector<double>& leafbounds);

    /*negativeleafrangemin double
      Negative direction means left for X axis,bottom for Y axis*/
    double get_negativeleafrangemin() const;
    void set_negativeleafrangemin(const double& negativeleafrangemin);

    /*negativeleafrangemax double
      Negative direction means left for X axis,bottom for Y axis*/
    double get_negativeleafrangemax() const;
    void set_negativeleafrangemax(const double& negativeleafrangemax);

    /*positiveleafrangemin double
      Positive direction means right for X axis,upper for Y axis*/
    double get_positiveleafrangemin() const;
    void set_positiveleafrangemin(const double& positiveleafrangemin);

    /*positiveleafrangemax double
      Positive direction means right for X axis,upper for Y axis*/
    double get_positiveleafrangemax() const;
    void set_positiveleafrangemax(const double& positiveleafrangemax);

    /*isinterdigitation tinyint
      allow Interdigitation or not*/
    bool get_isinterdigitation() const;
    void set_isinterdigitation(const bool& isinterdigitation);

    /*leafspan float
      length of leaf span (maximum leaf position difference between leaves on the same side)*/
    float get_leafspan() const;
    void set_leafspan(const float& leafspan);

    /*minleafendgap float
      minimum separation between opposing leaf end pairs*/
    float get_minleafendgap() const;
    void set_minleafendgap(const float& minleafendgap);

    /*sdd float
      jaw到靶距离*/
    float get_sdd() const;
    void set_sdd(const float& sdd);

    /*sourcetobeamlimitingdevicedistance float
      靶到jaw距离*/
    float get_sourcetobeamlimitingdevicedistance() const;
    void set_sourcetobeamlimitingdevicedistance(const float& sourcetobeamlimitingdevicedistance);

    /*xindependent int
      0:symmetric 1:independent 2:MLC 3:MLC-non divergent*/
    int get_xindependent() const;
    void set_xindependent(const int& xindependent);

    /*xmin_1 float
      leftmost or bottommost travel */
    float get_xmin_1() const;
    void set_xmin_1(const float& xmin_1);

    /*xmax_1 float
      rightmost or topmost travel*/
    float get_xmax_1() const;
    void set_xmax_1(const float& xmax_1);

    /*xmin_2 float
      leftmost or bottommost travel*/
    float get_xmin_2() const;
    void set_xmin_2(const float& xmin_2);

    /*xmax_2 float
      rightmost or topmost travel*/
    float get_xmax_2() const;
    void set_xmax_2(const float& xmax_2);

    /*xmin_w float
      start of jaw orthogonal to jaw travel dir*/
    float get_xmin_w() const;
    void set_xmin_w(const float& xmin_w);

    /*xmax_w float
      end of jaw*/
    float get_xmax_w() const;
    void set_xmax_w(const float& xmax_w);

    /*xsdd float
      primary source to jaw (diaphram) distance*/
    float get_xsdd() const;
    void set_xsdd(const float& xsdd);

    /*xname_1 varchar
      name_1[NAME_LENGTH]*/
    std::string get_xname_1() const;
    void set_xname_1(const std::string& xname_1);

    /*xname_2 varchar
      name_2[NAME_LENGTH]*/
    std::string get_xname_2() const;
    void set_xname_2(const std::string& xname_2);

    /*xisxjawlimit tinyint
      m_bIsXJawLimit,char  name_1[NAME_LENGTH], name_2[NAME_LENGTH];*/
    bool get_xisxjawlimit() const;
    void set_xisxjawlimit(const bool& xisxjawlimit);

    /*yindependent int
      */
    int get_yindependent() const;
    void set_yindependent(const int& yindependent);

    /*ymin_1 float
      RTFWKDLDOJawLimits m_pJawLimitY ymin_1*/
    float get_ymin_1() const;
    void set_ymin_1(const float& ymin_1);

    /*ymax_1 float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ymax_1() const;
    void set_ymax_1(const float& ymax_1);

    /*ymin_2 float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ymin_2() const;
    void set_ymin_2(const float& ymin_2);

    /*ymax_2 float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ymax_2() const;
    void set_ymax_2(const float& ymax_2);

    /*ymin_w float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ymin_w() const;
    void set_ymin_w(const float& ymin_w);

    /*ymax_w float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ymax_w() const;
    void set_ymax_w(const float& ymax_w);

    /*ysdd float
      RTFWKDLDOJawLimits m_pJawLimitY */
    float get_ysdd() const;
    void set_ysdd(const float& ysdd);

    /*yname_1 varchar
      RTFWKDLDOJawLimits m_pJawLimitY */
    std::string get_yname_1() const;
    void set_yname_1(const std::string& yname_1);

    /*yname_2 varchar
      RTFWKDLDOJawLimits m_pJawLimitY */
    std::string get_yname_2() const;
    void set_yname_2(const std::string& yname_2);

    /*yisxjawlimit tinyint
      RTFWKDLDOJawLimits m_pJawLimitY */
    bool get_yisxjawlimit() const;
    void set_yisxjawlimit(const bool& yisxjawlimit);

    /*maximumgantryspeed_degreepersecond float
      gantry最大转速*/
    float get_maximumgantryspeed_degreepersecond() const;
    void set_maximumgantryspeed_degreepersecond(const float& maximumgantryspeed_degreepersecond);

    /*maximumleafspeed_mmpersecond float
       Add on 20141013 by Jingjie.zhou*/
    float get_maximumleafspeed_mmpersecond() const;
    void set_maximumleafspeed_mmpersecond(const float& maximumleafspeed_mmpersecond);

    /*deviceid varchar
      机器序列号*/
    std::string get_deviceid() const;
    void set_deviceid(const std::string& deviceid);

    /*comments varchar
      描述*/
    std::string get_comments() const;
    void set_comments(const std::string& comments);

    /*collimatoranglemin double
      最小collimator角度*/
    double get_collimatoranglemin() const;
    void set_collimatoranglemin(const double& collimatoranglemin);

    /*collimatoranglemax double
      最大collimator角度*/
    double get_collimatoranglemax() const;
    void set_collimatoranglemax(const double& collimatoranglemax);

    /*gantryclockwiserange double
      gantry顺时针转动范围*/
    double get_gantryclockwiserange() const;
    void set_gantryclockwiserange(const double& gantryclockwiserange);

    /*gantrycounterclockwiserange double
      gantry逆时针转动范围*/
    double get_gantrycounterclockwiserange() const;
    void set_gantrycounterclockwiserange(const double& gantrycounterclockwiserange);

    /*availableplantype varchar
      支持计划类型*/
    std::string get_availableplantype() const;
    void set_availableplantype(const std::string& availableplantype);

    /*maximumjawspeed_mmpersecond float
      jaw最大移动速度*/
    float get_maximumjawspeed_mmpersecond() const;
    void set_maximumjawspeed_mmpersecond(const float& maximumjawspeed_mmpersecond);

    /*minimumjawgap float
      jaw最小间距*/
    float get_minimumjawgap() const;
    void set_minimumjawgap(const float& minimumjawgap);

    /*dynamictrackingjawx tinyint
      是否支持x jaw动态跟随*/
    bool get_dynamictrackingjawx() const;
    void set_dynamictrackingjawx(const bool& dynamictrackingjawx);

    /*dynamictrackingjawy tinyint
      gantry逆时针转动范围*/
    bool get_dynamictrackingjawy() const;
    void set_dynamictrackingjawy(const bool& dynamictrackingjawy);

    /*sourcetomlctopdistance float
      靶到block tray距离*/
    float get_sourcetomlctopdistance() const;
    void set_sourcetomlctopdistance(const float& sourcetomlctopdistance);

    /*jawtrackinggap float
      jaw跟随mlc的距离*/
    float get_jawtrackinggap() const;
    void set_jawtrackinggap(const float& jawtrackinggap);

    /*supportapetureblock tinyint
      是否支持aperture block*/
    bool get_supportapetureblock() const;
    void set_supportapetureblock(const bool& supportapetureblock);

    /*supportshieldblock tinyint
      是否支持shielding block*/
    bool get_supportshieldblock() const;
    void set_supportshieldblock(const bool& supportshieldblock);

    /*sourcetoblocktraydistance float
      靶到block tray距离*/
    float get_sourcetoblocktraydistance() const;
    void set_sourcetoblocktraydistance(const float& sourcetoblocktraydistance);

    /*blockheight float
      附件挡块的高度*/
    float get_blockheight() const;
    void set_blockheight(const float& blockheight);

    /*maxpatientperhour int
      每小时最大病人数*/
    int get_maxpatientperhour() const;
    void set_maxpatientperhour(const int& maxpatientperhour);

    /*blockthickness float
      附件挡块的厚度*/
    float get_blockthickness() const;
    void set_blockthickness(const float& blockthickness);

    /*sourcetowedgetopdistance float
      靶到wedge上表面距离*/
    float get_sourcetowedgetopdistance() const;
    void set_sourcetowedgetopdistance(const float& sourcetowedgetopdistance);

    /*sourcetoapplicatordistance float
      靶到applicator距离*/
    float get_sourcetoapplicatordistance() const;
    void set_sourcetoapplicatordistance(const float& sourcetoapplicatordistance);

    /*crc varchar
      校验*/
    std::string get_crc() const;
    void set_crc(const std::string& crc);

    /*state int
      状态,现在machine需要添加Active功能*/
    int get_state() const;
    void set_state(const int& state);

    /*forcejawfollow tinyint
      该machine是否强制钨门跟随*/
    bool get_forcejawfollow() const;
    void set_forcejawfollow(const bool& forcejawfollow);

    /*inactivereason varchar
      该machine被inactive的原因*/
    std::string get_inactivereason() const;
    void set_inactivereason(const std::string& inactivereason);

    /*inactivetime datetime
      该machine被inactive的时间*/
    DATETIME_BOOST get_inactivetime() const;
    void set_inactivetime(const DATETIME_BOOST& inactivetime);

    /*inactiveuser varchar
      该machine被谁inactive*/
    std::string get_inactiveuser() const;
    void set_inactiveuser(const std::string& inactiveuser);

    /*updatetime timestamp
      时间戳*/
    DATETIME_BOOST get_updatetime() const;
    void set_updatetime(const DATETIME_BOOST& updatetime);

	/*mingantryspeed_degreepersecond float
      gantry最小速度*/
    float get_mingantryspeed_degreepersecond() const;
    void set_mingantryspeed_degreepersecond(const float& mingantryspeed_degreepersecond);

    /*maxleafacc_mmpersec2 float
      叶片最大加速度*/
    float get_maxleafacc_mmpersec2() const;
    void set_maxleafacc_mmpersec2(const float& maxleafacc_mmpersec2);
	
    //////////////////////////////////////////////////////////////////////////
    bool get_crc_valid() const;
    void set_crc_valid(const bool& crc_valid);


private:
    friend class boost::serialization::access;
    template<class Archive>
    void serialize( Archive &ar,const unsigned int version) {
  	  version;
	  ar & BOOST_SERIALIZATION_BASE_OBJECT_NVP(RtDatabaseObject);
	  ar & BOOST_SERIALIZATION_NVP(m_pImp);
    }
    RtMachineImp*                   m_pImp;
};


//////////////////////////////////////////////////////////////////////////
//for imp

class RtMachineImp
{

public:
    //default is false to improve performance
    RT_DB_EXPORT RtMachineImp(bool bGeneraterUid = false);

    virtual ~RtMachineImp();

    RtMachineImp(const RtMachineImp& machine);

    RtMachineImp& operator = (const RtMachineImp& machine);

    //uid
    inline std::string get_uid() const { return m_uid;}
    inline void set_uid(const std::string& uid) { m_uid = uid;}

    //name
    inline std::string get_name() const { return m_name;}
    inline void set_name(const std::string& name) { m_name = name;}

    //type
    inline std::string get_type() const { return m_type;}
    inline void set_type(const std::string& type) { m_type = type;}

    //manufacturer
    inline std::string get_manufacturer() const { return m_manufacturer;}
    inline void set_manufacturer(const std::string& manufacturer) { m_manufacturer = manufacturer;}

    //gantrymax
    inline double get_gantrymax() const { return m_gantrymax;}
    inline void set_gantrymax(const double& gantrymax) { m_gantrymax = gantrymax;}

    //gantrymin
    inline double get_gantrymin() const { return m_gantrymin;}
    inline void set_gantrymin(const double& gantrymin) { m_gantrymin = gantrymin;}

    //sad
    inline double get_sad() const { return m_sad;}
    inline void set_sad(const double& sad) { m_sad = sad;}

    //tablelateralmax
    inline double get_tablelateralmax() const { return m_tablelateralmax;}
    inline void set_tablelateralmax(const double& tablelateralmax) { m_tablelateralmax = tablelateralmax;}

    //tablelateralmin
    inline double get_tablelateralmin() const { return m_tablelateralmin;}
    inline void set_tablelateralmin(const double& tablelateralmin) { m_tablelateralmin = tablelateralmin;}

    //tablelongitudinalmax
    inline double get_tablelongitudinalmax() const { return m_tablelongitudinalmax;}
    inline void set_tablelongitudinalmax(const double& tablelongitudinalmax) { m_tablelongitudinalmax = tablelongitudinalmax;}

    //tablelongitudinalmin
    inline double get_tablelongitudinalmin() const { return m_tablelongitudinalmin;}
    inline void set_tablelongitudinalmin(const double& tablelongitudinalmin) { m_tablelongitudinalmin = tablelongitudinalmin;}

    //tableverticalmax
    inline double get_tableverticalmax() const { return m_tableverticalmax;}
    inline void set_tableverticalmax(const double& tableverticalmax) { m_tableverticalmax = tableverticalmax;}

    //tableverticalmin
    inline double get_tableverticalmin() const { return m_tableverticalmin;}
    inline void set_tableverticalmin(const double& tableverticalmin) { m_tableverticalmin = tableverticalmin;}

    //tableanglemax
    inline double get_tableanglemax() const { return m_tableanglemax;}
    inline void set_tableanglemax(const double& tableanglemax) { m_tableanglemax = tableanglemax;}

    //tableanglemin
    inline double get_tableanglemin() const { return m_tableanglemin;}
    inline void set_tableanglemin(const double& tableanglemin) { m_tableanglemin = tableanglemin;}

    //collimatordirection
    inline int get_collimatordirection() const { return m_collimatordirection;}
    inline void set_collimatordirection(const int& collimatordirection) { m_collimatordirection = collimatordirection;}

    //mlcdirectiontype
    inline int get_mlcdirectiontype() const { return m_mlcdirectiontype;}
    inline void set_mlcdirectiontype(const int& mlcdirectiontype) { m_mlcdirectiontype = mlcdirectiontype;}

    //jawxissymmetry
    inline bool get_jawxissymmetry() const { return m_jawxissymmetry;}
    inline void set_jawxissymmetry(const bool& jawxissymmetry) { m_jawxissymmetry = jawxissymmetry;}

    //jawyissymmetry
    inline bool get_jawyissymmetry() const { return m_jawyissymmetry;}
    inline void set_jawyissymmetry(const bool& jawyissymmetry) { m_jawyissymmetry = jawyissymmetry;}

    //xjawnum
    inline int get_xjawnum() const { return m_xjawnum;}
    inline void set_xjawnum(const int& xjawnum) { m_xjawnum = xjawnum;}

    //yjawnum
    inline int get_yjawnum() const { return m_yjawnum;}
    inline void set_yjawnum(const int& yjawnum) { m_yjawnum = yjawnum;}

    //leafnum
    inline int get_leafnum() const { return m_leafnum;}
    inline void set_leafnum(const int& leafnum) { m_leafnum = leafnum;}

    //leafboundaries
    inline std::string get_leafboundaries() const { return m_leafboundaries;};
    inline void set_leafboundaries(const std::string& leafbounds) {m_leafboundaries = leafbounds;}

    inline std::vector<double> get_leafboundaries_list() const { return m_leafboundaries_list;};
    inline void set_leafboundaries_list(const std::vector<double>& leafbounds) {m_leafboundaries_list = leafbounds;}

    //negativeleafrangemin
    inline double get_negativeleafrangemin() const { return m_negativeleafrangemin;}
    inline void set_negativeleafrangemin(const double& negativeleafrangemin) { m_negativeleafrangemin = negativeleafrangemin;}

    //negativeleafrangemax
    inline double get_negativeleafrangemax() const { return m_negativeleafrangemax;}
    inline void set_negativeleafrangemax(const double& negativeleafrangemax) { m_negativeleafrangemax = negativeleafrangemax;}

    //positiveleafrangemin
    inline double get_positiveleafrangemin() const { return m_positiveleafrangemin;}
    inline void set_positiveleafrangemin(const double& positiveleafrangemin) { m_positiveleafrangemin = positiveleafrangemin;}

    //positiveleafrangemax
    inline double get_positiveleafrangemax() const { return m_positiveleafrangemax;}
    inline void set_positiveleafrangemax(const double& positiveleafrangemax) { m_positiveleafrangemax = positiveleafrangemax;}

    //isinterdigitation
    inline bool get_isinterdigitation() const { return m_isinterdigitation;}
    inline void set_isinterdigitation(const bool& isinterdigitation) { m_isinterdigitation = isinterdigitation;}

    //leafspan
    inline float get_leafspan() const { return m_leafspan;}
    inline void set_leafspan(const float& leafspan) { m_leafspan = leafspan;}

    //minleafendgap
    inline float get_minleafendgap() const { return m_minleafendgap;}
    inline void set_minleafendgap(const float& minleafendgap) { m_minleafendgap = minleafendgap;}

    //sdd
    inline float get_sdd() const { return m_sdd;}
    inline void set_sdd(const float& sdd) { m_sdd = sdd;}

    //sourcetobeamlimitingdevicedistance
    inline float get_sourcetobeamlimitingdevicedistance() const { return m_sourcetobeamlimitingdevicedistance;}
    inline void set_sourcetobeamlimitingdevicedistance(const float& sourcetobeamlimitingdevicedistance) { m_sourcetobeamlimitingdevicedistance = sourcetobeamlimitingdevicedistance;}

    //xindependent
    inline int get_xindependent() const { return m_xindependent;}
    inline void set_xindependent(const int& xindependent) { m_xindependent = xindependent;}

    //xmin_1
    inline float get_xmin_1() const { return m_xmin_1;}
    inline void set_xmin_1(const float& xmin_1) { m_xmin_1 = xmin_1;}

    //xmax_1
    inline float get_xmax_1() const { return m_xmax_1;}
    inline void set_xmax_1(const float& xmax_1) { m_xmax_1 = xmax_1;}

    //xmin_2
    inline float get_xmin_2() const { return m_xmin_2;}
    inline void set_xmin_2(const float& xmin_2) { m_xmin_2 = xmin_2;}

    //xmax_2
    inline float get_xmax_2() const { return m_xmax_2;}
    inline void set_xmax_2(const float& xmax_2) { m_xmax_2 = xmax_2;}

    //xmin_w
    inline float get_xmin_w() const { return m_xmin_w;}
    inline void set_xmin_w(const float& xmin_w) { m_xmin_w = xmin_w;}

    //xmax_w
    inline float get_xmax_w() const { return m_xmax_w;}
    inline void set_xmax_w(const float& xmax_w) { m_xmax_w = xmax_w;}

    //xsdd
    inline float get_xsdd() const { return m_xsdd;}
    inline void set_xsdd(const float& xsdd) { m_xsdd = xsdd;}

    //xname_1
    inline std::string get_xname_1() const { return m_xname_1;}
    inline void set_xname_1(const std::string& xname_1) { m_xname_1 = xname_1;}

    //xname_2
    inline std::string get_xname_2() const { return m_xname_2;}
    inline void set_xname_2(const std::string& xname_2) { m_xname_2 = xname_2;}

    //xisxjawlimit
    inline bool get_xisxjawlimit() const { return m_xisxjawlimit;}
    inline void set_xisxjawlimit(const bool& xisxjawlimit) { m_xisxjawlimit = xisxjawlimit;}

    //yindependent
    inline int get_yindependent() const { return m_yindependent;}
    inline void set_yindependent(const int& yindependent) { m_yindependent = yindependent;}

    //ymin_1
    inline float get_ymin_1() const { return m_ymin_1;}
    inline void set_ymin_1(const float& ymin_1) { m_ymin_1 = ymin_1;}

    //ymax_1
    inline float get_ymax_1() const { return m_ymax_1;}
    inline void set_ymax_1(const float& ymax_1) { m_ymax_1 = ymax_1;}

    //ymin_2
    inline float get_ymin_2() const { return m_ymin_2;}
    inline void set_ymin_2(const float& ymin_2) { m_ymin_2 = ymin_2;}

    //ymax_2
    inline float get_ymax_2() const { return m_ymax_2;}
    inline void set_ymax_2(const float& ymax_2) { m_ymax_2 = ymax_2;}

    //ymin_w
    inline float get_ymin_w() const { return m_ymin_w;}
    inline void set_ymin_w(const float& ymin_w) { m_ymin_w = ymin_w;}

    //ymax_w
    inline float get_ymax_w() const { return m_ymax_w;}
    inline void set_ymax_w(const float& ymax_w) { m_ymax_w = ymax_w;}

    //ysdd
    inline float get_ysdd() const { return m_ysdd;}
    inline void set_ysdd(const float& ysdd) { m_ysdd = ysdd;}

    //yname_1
    inline std::string get_yname_1() const { return m_yname_1;}
    inline void set_yname_1(const std::string& yname_1) { m_yname_1 = yname_1;}

    //yname_2
    inline std::string get_yname_2() const { return m_yname_2;}
    inline void set_yname_2(const std::string& yname_2) { m_yname_2 = yname_2;}

    //yisxjawlimit
    inline bool get_yisxjawlimit() const { return m_yisxjawlimit;}
    inline void set_yisxjawlimit(const bool& yisxjawlimit) { m_yisxjawlimit = yisxjawlimit;}

    //maximumgantryspeed_degreepersecond
    inline float get_maximumgantryspeed_degreepersecond() const { return m_maximumgantryspeed_degreepersecond;}
    inline void set_maximumgantryspeed_degreepersecond(const float& maximumgantryspeed_degreepersecond) { m_maximumgantryspeed_degreepersecond = maximumgantryspeed_degreepersecond;}

    //maximumleafspeed_mmpersecond
    inline float get_maximumleafspeed_mmpersecond() const { return m_maximumleafspeed_mmpersecond;}
    inline void set_maximumleafspeed_mmpersecond(const float& maximumleafspeed_mmpersecond) { m_maximumleafspeed_mmpersecond = maximumleafspeed_mmpersecond;}

    //deviceid
    inline std::string get_deviceid() const { return m_deviceid;}
    inline void set_deviceid(const std::string& deviceid) { m_deviceid = deviceid;}

    //comments
    inline std::string get_comments() const { return m_comments;}
    inline void set_comments(const std::string& comments) { m_comments = comments;}

    //collimatoranglemin
    inline double get_collimatoranglemin() const { return m_collimatoranglemin;}
    inline void set_collimatoranglemin(const double& collimatoranglemin) { m_collimatoranglemin = collimatoranglemin;}

    //collimatoranglemax
    inline double get_collimatoranglemax() const { return m_collimatoranglemax;}
    inline void set_collimatoranglemax(const double& collimatoranglemax) { m_collimatoranglemax = collimatoranglemax;}

    //gantryclockwiserange
    inline double get_gantryclockwiserange() const { return m_gantryclockwiserange;}
    inline void set_gantryclockwiserange(const double& gantryclockwiserange) { m_gantryclockwiserange = gantryclockwiserange;}

    //gantrycounterclockwiserange
    inline double get_gantrycounterclockwiserange() const { return m_gantrycounterclockwiserange;}
    inline void set_gantrycounterclockwiserange(const double& gantrycounterclockwiserange) { m_gantrycounterclockwiserange = gantrycounterclockwiserange;}

    //availableplantype
    inline std::string get_availableplantype() const { return m_availableplantype;}
    inline void set_availableplantype(const std::string& availableplantype) { m_availableplantype = availableplantype;}

    //maximumjawspeed_mmpersecond
    inline float get_maximumjawspeed_mmpersecond() const { return m_maximumjawspeed_mmpersecond;}
    inline void set_maximumjawspeed_mmpersecond(const float& maximumjawspeed_mmpersecond) { m_maximumjawspeed_mmpersecond = maximumjawspeed_mmpersecond;}

    //minimumjawgap
    inline float get_minimumjawgap() const { return m_minimumjawgap;}
    inline void set_minimumjawgap(const float& minimumjawgap) { m_minimumjawgap = minimumjawgap;}

    //dynamictrackingjawx
    inline bool get_dynamictrackingjawx() const { return m_dynamictrackingjawx;}
    inline void set_dynamictrackingjawx(const bool& dynamictrackingjawx) { m_dynamictrackingjawx = dynamictrackingjawx;}

    //dynamictrackingjawy
    inline bool get_dynamictrackingjawy() const { return m_dynamictrackingjawy;}
    inline void set_dynamictrackingjawy(const bool& dynamictrackingjawy) { m_dynamictrackingjawy = dynamictrackingjawy;}

    //sourcetomlctopdistance
    inline float get_sourcetomlctopdistance() const { return m_sourcetomlctopdistance;}
    inline void set_sourcetomlctopdistance(const float& sourcetomlctopdistance) { m_sourcetomlctopdistance = sourcetomlctopdistance;}

    //jawtrackinggap
    inline float get_jawtrackinggap() const { return m_jawtrackinggap;}
    inline void set_jawtrackinggap(const float& jawtrackinggap) { m_jawtrackinggap = jawtrackinggap;}

    //supportapetureblock
    inline bool get_supportapetureblock() const { return m_supportapetureblock;}
    inline void set_supportapetureblock(const bool& supportapetureblock) { m_supportapetureblock = supportapetureblock;}

    //supportshieldblock
    inline bool get_supportshieldblock() const { return m_supportshieldblock;}
    inline void set_supportshieldblock(const bool& supportshieldblock) { m_supportshieldblock = supportshieldblock;}

    //sourcetoblocktraydistance
    inline float get_sourcetoblocktraydistance() const { return m_sourcetoblocktraydistance;}
    inline void set_sourcetoblocktraydistance(const float& sourcetoblocktraydistance) { m_sourcetoblocktraydistance = sourcetoblocktraydistance;}

    //blockheight
    inline float get_blockheight() const { return m_blockheight;}
    inline void set_blockheight(const float& blockheight) { m_blockheight = blockheight;}

    //maxpatientperhour
    inline int get_maxpatientperhour() const { return m_maxpatientperhour;}
    inline void set_maxpatientperhour(const int& maxpatientperhour) { m_maxpatientperhour = maxpatientperhour;}

    //blockthickness
    inline float get_blockthickness() const { return m_blockthickness;}
    inline void set_blockthickness(const float& blockthickness) { m_blockthickness = blockthickness;}

    //sourcetowedgetopdistance
    inline float get_sourcetowedgetopdistance() const { return m_sourcetowedgetopdistance;}
    inline void set_sourcetowedgetopdistance(const float& sourcetowedgetopdistance) { m_sourcetowedgetopdistance = sourcetowedgetopdistance;}

    //sourcetoapplicatordistance
    inline float get_sourcetoapplicatordistance() const { return m_sourcetoapplicatordistance;}
    inline void set_sourcetoapplicatordistance(const float& sourcetoapplicatordistance) { m_sourcetoapplicatordistance = sourcetoapplicatordistance;}

    //crc
    inline std::string get_crc() const { return m_crc;}
    inline void set_crc(const std::string& crc) { m_crc = crc;}

    //state
    inline int get_state() const { return m_state;}
    inline void set_state(const int& state) { m_state = state;}

    //forcejawfollow
    inline bool get_forcejawfollow() const { return m_forcejawfollow;}
    inline void set_forcejawfollow(const bool& forcejawfollow) { m_forcejawfollow = forcejawfollow;}

    //inactivereason
    inline std::string get_inactivereason() const { return m_inactivereason;}
    inline void set_inactivereason(const std::string& inactivereason) { m_inactivereason = inactivereason;}

    //inactivetime
    inline DATETIME_BOOST get_inactivetime() const { return m_inactivetime;}
    inline void set_inactivetime(const DATETIME_BOOST& inactivetime) { m_inactivetime = inactivetime;}

    //inactiveuser
    inline std::string get_inactiveuser() const { return m_inactiveuser;}
    inline void set_inactiveuser(const std::string& inactiveuser) { m_inactiveuser = inactiveuser;}

    //updatetime
    inline DATETIME_BOOST get_updatetime() const { return m_updatetime;}
    inline void set_updatetime(const DATETIME_BOOST& updatetime) { m_updatetime = updatetime;}

	//mingantryspeed_degreepersecond
    inline float get_mingantryspeed_degreepersecond() const { return m_mingantryspeed_degreepersecond;}
    inline void set_mingantryspeed_degreepersecond(const float& mingantryspeed_degreepersecond) { m_mingantryspeed_degreepersecond = mingantryspeed_degreepersecond;}

    //maxleafacc_mmpersec2
    inline float get_maxleafacc_mmpersec2() const { return m_maxleafacc_mmpersec2;}
    inline void set_maxleafacc_mmpersec2(const float& maxleafacc_mmpersec2) { m_maxleafacc_mmpersec2 = maxleafacc_mmpersec2;}
    //////////////////////////////////////////////////////////////////////////
    inline bool get_crc_valid() const { return m_crc_valid;}
    inline void set_crc_valid(const bool& crc_valid) { m_crc_valid = crc_valid;}

private:    //81 parameters
	friend class boost::serialization::access;
	template<class Archive>
	void serialize(Archive &ar, const unsigned int version) {
		version;
		ar & BOOST_SERIALIZATION_NVP(m_uid);
		ar & BOOST_SERIALIZATION_NVP(m_name);
		ar & BOOST_SERIALIZATION_NVP(m_type);
		ar & BOOST_SERIALIZATION_NVP(m_manufacturer);
		ar & BOOST_SERIALIZATION_NVP(m_gantrymax);
		ar & BOOST_SERIALIZATION_NVP(m_gantrymin);
		ar & BOOST_SERIALIZATION_NVP(m_sad);
		ar & BOOST_SERIALIZATION_NVP(m_tablelateralmax);
		ar & BOOST_SERIALIZATION_NVP(m_tablelateralmin);
		ar & BOOST_SERIALIZATION_NVP(m_tablelongitudinalmax);
		ar & BOOST_SERIALIZATION_NVP(m_tablelongitudinalmin);
		ar & BOOST_SERIALIZATION_NVP(m_tableverticalmax);
		ar & BOOST_SERIALIZATION_NVP(m_tableverticalmin);
		ar & BOOST_SERIALIZATION_NVP(m_tableanglemax);
		ar & BOOST_SERIALIZATION_NVP(m_tableanglemin);
		ar & BOOST_SERIALIZATION_NVP(m_collimatordirection);
		ar & BOOST_SERIALIZATION_NVP(m_mlcdirectiontype);
		ar & BOOST_SERIALIZATION_NVP(m_jawxissymmetry);
		ar & BOOST_SERIALIZATION_NVP(m_jawyissymmetry);
		ar & BOOST_SERIALIZATION_NVP(m_xjawnum);
		ar & BOOST_SERIALIZATION_NVP(m_yjawnum);
		ar & BOOST_SERIALIZATION_NVP(m_leafnum);
		ar & BOOST_SERIALIZATION_NVP(m_leafboundaries);
		ar & BOOST_SERIALIZATION_NVP(m_leafboundaries_list);
		ar & BOOST_SERIALIZATION_NVP(m_negativeleafrangemin);
		ar & BOOST_SERIALIZATION_NVP(m_negativeleafrangemax);
		ar & BOOST_SERIALIZATION_NVP(m_positiveleafrangemin);
		ar & BOOST_SERIALIZATION_NVP(m_positiveleafrangemax);
		ar & BOOST_SERIALIZATION_NVP(m_isinterdigitation);
		ar & BOOST_SERIALIZATION_NVP(m_leafspan);
		ar & BOOST_SERIALIZATION_NVP(m_minleafendgap);
		ar & BOOST_SERIALIZATION_NVP(m_sdd);
		ar & BOOST_SERIALIZATION_NVP(m_sourcetobeamlimitingdevicedistance);
		ar & BOOST_SERIALIZATION_NVP(m_xindependent);
		ar & BOOST_SERIALIZATION_NVP(m_xmin_1);
		ar & BOOST_SERIALIZATION_NVP(m_xmax_1);
		ar & BOOST_SERIALIZATION_NVP(m_xmin_2);
		ar & BOOST_SERIALIZATION_NVP(m_xmax_2);
		ar & BOOST_SERIALIZATION_NVP(m_xmin_w);
		ar & BOOST_SERIALIZATION_NVP(m_xmax_w);
		ar & BOOST_SERIALIZATION_NVP(m_xsdd);
		ar & BOOST_SERIALIZATION_NVP(m_xname_1);
		ar & BOOST_SERIALIZATION_NVP(m_xname_2);
		ar & BOOST_SERIALIZATION_NVP(m_xisxjawlimit);
		ar & BOOST_SERIALIZATION_NVP(m_yindependent);
		ar & BOOST_SERIALIZATION_NVP(m_ymin_1);
		ar & BOOST_SERIALIZATION_NVP(m_ymax_1);
		ar & BOOST_SERIALIZATION_NVP(m_ymin_2);
		ar & BOOST_SERIALIZATION_NVP(m_ymax_2);
		ar & BOOST_SERIALIZATION_NVP(m_ymin_w);
		ar & BOOST_SERIALIZATION_NVP(m_ymax_w);
		ar & BOOST_SERIALIZATION_NVP(m_ysdd);
		ar & BOOST_SERIALIZATION_NVP(m_yname_1);
		ar & BOOST_SERIALIZATION_NVP(m_yname_2);
		ar & BOOST_SERIALIZATION_NVP(m_yisxjawlimit);
		ar & BOOST_SERIALIZATION_NVP(m_maximumgantryspeed_degreepersecond);
		ar & BOOST_SERIALIZATION_NVP(m_maximumleafspeed_mmpersecond);
		ar & BOOST_SERIALIZATION_NVP(m_deviceid);
		ar & BOOST_SERIALIZATION_NVP(m_comments);
		ar & BOOST_SERIALIZATION_NVP(m_collimatoranglemin);
		ar & BOOST_SERIALIZATION_NVP(m_collimatoranglemax);
		ar & BOOST_SERIALIZATION_NVP(m_gantryclockwiserange);
		ar & BOOST_SERIALIZATION_NVP(m_gantrycounterclockwiserange);
		ar & BOOST_SERIALIZATION_NVP(m_availableplantype);
		ar & BOOST_SERIALIZATION_NVP(m_maximumjawspeed_mmpersecond);
		ar & BOOST_SERIALIZATION_NVP(m_minimumjawgap);
		ar & BOOST_SERIALIZATION_NVP(m_dynamictrackingjawx);
		ar & BOOST_SERIALIZATION_NVP(m_dynamictrackingjawy);
		ar & BOOST_SERIALIZATION_NVP(m_sourcetomlctopdistance);
		ar & BOOST_SERIALIZATION_NVP(m_jawtrackinggap);
		ar & BOOST_SERIALIZATION_NVP(m_supportapetureblock);
		ar & BOOST_SERIALIZATION_NVP(m_supportshieldblock);
		ar & BOOST_SERIALIZATION_NVP(m_sourcetoblocktraydistance);
		ar & BOOST_SERIALIZATION_NVP(m_blockheight);
		ar & BOOST_SERIALIZATION_NVP(m_maxpatientperhour);
		ar & BOOST_SERIALIZATION_NVP(m_blockthickness);
		ar & BOOST_SERIALIZATION_NVP(m_sourcetowedgetopdistance);
		ar & BOOST_SERIALIZATION_NVP(m_sourcetoapplicatordistance);
		ar & BOOST_SERIALIZATION_NVP(m_crc);
		ar & BOOST_SERIALIZATION_NVP(m_state);
		ar & BOOST_SERIALIZATION_NVP(m_forcejawfollow);
		ar & BOOST_SERIALIZATION_NVP(m_inactivereason);
		ar & BOOST_SERIALIZATION_NVP(m_inactivetime);
		ar & BOOST_SERIALIZATION_NVP(m_inactiveuser);
		ar & BOOST_SERIALIZATION_NVP(m_updatetime);
		ar & BOOST_SERIALIZATION_NVP(m_mingantryspeed_degreepersecond);
		ar & BOOST_SERIALIZATION_NVP(m_maxleafacc_mmpersec2);
	}
    std::string						m_uid;
    std::string						m_name;
    std::string						m_type;
    std::string						m_manufacturer;
    double							m_gantrymax;
    double							m_gantrymin;
    double							m_sad;
    double							m_tablelateralmax;
    double							m_tablelateralmin;
    double							m_tablelongitudinalmax;
    double							m_tablelongitudinalmin;
    double							m_tableverticalmax;
    double							m_tableverticalmin;
    double							m_tableanglemax;
    double							m_tableanglemin;
    int								m_collimatordirection;
    int								m_mlcdirectiontype;
    bool							m_jawxissymmetry;
    bool							m_jawyissymmetry;
    int								m_xjawnum;
    int								m_yjawnum;
    int								m_leafnum;
    std::string                     m_leafboundaries;  
    std::vector<double>              m_leafboundaries_list;
    double							m_negativeleafrangemin;
    double							m_negativeleafrangemax;
    double							m_positiveleafrangemin;
    double							m_positiveleafrangemax;
    bool							m_isinterdigitation;
    float							m_leafspan;
    float							m_minleafendgap;
    float							m_sdd;
    float							m_sourcetobeamlimitingdevicedistance;
    int								m_xindependent;
    float							m_xmin_1;
    float							m_xmax_1;
    float							m_xmin_2;
    float							m_xmax_2;
    float							m_xmin_w;
    float							m_xmax_w;
    float							m_xsdd;
    std::string						m_xname_1;
    std::string						m_xname_2;
    bool							m_xisxjawlimit;
    int								m_yindependent;
    float							m_ymin_1;
    float							m_ymax_1;
    float							m_ymin_2;
    float							m_ymax_2;
    float							m_ymin_w;
    float							m_ymax_w;
    float							m_ysdd;
    std::string						m_yname_1;
    std::string						m_yname_2;
    bool							m_yisxjawlimit;
    float							m_maximumgantryspeed_degreepersecond;
    float							m_maximumleafspeed_mmpersecond;
    std::string						m_deviceid;
    std::string						m_comments;
    double							m_collimatoranglemin;
    double							m_collimatoranglemax;
    double							m_gantryclockwiserange;
    double							m_gantrycounterclockwiserange;
    std::string						m_availableplantype;
    float							m_maximumjawspeed_mmpersecond;
    float							m_minimumjawgap;
    bool							m_dynamictrackingjawx;
    bool							m_dynamictrackingjawy;
    float							m_sourcetomlctopdistance;
    float							m_jawtrackinggap;
    bool							m_supportapetureblock;
    bool							m_supportshieldblock;
    float							m_sourcetoblocktraydistance;
    float							m_blockheight;
    int								m_maxpatientperhour;
    float							m_blockthickness;
    float							m_sourcetowedgetopdistance;
    float							m_sourcetoapplicatordistance;
    std::string						m_crc;
    int								m_state;
    bool							m_forcejawfollow;
    std::string						m_inactivereason;
    DATETIME_BOOST					m_inactivetime;
    std::string						m_inactiveuser;
    DATETIME_BOOST					m_updatetime;
	float							m_mingantryspeed_degreepersecond;
    float							m_maxleafacc_mmpersec2;
    //////////////////////////////////////////////////////////////////////////
    bool                            m_crc_valid;
};

RT_TPS_DATABASE_END_NAMESPACE
#endif
