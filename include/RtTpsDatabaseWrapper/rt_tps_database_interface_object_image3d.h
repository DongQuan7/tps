//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2015
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_interface_object_image3d.h
///  \brief     NO table in database
///
///  \version 1.0
///  \date    July 10,2015
///  \{
//////////////////////////////////////////////////////////////////////////

#ifndef RT_TPS_DATABASE_INTERFACE_OBJECT_IMAGE3D_H_
#define RT_TPS_DATABASE_INTERFACE_OBJECT_IMAGE3D_H_

#include "RtTpsDatabaseWrapper/rt_tps_database_defs.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_data.h"
#include <vector>
#include "boost/date_time/gregorian/gregorian_types.hpp"
#include "boost/date_time/posix_time/posix_time_types.hpp"


RT_TPS_DATABASE_BEGIN_NAMESPACE;

#define ABSURDLY_LARGE_MAX_SCANS 4096

/////////////////////////////////////////////////////////////////
///  @class    RTFWKDLDOPerScanInfo
///
///  @brief    
/////////////////////////////////////////////////////////////////
class RT_DB_EXPORT RtImage3DPerScanInfo
{
public:
    RtImage3DPerScanInfo();

    virtual ~RtImage3DPerScanInfo();

    RtImage3DPerScanInfo(const RtImage3DPerScanInfo& oPerScanInfo);

    RtImage3DPerScanInfo& operator = (const RtImage3DPerScanInfo& perScanInfo);

    //////////////////////////////////////////////////////////////////////////
    /// ImagePositionPatient
    //////////////////////////////////////////////////////////////////////////
    db_Point3f m_ImagePosition;

    /////////////////////////////////////////////////////////////////
    /// file offset to start of slice data
    /////////////////////////////////////////////////////////////////
    unsigned int m_uiFileOffset;

    /////////////////////////////////////////////////////////////////
    /// SOP instance UID
    /////////////////////////////////////////////////////////////////
    char m_cSOPInstanceUID[64];

    ////////////////////////////////////////////////////////////////
    //instance number start from 1
    ////////////////////////////////////////////////////////////////
    unsigned int m_uiInstanceNumber;

    /////////////////////////////////////////////////////////////////
    /// Image UID
    /// Add on 20150309 for Chunhui.Shi
    /////////////////////////////////////////////////////////////////
    std::string m_sUID;

    //////////////////////////////////////////////////////////////////////////
    /// Image SliceLocation
    /// Add on 20170821 by qiang.xu
    //////////////////////////////////////////////////////////////////////////
    float m_SliceLocation;

    //////////////////////////////////////////////////////////////////////////
    /// Image bitsStored
    /// Add on 20170821 by qiang.xu
    //////////////////////////////////////////////////////////////////////////
    int m_BitsStored;

};

/////////////////////////////////////////////////////////////////
///  @class    RTFWKDLDOImage3DHeader
///
///  @brief    
/////////////////////////////////////////////////////////////////
class RT_DB_EXPORT RtImage3DHeader
{
public:
    RtImage3DHeader();

    virtual ~RtImage3DHeader();

    RtImage3DHeader(const RtImage3DHeader& oImage3DHeader);

    RtImage3DHeader operator= (const RtImage3DHeader& oImage3DHeader);

    /////////////////////////////////////////////////////////////////
    /// Person Scan Information
    /////////////////////////////////////////////////////////////////
    //RTFWKDLDOPerScanInfo m_ScanInfoList[ABSURDLY_LARGE_MAX_SCANS];
    std::vector<RtImage3DPerScanInfo>   m_vScanInfoList;
    //if the size is same as m_vScanInfoList, that means no interpolation
    void GetInterpolation(bool*& pInter, int* iInterCount) const;
    void SetInterpolation(const bool* pInter, const int iInterCount);

    /////////////////////////////////////////////////////////////////
    /// 
    /////////////////////////////////////////////////////////////////
    double m_dScaleSlope;

    /////////////////////////////////////////////////////////////////
    /// 
    /////////////////////////////////////////////////////////////////
    double m_dScaleIntercept;

    /////////////////////////////////////////////////////////////////
    /// 
    /////////////////////////////////////////////////////////////////
    int m_iSliceCount;

    /////////////////////////////////////////////////////////////////
    /// rows
    /////////////////////////////////////////////////////////////////
    int m_iXDim;

    /////////////////////////////////////////////////////////////////
    /// columns, defaults to x_dim=y_dim=resolution
    /////////////////////////////////////////////////////////////////
    int m_iYDim;

    /////////////////////////////////////////////////////////////////
    /// pixel spacing
    /////////////////////////////////////////////////////////////////
    double m_dXSize;

    /////////////////////////////////////////////////////////////////
    /// pixel spacing, defaults to x_size=y_size=pixel_size
    /////////////////////////////////////////////////////////////////
    double m_dYSize;

    /////////////////////////////////////////////////////////////////
    /// the volume default WindowWidth
    /////////////////////////////////////////////////////////////////
    int m_iWindowWidth;

    /////////////////////////////////////////////////////////////////
    /// the volume default WindowCenter
    /////////////////////////////////////////////////////////////////
    int m_iWindowCenter;

    /////////////////////////////////////////////////////////////////
    /// flag to decide whether the slices are equal spacing in z axis
    /////////////////////////////////////////////////////////////////
    bool m_bIsEqualSliceSpacing;

    /////////////////////////////////////////////////////////////////
    /// if isEqualSpacing == true , spacing is the spacing in z axis between neighbour slices ,else spacing = 0
    /////////////////////////////////////////////////////////////////
    float m_fSliceSpacing;    

    //////////////////////////////////////////////////////////////////////////
    /// modality
    //////////////////////////////////////////////////////////////////////////
    char m_cModality[6];

    //////////////////////////////////////////////////////////////////////////
    /// Pixel representation
    //////////////////////////////////////////////////////////////////////////
    int m_iDataType;

    //////////////////////////////////////////////////////////////////////////
    /// Bits Allocated
    //////////////////////////////////////////////////////////////////////////
    int m_iBitsAllocated;

    //////////////////////////////////////////////////////////////////////////
    /// ImageOrientationPatient, X
    //////////////////////////////////////////////////////////////////////////
    db_Vector3f m_ImageXOrientation;

    //////////////////////////////////////////////////////////////////////////
    /// ImageOrientationPatient, Y
    //////////////////////////////////////////////////////////////////////////
    db_Vector3f m_ImageYOrientation;

    //////////////////////////////////////////////////////////////////////////
    /// Patient Position
    //////////////////////////////////////////////////////////////////////////
    char m_cPatientPosition[6];

    /// #[tag field]
    std::string m_sManufacturerModelName;

    /// #[tag field]
    std::string m_tAcquisitionDateTime;

    /// #[tag field]
    std::string  m_sFrameOfReferenceUID;

private:
    int         m_iInterCount;
    bool*       m_pInterpolation;

};

RT_TPS_DATABASE_END_NAMESPACE

#endif 
