//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_voi.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.11
///
///  \version 1.0
///  \date    8/8/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_voi.h"
#include "boost/algorithm/string/split.hpp"
#include "boost/algorithm/string/classification.hpp"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtVoi& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //54 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < VOI_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_VOI_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmsvoi SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < VOI_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_VOI_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmsvoi (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_structuresetuid = "";
    std::string	data_conceptualvolumeuid = "";
    std::string	data_name = "";
    bool		data_isbolus = false;
    float		data_xcoordinate3dmax = 0.f;
    float		data_ycoordinate3dmax = 0.f;
    float		data_zcoordinate3dmax = 0.f;
    float		data_xcoordinate3dmin = 0.f;
    float		data_ycoordinate3dmin = 0.f;
    float		data_zcoordinate3dmin = 0.f;
    int			data_orientation = 0;
    float		data_volume = 0.f;
    float		data_density = 0.f;
    std::string	data_lockuseruid = "";
    MYSQL_TIME	data_locktime;
    std::string	data_lockmacaddress = "";
    float		data_red = 0.f;
    float		data_green = 0.f;
    float		data_blue = 0.f;
    float		data_alpha = 0.f;
    float		data_averagedensity = 0.f;
    float		data_maxdensity = 0.f;
    float		data_mindensity = 0.f;
    float		data_surfacearea = 0.f;
    float		data_centroidx = 0.f;
    float		data_centroidy = 0.f;
    float		data_centroidz = 0.f;
    int			data_voirole = 0;
    float		data_standarddeviation = 0.f;
    bool		data_isvisible = false;
    int			data_rtroiinterpretedtype = 0;
    std::string	data_roiinterpreter = "";
    int			data_referencesubvolumeoffsetx = 0;
    int			data_referencesubvolumeoffsety = 0;
    int			data_referencesubvolumeoffsetz = 0;
    int			data_referencesubvolumesizex = 0;
    int			data_referencesubvolumesizey = 0;
    int			data_referencesubvolumesizez = 0;
    std::string	data_referencesubvolumedatafilepath = "";
    std::string	data_pat2volumematrix = "";
    std::string	data_interpolate = "";
    int			data_locktype = 0;
    int			data_planningrole = 0;
    int			data_subrole = 0;
    float		data_overridedenstiy = 0.f;
    float		data_tcpntcp = 0.f;
    bool		data_isoverride = false;
    std::string	data_description = "";
    float		data_alpha3d = 0.f;
    int			data_roinumberindcm = 0;
    MYSQL_TIME	data_updatetime;
    std::string	data_softwareversionno = "";
    bool		data_isshaded = false;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < VOI_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//structuresetuid varchar
            {
                data_structuresetuid = src.get_structuresetuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_structuresetuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_structuresetuid.size();
            }
            break;
        case 2: 	//conceptualvolumeuid varchar
            {
                data_conceptualvolumeuid = src.get_conceptualvolumeuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_conceptualvolumeuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_conceptualvolumeuid.size();
            }
            break;
        case 3: 	//name varchar
            {
                data_name = src.get_name();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_name.c_str();
                bind[iCount].buffer_length = (unsigned long)data_name.size();
            }
            break;
        case 4: 	//isbolus tinyint
            {
                data_isbolus = src.get_isbolus();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isbolus;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 5: 	//xcoordinate3dmax float
            {
                data_xcoordinate3dmax = src.get_xcoordinate3dmax();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xcoordinate3dmax;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 6: 	//ycoordinate3dmax float
            {
                data_ycoordinate3dmax = src.get_ycoordinate3dmax();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ycoordinate3dmax;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 7: 	//zcoordinate3dmax float
            {
                data_zcoordinate3dmax = src.get_zcoordinate3dmax();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_zcoordinate3dmax;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 8: 	//xcoordinate3dmin float
            {
                data_xcoordinate3dmin = src.get_xcoordinate3dmin();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xcoordinate3dmin;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 9: 	//ycoordinate3dmin float
            {
                data_ycoordinate3dmin = src.get_ycoordinate3dmin();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ycoordinate3dmin;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 10: 	//zcoordinate3dmin float
            {
                data_zcoordinate3dmin = src.get_zcoordinate3dmin();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_zcoordinate3dmin;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 11: 	//orientation int
            {
                data_orientation = src.get_orientation();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_orientation;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 12: 	//volume float
            {
                data_volume = src.get_volume();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_volume;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 13: 	//density float
            {
                data_density = src.get_density();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_density;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 14: 	//lockuseruid varchar
            {
                data_lockuseruid = src.get_lockuseruid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_lockuseruid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_lockuseruid.size();
            }
            break;
        case 15: 	//locktime datetime
            {
                ConvertDateTime2DB(src.get_locktime(), &data_locktime);
                bind[iCount].buffer_type = MYSQL_TYPE_DATETIME;
                bind[iCount].buffer = (void*)&data_locktime;
                if (src.get_locktime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 16: 	//lockmacaddress varchar
            {
                data_lockmacaddress = src.get_lockmacaddress();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_lockmacaddress.c_str();
                bind[iCount].buffer_length = (unsigned long)data_lockmacaddress.size();
            }
            break;
        case 17: 	//red float
            {
                data_red = src.get_color()[0];
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_red;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 18: 	//green float
            {
                data_green = src.get_color()[1];
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_green;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 19: 	//blue float
            {
                data_blue = src.get_color()[2];
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_blue;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 20: 	//alpha float
            {
                data_alpha = src.get_color()[3];
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_alpha;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 21: 	//averagedensity float
            {
                data_averagedensity = src.get_averagedensity();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_averagedensity;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 22: 	//maxdensity float
            {
                data_maxdensity = src.get_maxdensity();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_maxdensity;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 23: 	//mindensity float
            {
                data_mindensity = src.get_mindensity();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_mindensity;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 24: 	//surfacearea float
            {
                data_surfacearea = src.get_surfacearea();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_surfacearea;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 25: 	//centroidx float
            {
                data_centroidx = src.get_centroidx();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_centroidx;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 26: 	//centroidy float
            {
                data_centroidy = src.get_centroidy();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_centroidy;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 27: 	//centroidz float
            {
                data_centroidz = src.get_centroidz();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_centroidz;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 28: 	//voirole int
            {
                data_voirole = src.get_voirole();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_voirole;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 29: 	//standarddeviation float
            {
                data_standarddeviation = src.get_standarddeviation();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_standarddeviation;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 30: 	//isvisible tinyint
            {
                data_isvisible = src.get_isvisible();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isvisible;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 31: 	//rtroiinterpretedtype int
            {
                data_rtroiinterpretedtype = src.get_rtroiinterpretedtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_rtroiinterpretedtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 32: 	//roiinterpreter varchar
            {
                data_roiinterpreter = src.get_roiinterpreter();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_roiinterpreter.c_str();
                bind[iCount].buffer_length = (unsigned long)data_roiinterpreter.size();
            }
            break;
        case 33: 	//referencesubvolumeoffsetx int
            {
                data_referencesubvolumeoffsetx = src.get_referencesubvolumeoffsetx();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumeoffsetx;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 34: 	//referencesubvolumeoffsety int
            {
                data_referencesubvolumeoffsety = src.get_referencesubvolumeoffsety();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumeoffsety;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 35: 	//referencesubvolumeoffsetz int
            {
                data_referencesubvolumeoffsetz = src.get_referencesubvolumeoffsetz();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumeoffsetz;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 36: 	//referencesubvolumesizex int
            {
                data_referencesubvolumesizex = src.get_referencesubvolumesizex();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumesizex;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 37: 	//referencesubvolumesizey int
            {
                data_referencesubvolumesizey = src.get_referencesubvolumesizey();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumesizey;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 38: 	//referencesubvolumesizez int
            {
                data_referencesubvolumesizez = src.get_referencesubvolumesizez();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_referencesubvolumesizez;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 39: 	//referencesubvolumedatafilepath varchar
            {
                data_referencesubvolumedatafilepath = src.get_referencesubvolumedatafilepath();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_referencesubvolumedatafilepath.c_str();
                bind[iCount].buffer_length = (unsigned long)data_referencesubvolumedatafilepath.size();
            }
            break;
        case 40: 	//pat2volumematrix varchar
            {
                const float* matrix = src.get_pat2volumematrix(); 
                if (nullptr != matrix){
                    for (int y(0); y<4; ++y){
                        for (int x(0); x<4; ++x){
                            data_pat2volumematrix += std::to_string(long double(matrix[x + y*4])) + ((3==y && 3==x)? "":",");
                        }
                    }
                }
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_pat2volumematrix.c_str();
                bind[iCount].buffer_length = (unsigned long)data_pat2volumematrix.size();
            }
            break;
        case 41: 	//interpolate varchar
            {
                const std::vector<bool>& vValue = src.get_interpolate();
                int iCnt(0);
                for (auto itr=vValue.cbegin(); itr!=vValue.cend(); ++itr, ++iCnt)
                {
                    data_interpolate += ((*itr)? "1":"0"); 
                    data_interpolate += (iCnt!=vValue.size()-1 ? ",":"");
                }
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_interpolate.c_str();
                bind[iCount].buffer_length = (unsigned long)data_interpolate.size();
            }
            break;
        case 42: 	//locktype int
            {
                data_locktype = src.get_locktype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_locktype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 43: 	//planningrole int
            {
                data_planningrole = src.get_planningrole();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_planningrole;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 44: 	//subrole int
            {
                data_subrole = src.get_subrole();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_subrole;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 45: 	//overridedenstiy float
            {
                data_overridedenstiy = src.get_overridedenstiy();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_overridedenstiy;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 46: 	//tcpntcp float
            {
                data_tcpntcp = src.get_tcpntcp();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_tcpntcp;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 47: 	//isoverride tinyint
            {
                data_isoverride = src.get_isoverride();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isoverride;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 48: 	//description varchar
            {
                data_description = src.get_description();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_description.c_str();
                bind[iCount].buffer_length = (unsigned long)data_description.size();
            }
            break;
        case 49: 	//alpha3d float
            {
                data_alpha3d = src.get_alpha3d();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_alpha3d;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 50: 	//roinumberindcm int
            {
                data_roinumberindcm = src.get_roinumberindcm();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_roinumberindcm;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 51: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 52: 	//softwareversionno varchar
            {
                data_softwareversionno = src.get_softwareversionno();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_softwareversionno.c_str();
                bind[iCount].buffer_length = (unsigned long)data_softwareversionno.size();
            }
            break;
        case 53: 	//isshaded tinyint
            {
                data_isshaded = src.get_isshaded();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isshaded;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
	DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtVoi*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtVoi*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsvoi    54 parameters
    const int field_num = VOI_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 64;
    MAX_LENGTH[3] = 1024;
    MAX_LENGTH[4] = 0;
    MAX_LENGTH[5] = 0;
    MAX_LENGTH[6] = 0;
    MAX_LENGTH[7] = 0;
    MAX_LENGTH[8] = 0;
    MAX_LENGTH[9] = 0;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 0;
    MAX_LENGTH[12] = 0;
    MAX_LENGTH[13] = 0;
    MAX_LENGTH[14] = 64;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 64;
    MAX_LENGTH[17] = 0;
    MAX_LENGTH[18] = 0;
    MAX_LENGTH[19] = 0;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 0;
    MAX_LENGTH[23] = 0;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;
    MAX_LENGTH[26] = 0;
    MAX_LENGTH[27] = 0;
    MAX_LENGTH[28] = 0;
    MAX_LENGTH[29] = 0;
    MAX_LENGTH[30] = 0;
    MAX_LENGTH[31] = 0;
    MAX_LENGTH[32] = 1024;
    MAX_LENGTH[33] = 0;
    MAX_LENGTH[34] = 0;
    MAX_LENGTH[35] = 0;
    MAX_LENGTH[36] = 0;
    MAX_LENGTH[37] = 0;
    MAX_LENGTH[38] = 0;
    MAX_LENGTH[39] = 1024;
    MAX_LENGTH[40] = 2048;
    MAX_LENGTH[41] = 4096;
    MAX_LENGTH[42] = 0;
    MAX_LENGTH[43] = 0;
    MAX_LENGTH[44] = 0;
    MAX_LENGTH[45] = 0;
    MAX_LENGTH[46] = 0;
    MAX_LENGTH[47] = 0;
    MAX_LENGTH[48] = 1024;
    MAX_LENGTH[49] = 0;
    MAX_LENGTH[50] = 0;
    MAX_LENGTH[51] = 0;
    MAX_LENGTH[52] = 64;
    MAX_LENGTH[53] = 0;

    //std::string	data_uid
    //std::string	data_structuresetuid
    //std::string	data_conceptualvolumeuid
    //std::string	data_name
    bool	data_isbolus = false;
    float	data_xcoordinate3dmax = 0.f;
    float	data_ycoordinate3dmax = 0.f;
    float	data_zcoordinate3dmax = 0.f;
    float	data_xcoordinate3dmin = 0.f;
    float	data_ycoordinate3dmin = 0.f;
    float	data_zcoordinate3dmin = 0.f;
    int	data_orientation = 0;
    float	data_volume = 0.f;
    float	data_density = 0.f;
    //std::string	data_lockuseruid
    MYSQL_TIME	data_locktime;
    //std::string	data_lockmacaddress
    float	data_red = 0.f;
    float	data_green = 0.f;
    float	data_blue = 0.f;
    float	data_alpha = 0.f;
    float	data_averagedensity = 0.f;
    float	data_maxdensity = 0.f;
    float	data_mindensity = 0.f;
    float	data_surfacearea = 0.f;
    float	data_centroidx = 0.f;
    float	data_centroidy = 0.f;
    float	data_centroidz = 0.f;
    int	data_voirole = 0;
    float	data_standarddeviation = 0.f;
    bool	data_isvisible = false;
    int	data_rtroiinterpretedtype = 0;
    //std::string	data_roiinterpreter
    int	data_referencesubvolumeoffsetx = 0;
    int	data_referencesubvolumeoffsety = 0;
    int	data_referencesubvolumeoffsetz = 0;
    int	data_referencesubvolumesizex = 0;
    int	data_referencesubvolumesizey = 0;
    int	data_referencesubvolumesizez = 0;
    //std::string	data_referencesubvolumedatafilepath
    //std::string	data_pat2volumematrix
    //std::string	data_interpolate
    int	data_locktype = 0;
    int	data_planningrole = 0;
    int	data_subrole = 0;
    float	data_overridedenstiy = 0.f;
    float	data_tcpntcp = 0.f;
    bool	data_isoverride = false;
    //std::string	data_description
    float	data_alpha3d = 0.f;
    int	data_roinumberindcm = 0;
    MYSQL_TIME	data_updatetime;
    //std::string	data_softwareversionno
    bool	data_isshaded = false;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 4: 	//isbolus tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isbolus;
            break;
        case 5: 	//xcoordinate3dmax float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xcoordinate3dmax;
            break;
        case 6: 	//ycoordinate3dmax float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ycoordinate3dmax;
            break;
        case 7: 	//zcoordinate3dmax float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_zcoordinate3dmax;
            break;
        case 8: 	//xcoordinate3dmin float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xcoordinate3dmin;
            break;
        case 9: 	//ycoordinate3dmin float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ycoordinate3dmin;
            break;
        case 10: 	//zcoordinate3dmin float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_zcoordinate3dmin;
            break;
        case 11: 	//orientation int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_orientation;
            break;
        case 12: 	//volume float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_volume;
            break;
        case 13: 	//density float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_density;
            break;
        case 15: 	//locktime datetime
            bind[i].buffer_type= MYSQL_TYPE_DATETIME;
            bind[i].buffer= (char *)&data_locktime;
            break;
        case 17: 	//red float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_red;
            break;
        case 18: 	//green float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_green;
            break;
        case 19: 	//blue float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_blue;
            break;
        case 20: 	//alpha float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_alpha;
            break;
        case 21: 	//averagedensity float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_averagedensity;
            break;
        case 22: 	//maxdensity float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maxdensity;
            break;
        case 23: 	//mindensity float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_mindensity;
            break;
        case 24: 	//surfacearea float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_surfacearea;
            break;
        case 25: 	//centroidx float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_centroidx;
            break;
        case 26: 	//centroidy float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_centroidy;
            break;
        case 27: 	//centroidz float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_centroidz;
            break;
        case 28: 	//voirole int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_voirole;
            break;
        case 29: 	//standarddeviation float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_standarddeviation;
            break;
        case 30: 	//isvisible tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isvisible;
            break;
        case 31: 	//rtroiinterpretedtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_rtroiinterpretedtype;
            break;
        case 33: 	//referencesubvolumeoffsetx int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumeoffsetx;
            break;
        case 34: 	//referencesubvolumeoffsety int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumeoffsety;
            break;
        case 35: 	//referencesubvolumeoffsetz int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumeoffsetz;
            break;
        case 36: 	//referencesubvolumesizex int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumesizex;
            break;
        case 37: 	//referencesubvolumesizey int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumesizey;
            break;
        case 38: 	//referencesubvolumesizez int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_referencesubvolumesizez;
            break;
        case 42: 	//locktype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_locktype;
            break;
        case 43: 	//planningrole int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_planningrole;
            break;
        case 44: 	//subrole int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_subrole;
            break;
        case 45: 	//overridedenstiy float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_overridedenstiy;
            break;
        case 46: 	//tcpntcp float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_tcpntcp;
            break;
        case 47: 	//isoverride tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isoverride;
            break;
        case 49: 	//alpha3d float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_alpha3d;
            break;
        case 50: 	//roinumberindcm int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_roinumberindcm;
            break;
        case 51: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        case 53: 	//isshaded tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isshaded;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtVoi* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtVoi();
        const float* fColor = pDis->get_color();
        float fColorNew[4] = {0};
        memcpy(fColorNew, fColor, sizeof(float)*4);
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//structuresetuid varchar
                pDis->set_structuresetuid((char *)bind[i].buffer);
                break;
            case 2: 	//conceptualvolumeuid varchar
                pDis->set_conceptualvolumeuid((char *)bind[i].buffer);
                break;
            case 3: 	//name varchar
                pDis->set_name((char *)bind[i].buffer);
                break;
            case 4: 	//isbolus tinyint
                pDis->set_isbolus(data_isbolus);
                break;
            case 5: 	//xcoordinate3dmax float
                pDis->set_xcoordinate3dmax(data_xcoordinate3dmax);
                break;
            case 6: 	//ycoordinate3dmax float
                pDis->set_ycoordinate3dmax(data_ycoordinate3dmax);
                break;
            case 7: 	//zcoordinate3dmax float
                pDis->set_zcoordinate3dmax(data_zcoordinate3dmax);
                break;
            case 8: 	//xcoordinate3dmin float
                pDis->set_xcoordinate3dmin(data_xcoordinate3dmin);
                break;
            case 9: 	//ycoordinate3dmin float
                pDis->set_ycoordinate3dmin(data_ycoordinate3dmin);
                break;
            case 10: 	//zcoordinate3dmin float
                pDis->set_zcoordinate3dmin(data_zcoordinate3dmin);
                break;
            case 11: 	//orientation int
                pDis->set_orientation(data_orientation);
                break;
            case 12: 	//volume float
                pDis->set_volume(data_volume);
                break;
            case 13: 	//density float
                pDis->set_density(data_density);
                break;
            case 14: 	//lockuseruid varchar
                pDis->set_lockuseruid((char *)bind[i].buffer);
                break;
            case 15: 	//locktime datetime
                {
                    DATETIME_BOOST locktime;
                    ConvertDateTime2Boost(data_locktime, &locktime);
                    pDis->set_locktime(locktime);
                }
                break;
            case 16: 	//lockmacaddress varchar
                pDis->set_lockmacaddress((char *)bind[i].buffer);
                break;
            case 17: 	//red float
                {
                    fColorNew[0] = data_red;
                    pDis->set_color(fColorNew);
                }
                break;
            case 18: 	//green float
                {
                    fColorNew[1] = data_green;
                    pDis->set_color(fColorNew);
                }
                break;
            case 19: 	//blue float
                {
                    fColorNew[2] = data_blue;
                    pDis->set_color(fColorNew);
                }
                break;
            case 20: 	//alpha float
                {
                    fColorNew[3] = data_alpha;
                    pDis->set_color(fColorNew);
                }
                break;
            case 21: 	//averagedensity float
                pDis->set_averagedensity(data_averagedensity);
                break;
            case 22: 	//maxdensity float
                pDis->set_maxdensity(data_maxdensity);
                break;
            case 23: 	//mindensity float
                pDis->set_mindensity(data_mindensity);
                break;
            case 24: 	//surfacearea float
                pDis->set_surfacearea(data_surfacearea);
                break;
            case 25: 	//centroidx float
                pDis->set_centroidx(data_centroidx);
                break;
            case 26: 	//centroidy float
                pDis->set_centroidy(data_centroidy);
                break;
            case 27: 	//centroidz float
                pDis->set_centroidz(data_centroidz);
                break;
            case 28: 	//voirole int
                pDis->set_voirole(data_voirole);
                break;
            case 29: 	//standarddeviation float
                pDis->set_standarddeviation(data_standarddeviation);
                break;
            case 30: 	//isvisible tinyint
                pDis->set_isvisible(data_isvisible);
                break;
            case 31: 	//rtroiinterpretedtype int
                pDis->set_rtroiinterpretedtype(data_rtroiinterpretedtype);
                break;
            case 32: 	//roiinterpreter varchar
                pDis->set_roiinterpreter((char *)bind[i].buffer);
                break;
            case 33: 	//referencesubvolumeoffsetx int
                pDis->set_referencesubvolumeoffsetx(data_referencesubvolumeoffsetx);
                break;
            case 34: 	//referencesubvolumeoffsety int
                pDis->set_referencesubvolumeoffsety(data_referencesubvolumeoffsety);
                break;
            case 35: 	//referencesubvolumeoffsetz int
                pDis->set_referencesubvolumeoffsetz(data_referencesubvolumeoffsetz);
                break;
            case 36: 	//referencesubvolumesizex int
                pDis->set_referencesubvolumesizex(data_referencesubvolumesizex);
                break;
            case 37: 	//referencesubvolumesizey int
                pDis->set_referencesubvolumesizey(data_referencesubvolumesizey);
                break;
            case 38: 	//referencesubvolumesizez int
                pDis->set_referencesubvolumesizez(data_referencesubvolumesizez);
                break;
            case 39: 	//referencesubvolumedatafilepath varchar
                pDis->set_referencesubvolumedatafilepath((char *)bind[i].buffer);
                break;
            case 40: 	//pat2volumematrix varchar
                {
                    std::vector<std::string> subValue;
                    std::string sData = std::string((char *)bind[i].buffer);
                    (void)boost::split(subValue, sData, boost::is_any_of(","));
                    if (subValue.size()!=16) break;
                    float matrix[16];
                    for (int j(0); j<4; ++j){
                        for (int i(0); i<4; ++i){
                            matrix[i + j*4] = subValue[i + j*4].empty()? 0.0f : (float)atof(subValue[i + j*4].c_str());
                        }
                    }
                    pDis->set_pat2volumematrix(matrix);
                }
                break;
            case 41: 	//interpolate varchar
                {
                    std::string sData = std::string((char *)bind[i].buffer);
                    if (sData.empty()) break;
                    std::vector<std::string> subValue;
                    (void)boost::split(subValue, sData, boost::is_any_of(","));
                    std::vector<std::string>::iterator itsubVal = subValue.begin();
                    std::vector<bool> vecValue;
                    for (; itsubVal!=subValue.end(); itsubVal++) {
                        vecValue.push_back((*itsubVal).empty()? false : boost::lexical_cast<bool>((*itsubVal)));
                    }
                    pDis->set_interpolate(vecValue);
                }
                break;
            case 42: 	//locktype int
                pDis->set_locktype(data_locktype);
                break;
            case 43: 	//planningrole int
                pDis->set_planningrole(data_planningrole);
                break;
            case 44: 	//subrole int
                pDis->set_subrole(data_subrole);
                break;
            case 45: 	//overridedenstiy float
                pDis->set_overridedenstiy(data_overridedenstiy);
                break;
            case 46: 	//tcpntcp float
                pDis->set_tcpntcp(data_tcpntcp);
                break;
            case 47: 	//isoverride tinyint
                pDis->set_isoverride(data_isoverride);
                break;
            case 48: 	//description varchar
                pDis->set_description((char *)bind[i].buffer);
                break;
            case 49: 	//alpha3d float
                pDis->set_alpha3d(data_alpha3d);
                break;
            case 50: 	//roinumberindcm int
                pDis->set_roinumberindcm(data_roinumberindcm);
                break;
            case 51: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            case 52: 	//softwareversionno varchar
                pDis->set_softwareversionno((char *)bind[i].buffer);
                break;
            case 53: 	//isshaded tinyint
                pDis->set_isshaded(data_isshaded);
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE