//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_machine.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.11
///
///  \version 1.0
///  \date    8/8/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_machine.h"
#include "rt_tps_database_cryptohash.h"
#include "boost/algorithm/string/split.hpp"
#include "boost/algorithm/string/classification.hpp"
//#include "boost/math/special_functions/round.hpp"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtMachine& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //86 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < MACHINE_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_MACHINE_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmsmachine SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < MACHINE_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_MACHINE_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmsmachine (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_name = "";
    std::string	data_type = "";
    std::string	data_manufacturer = "";
    double		data_gantrymax = 0.;
    double		data_gantrymin = 0.;
    double		data_sad = 0.;
    double		data_tablelateralmax = 0.;
    double		data_tablelateralmin = 0.;
    double		data_tablelongitudinalmax = 0.;
    double		data_tablelongitudinalmin = 0.;
    double		data_tableverticalmax = 0.;
    double		data_tableverticalmin = 0.;
    double		data_tableanglemax = 0.;
    double		data_tableanglemin = 0.;
    int			data_collimatordirection = 0;
    int			data_mlcdirectiontype = 0;
    bool		data_jawxissymmetry = false;
    bool		data_jawyissymmetry = false;
    int			data_xjawnum = 0;
    int			data_yjawnum = 0;
    int			data_leafnum = 0;
    std::string	data_leafboundaries = "";
    double		data_negativeleafrangemin = 0.;
    double		data_negativeleafrangemax = 0.;
    double		data_positiveleafrangemin = 0.;
    double		data_positiveleafrangemax = 0.;
    bool		data_isinterdigitation = false;
    float		data_leafspan = 0.f;
    float		data_minleafendgap = 0.f;
    float		data_sdd = 0.f;
    float		data_sourcetobeamlimitingdevicedistance = 0.f;
    int			data_xindependent = 0;
    float		data_xmin_1 = 0.f;
    float		data_xmax_1 = 0.f;
    float		data_xmin_2 = 0.f;
    float		data_xmax_2 = 0.f;
    float		data_xmin_w = 0.f;
    float		data_xmax_w = 0.f;
    float		data_xsdd = 0.f;
    std::string	data_xname_1 = "";
    std::string	data_xname_2 = "";
    bool		data_xisxjawlimit = false;
    int			data_yindependent = 0;
    float		data_ymin_1 = 0.f;
    float		data_ymax_1 = 0.f;
    float		data_ymin_2 = 0.f;
    float		data_ymax_2 = 0.f;
    float		data_ymin_w = 0.f;
    float		data_ymax_w = 0.f;
    float		data_ysdd = 0.f;
    std::string	data_yname_1 = "";
    std::string	data_yname_2 = "";
    bool		data_yisxjawlimit = false;
    float		data_maximumgantryspeed_degreepersecond = 0.f;
    float		data_maximumleafspeed_mmpersecond = 0.f;
    std::string	data_deviceid = "";
    std::string	data_comments = "";
    double		data_collimatoranglemin = 0.;
    double		data_collimatoranglemax = 0.;
    double		data_gantryclockwiserange = 0.;
    double		data_gantrycounterclockwiserange = 0.;
    std::string	data_availableplantype = "";
    float		data_maximumjawspeed_mmpersecond = 0.f;
    float		data_minimumjawgap = 0.f;
    bool		data_dynamictrackingjawx = false;
    bool		data_dynamictrackingjawy = false;
    float		data_sourcetomlctopdistance = 0.f;
    float		data_jawtrackinggap = 0.f;
    bool		data_supportapetureblock = false;
    bool		data_supportshieldblock = false;
    float		data_sourcetoblocktraydistance = 0.f;
    float		data_blockheight = 0.f;
    int			data_maxpatientperhour = 0;
    float		data_blockthickness = 0.f;
    float		data_sourcetowedgetopdistance = 0.f;
    float		data_sourcetoapplicatordistance = 0.f;
    std::string	data_crc = "";
    int			data_state = 0;
    bool		data_forcejawfollow = false;
    std::string	data_inactivereason = "";
    MYSQL_TIME	data_inactivetime;
    std::string	data_inactiveuser = "";
    MYSQL_TIME	data_updatetime;
    float		data_mingantryspeed_degreepersecond = 0.f;
    float		data_maxleafacc_mmpersec2 = 0.f;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < MACHINE_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//name varchar
            {
                data_name = src.get_name();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_name.c_str();
                bind[iCount].buffer_length = (unsigned long)data_name.size();
            }
            break;
        case 2: 	//type varchar
            {
                data_type = src.get_type();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_type.c_str();
                bind[iCount].buffer_length = (unsigned long)data_type.size();
            }
            break;
        case 3: 	//manufacturer varchar
            {
                data_manufacturer = src.get_manufacturer();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_manufacturer.c_str();
                bind[iCount].buffer_length = (unsigned long)data_manufacturer.size();
            }
            break;
        case 4: 	//gantrymax double
            {
                data_gantrymax = src.get_gantrymax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_gantrymax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 5: 	//gantrymin double
            {
                data_gantrymin = src.get_gantrymin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_gantrymin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 6: 	//sad double
            {
                data_sad = src.get_sad();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_sad;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 7: 	//tablelateralmax double
            {
                data_tablelateralmax = src.get_tablelateralmax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tablelateralmax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 8: 	//tablelateralmin double
            {
                data_tablelateralmin = src.get_tablelateralmin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tablelateralmin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 9: 	//tablelongitudinalmax double
            {
                data_tablelongitudinalmax = src.get_tablelongitudinalmax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tablelongitudinalmax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 10: 	//tablelongitudinalmin double
            {
                data_tablelongitudinalmin = src.get_tablelongitudinalmin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tablelongitudinalmin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 11: 	//tableverticalmax double
            {
                data_tableverticalmax = src.get_tableverticalmax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tableverticalmax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 12: 	//tableverticalmin double
            {
                data_tableverticalmin = src.get_tableverticalmin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tableverticalmin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 13: 	//tableanglemax double
            {
                data_tableanglemax = src.get_tableanglemax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tableanglemax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 14: 	//tableanglemin double
            {
                data_tableanglemin = src.get_tableanglemin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_tableanglemin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 15: 	//collimatordirection int
            {
                data_collimatordirection = src.get_collimatordirection();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_collimatordirection;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 16: 	//mlcdirectiontype int
            {
                data_mlcdirectiontype = src.get_mlcdirectiontype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_mlcdirectiontype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 17: 	//jawxissymmetry tinyint
            {
                data_jawxissymmetry = src.get_jawxissymmetry();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_jawxissymmetry;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 18: 	//jawyissymmetry tinyint
            {
                data_jawyissymmetry = src.get_jawyissymmetry();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_jawyissymmetry;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 19: 	//xjawnum int
            {
                data_xjawnum = src.get_xjawnum();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_xjawnum;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 20: 	//yjawnum int
            {
                data_yjawnum = src.get_yjawnum();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_yjawnum;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 21: 	//leafnum int
            {
                data_leafnum = src.get_leafnum();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_leafnum;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 22: 	//leafboundaries varchar
            {
                std::vector<double> leafboundaries = src.get_leafboundaries_list();
                if(leafboundaries.empty()) bind[iCount].is_null = &isnull;
                const size_t leafSize = leafboundaries.size();
                if (leafSize > 0)
                {
                    data_leafboundaries += std::to_string((long double)(leafboundaries[0]));
                    for (int y(1); y<leafSize; ++y){
                        data_leafboundaries += "\\" + std::to_string((long double)(leafboundaries[y]));
                    }
                }
                bind[iCount].buffer_type= MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer= (void *)data_leafboundaries.c_str();
                bind[iCount].buffer_length= (unsigned long)data_leafboundaries.size();
            }
            break;
        case 23: 	//negativeleafrangemin double
            {
                data_negativeleafrangemin = src.get_negativeleafrangemin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_negativeleafrangemin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 24: 	//negativeleafrangemax double
            {
                data_negativeleafrangemax = src.get_negativeleafrangemax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_negativeleafrangemax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 25: 	//positiveleafrangemin double
            {
                data_positiveleafrangemin = src.get_positiveleafrangemin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_positiveleafrangemin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 26: 	//positiveleafrangemax double
            {
                data_positiveleafrangemax = src.get_positiveleafrangemax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_positiveleafrangemax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 27: 	//isinterdigitation tinyint
            {
                data_isinterdigitation = src.get_isinterdigitation();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isinterdigitation;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 28: 	//leafspan float
            {
                data_leafspan = src.get_leafspan();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_leafspan;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 29: 	//minleafendgap float
            {
                data_minleafendgap = src.get_minleafendgap();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_minleafendgap;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 30: 	//sdd float
            {
                data_sdd = src.get_sdd();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sdd;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 31: 	//sourcetobeamlimitingdevicedistance float
            {
                data_sourcetobeamlimitingdevicedistance = src.get_sourcetobeamlimitingdevicedistance();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sourcetobeamlimitingdevicedistance;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 32: 	//xindependent int
            {
                data_xindependent = src.get_xindependent();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_xindependent;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 33: 	//xmin_1 float
            {
                data_xmin_1 = src.get_xmin_1();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmin_1;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 34: 	//xmax_1 float
            {
                data_xmax_1 = src.get_xmax_1();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmax_1;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 35: 	//xmin_2 float
            {
                data_xmin_2 = src.get_xmin_2();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmin_2;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 36: 	//xmax_2 float
            {
                data_xmax_2 = src.get_xmax_2();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmax_2;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 37: 	//xmin_w float
            {
                data_xmin_w = src.get_xmin_w();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmin_w;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 38: 	//xmax_w float
            {
                data_xmax_w = src.get_xmax_w();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xmax_w;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 39: 	//xsdd float
            {
                data_xsdd = src.get_xsdd();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xsdd;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 40: 	//xname_1 varchar
            {
                data_xname_1 = src.get_xname_1();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_xname_1.c_str();
                bind[iCount].buffer_length = (unsigned long)data_xname_1.size();
            }
            break;
        case 41: 	//xname_2 varchar
            {
                data_xname_2 = src.get_xname_2();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_xname_2.c_str();
                bind[iCount].buffer_length = (unsigned long)data_xname_2.size();
            }
            break;
        case 42: 	//xisxjawlimit tinyint
            {
                data_xisxjawlimit = src.get_xisxjawlimit();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_xisxjawlimit;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 43: 	//yindependent int
            {
                data_yindependent = src.get_yindependent();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_yindependent;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 44: 	//ymin_1 float
            {
                data_ymin_1 = src.get_ymin_1();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymin_1;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 45: 	//ymax_1 float
            {
                data_ymax_1 = src.get_ymax_1();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymax_1;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 46: 	//ymin_2 float
            {
                data_ymin_2 = src.get_ymin_2();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymin_2;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 47: 	//ymax_2 float
            {
                data_ymax_2 = src.get_ymax_2();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymax_2;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 48: 	//ymin_w float
            {
                data_ymin_w = src.get_ymin_w();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymin_w;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 49: 	//ymax_w float
            {
                data_ymax_w = src.get_ymax_w();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ymax_w;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 50: 	//ysdd float
            {
                data_ysdd = src.get_ysdd();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ysdd;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 51: 	//yname_1 varchar
            {
                data_yname_1 = src.get_yname_1();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_yname_1.c_str();
                bind[iCount].buffer_length = (unsigned long)data_yname_1.size();
            }
            break;
        case 52: 	//yname_2 varchar
            {
                data_yname_2 = src.get_yname_2();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_yname_2.c_str();
                bind[iCount].buffer_length = (unsigned long)data_yname_2.size();
            }
            break;
        case 53: 	//yisxjawlimit tinyint
            {
                data_yisxjawlimit = src.get_yisxjawlimit();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_yisxjawlimit;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 54: 	//maximumgantryspeed_degreepersecond float
            {
                data_maximumgantryspeed_degreepersecond = src.get_maximumgantryspeed_degreepersecond();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_maximumgantryspeed_degreepersecond;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 55: 	//maximumleafspeed_mmpersecond float
            {
                data_maximumleafspeed_mmpersecond = src.get_maximumleafspeed_mmpersecond();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_maximumleafspeed_mmpersecond;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 56: 	//deviceid varchar
            {
                data_deviceid = src.get_deviceid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_deviceid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_deviceid.size();
            }
            break;
        case 57: 	//comments varchar
            {
                data_comments = src.get_comments();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_comments.c_str();
                bind[iCount].buffer_length = (unsigned long)data_comments.size();
            }
            break;
        case 58: 	//collimatoranglemin double
            {
                data_collimatoranglemin = src.get_collimatoranglemin();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_collimatoranglemin;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 59: 	//collimatoranglemax double
            {
                data_collimatoranglemax = src.get_collimatoranglemax();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_collimatoranglemax;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 60: 	//gantryclockwiserange double
            {
                data_gantryclockwiserange = src.get_gantryclockwiserange();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_gantryclockwiserange;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 61: 	//gantrycounterclockwiserange double
            {
                data_gantrycounterclockwiserange = src.get_gantrycounterclockwiserange();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_gantrycounterclockwiserange;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 62: 	//availableplantype varchar
            {
                data_availableplantype = src.get_availableplantype();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_availableplantype.c_str();
                bind[iCount].buffer_length = (unsigned long)data_availableplantype.size();
            }
            break;
        case 63: 	//maximumjawspeed_mmpersecond float
            {
                data_maximumjawspeed_mmpersecond = src.get_maximumjawspeed_mmpersecond();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_maximumjawspeed_mmpersecond;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 64: 	//minimumjawgap float
            {
                data_minimumjawgap = src.get_minimumjawgap();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_minimumjawgap;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 65: 	//dynamictrackingjawx tinyint
            {
                data_dynamictrackingjawx = src.get_dynamictrackingjawx();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_dynamictrackingjawx;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 66: 	//dynamictrackingjawy tinyint
            {
                data_dynamictrackingjawy = src.get_dynamictrackingjawy();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_dynamictrackingjawy;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 67: 	//sourcetomlctopdistance float
            {
                data_sourcetomlctopdistance = src.get_sourcetomlctopdistance();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sourcetomlctopdistance;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 68: 	//jawtrackinggap float
            {
                data_jawtrackinggap = src.get_jawtrackinggap();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_jawtrackinggap;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 69: 	//supportapetureblock tinyint
            {
                data_supportapetureblock = src.get_supportapetureblock();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_supportapetureblock;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 70: 	//supportshieldblock tinyint
            {
                data_supportshieldblock = src.get_supportshieldblock();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_supportshieldblock;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 71: 	//sourcetoblocktraydistance float
            {
                data_sourcetoblocktraydistance = src.get_sourcetoblocktraydistance();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sourcetoblocktraydistance;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 72: 	//blockheight float
            {
                data_blockheight = src.get_blockheight();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_blockheight;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 73: 	//maxpatientperhour int
            {
                data_maxpatientperhour = src.get_maxpatientperhour();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_maxpatientperhour;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 74: 	//blockthickness float
            {
                data_blockthickness = src.get_blockthickness();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_blockthickness;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 75: 	//sourcetowedgetopdistance float
            {
                data_sourcetowedgetopdistance = src.get_sourcetowedgetopdistance();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sourcetowedgetopdistance;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 76: 	//sourcetoapplicatordistance float
            {
                data_sourcetoapplicatordistance = src.get_sourcetoapplicatordistance();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_sourcetoapplicatordistance;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 77: 	//crc varchar
            {
                data_crc = src.get_crc();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_crc.c_str();
                bind[iCount].buffer_length = (unsigned long)data_crc.size();
            }
            break;
        case 78: 	//state int
            {
                data_state = src.get_state();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_state;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 79: 	//forcejawfollow tinyint
            {
                data_forcejawfollow = src.get_forcejawfollow();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_forcejawfollow;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 80: 	//inactivereason varchar
            {
                data_inactivereason = src.get_inactivereason();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_inactivereason.c_str();
                bind[iCount].buffer_length = (unsigned long)data_inactivereason.size();
            }
            break;
        case 81: 	//inactivetime datetime
            {
                ConvertDateTime2DB(src.get_inactivetime(), &data_inactivetime);
                bind[iCount].buffer_type = MYSQL_TYPE_DATETIME;
                bind[iCount].buffer = (void*)&data_inactivetime;
                if (src.get_inactivetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 82: 	//inactiveuser varchar
            {
                data_inactiveuser = src.get_inactiveuser();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_inactiveuser.c_str();
                bind[iCount].buffer_length = (unsigned long)data_inactiveuser.size();
            }
            break;
        case 83: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 84: 	//mingantryspeed_degreepersecond float
            {
                data_mingantryspeed_degreepersecond = src.get_mingantryspeed_degreepersecond();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_mingantryspeed_degreepersecond;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 85: 	//maxleafacc_mmpersec2 float
            {
                data_maxleafacc_mmpersec2 = src.get_maxleafacc_mmpersec2();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_maxleafacc_mmpersec2;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
	DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtMachine*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtMachine*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsmachine    86 parameters
    const int field_num = MACHINE_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 1024;
    MAX_LENGTH[2] = 1024;
    MAX_LENGTH[3] = 1024;
    MAX_LENGTH[4] = 0;
    MAX_LENGTH[5] = 0;
    MAX_LENGTH[6] = 0;
    MAX_LENGTH[7] = 0;
    MAX_LENGTH[8] = 0;
    MAX_LENGTH[9] = 0;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 0;
    MAX_LENGTH[12] = 0;
    MAX_LENGTH[13] = 0;
    MAX_LENGTH[14] = 0;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 0;
    MAX_LENGTH[17] = 0;
    MAX_LENGTH[18] = 0;
    MAX_LENGTH[19] = 0;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 5400;
    MAX_LENGTH[23] = 0;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;
    MAX_LENGTH[26] = 0;
    MAX_LENGTH[27] = 0;
    MAX_LENGTH[28] = 0;
    MAX_LENGTH[29] = 0;
    MAX_LENGTH[30] = 0;
    MAX_LENGTH[31] = 0;
    MAX_LENGTH[32] = 0;
    MAX_LENGTH[33] = 0;
    MAX_LENGTH[34] = 0;
    MAX_LENGTH[35] = 0;
    MAX_LENGTH[36] = 0;
    MAX_LENGTH[37] = 0;
    MAX_LENGTH[38] = 0;
    MAX_LENGTH[39] = 0;
    MAX_LENGTH[40] = 1024;
    MAX_LENGTH[41] = 1024;
    MAX_LENGTH[42] = 0;
    MAX_LENGTH[43] = 0;
    MAX_LENGTH[44] = 0;
    MAX_LENGTH[45] = 0;
    MAX_LENGTH[46] = 0;
    MAX_LENGTH[47] = 0;
    MAX_LENGTH[48] = 0;
    MAX_LENGTH[49] = 0;
    MAX_LENGTH[50] = 0;
    MAX_LENGTH[51] = 1024;
    MAX_LENGTH[52] = 1024;
    MAX_LENGTH[53] = 0;
    MAX_LENGTH[54] = 0;
    MAX_LENGTH[55] = 0;
    MAX_LENGTH[56] = 64;
    MAX_LENGTH[57] = 1024;
    MAX_LENGTH[58] = 0;
    MAX_LENGTH[59] = 0;
    MAX_LENGTH[60] = 0;
    MAX_LENGTH[61] = 0;
    MAX_LENGTH[62] = 1024;
    MAX_LENGTH[63] = 0;
    MAX_LENGTH[64] = 0;
    MAX_LENGTH[65] = 0;
    MAX_LENGTH[66] = 0;
    MAX_LENGTH[67] = 0;
    MAX_LENGTH[68] = 0;
    MAX_LENGTH[69] = 0;
    MAX_LENGTH[70] = 0;
    MAX_LENGTH[71] = 0;
    MAX_LENGTH[72] = 0;
    MAX_LENGTH[73] = 0;
    MAX_LENGTH[74] = 0;
    MAX_LENGTH[75] = 0;
    MAX_LENGTH[76] = 0;
    MAX_LENGTH[77] = 64;
    MAX_LENGTH[78] = 0;
    MAX_LENGTH[79] = 0;
    MAX_LENGTH[80] = 512;
    MAX_LENGTH[81] = 0;
    MAX_LENGTH[82] = 64;
    MAX_LENGTH[83] = 0;
    MAX_LENGTH[84] = 0;
    MAX_LENGTH[85] = 0;

    //std::string	data_uid
    //std::string	data_name
    //std::string	data_type
    //std::string	data_manufacturer
    double	data_gantrymax = 0.;
    double	data_gantrymin = 0.;
    double	data_sad = 0.;
    double	data_tablelateralmax = 0.;
    double	data_tablelateralmin = 0.;
    double	data_tablelongitudinalmax = 0.;
    double	data_tablelongitudinalmin = 0.;
    double	data_tableverticalmax = 0.;
    double	data_tableverticalmin = 0.;
    double	data_tableanglemax = 0.;
    double	data_tableanglemin = 0.;
    int	data_collimatordirection = 0;
    int	data_mlcdirectiontype = 0;
    bool	data_jawxissymmetry = false;
    bool	data_jawyissymmetry = false;
    int	data_xjawnum = 0;
    int	data_yjawnum = 0;
    int	data_leafnum = 0;
    //std::vector<double>	data_leafboundaries
    double	data_negativeleafrangemin = 0.;
    double	data_negativeleafrangemax = 0.;
    double	data_positiveleafrangemin = 0.;
    double	data_positiveleafrangemax = 0.;
    bool	data_isinterdigitation = false;
    float	data_leafspan = 0.f;
    float	data_minleafendgap = 0.f;
    float	data_sdd = 0.f;
    float	data_sourcetobeamlimitingdevicedistance = 0.f;
    int	data_xindependent = 0;
    float	data_xmin_1 = 0.f;
    float	data_xmax_1 = 0.f;
    float	data_xmin_2 = 0.f;
    float	data_xmax_2 = 0.f;
    float	data_xmin_w = 0.f;
    float	data_xmax_w = 0.f;
    float	data_xsdd = 0.f;
    //std::string	data_xname_1
    //std::string	data_xname_2
    bool	data_xisxjawlimit = false;
    int	data_yindependent = 0;
    float	data_ymin_1 = 0.f;
    float	data_ymax_1 = 0.f;
    float	data_ymin_2 = 0.f;
    float	data_ymax_2 = 0.f;
    float	data_ymin_w = 0.f;
    float	data_ymax_w = 0.f;
    float	data_ysdd = 0.f;
    //std::string	data_yname_1
    //std::string	data_yname_2
    bool	data_yisxjawlimit = false;
    float	data_maximumgantryspeed_degreepersecond = 0.f;
    float	data_maximumleafspeed_mmpersecond = 0.f;
    //std::string	data_deviceid
    //std::string	data_comments
    double	data_collimatoranglemin = 0.;
    double	data_collimatoranglemax = 0.;
    double	data_gantryclockwiserange = 0.;
    double	data_gantrycounterclockwiserange = 0.;
    //std::string	data_availableplantype
    float	data_maximumjawspeed_mmpersecond = 0.f;
    float	data_minimumjawgap = 0.f;
    bool	data_dynamictrackingjawx = false;
    bool	data_dynamictrackingjawy = false;
    float	data_sourcetomlctopdistance = 0.f;
    float	data_jawtrackinggap = 0.f;
    bool	data_supportapetureblock = false;
    bool	data_supportshieldblock = false;
    float	data_sourcetoblocktraydistance = 0.f;
    float	data_blockheight = 0.f;
    int	data_maxpatientperhour = 0;
    float	data_blockthickness = 0.f;
    float	data_sourcetowedgetopdistance = 0.f;
    float	data_sourcetoapplicatordistance = 0.f;
    //std::string	data_crc
    int	data_state = 0;
    bool	data_forcejawfollow = false;
    //std::string	data_inactivereason
    MYSQL_TIME	data_inactivetime;
    //std::string	data_inactiveuser
    MYSQL_TIME	data_updatetime;
    float	data_mingantryspeed_degreepersecond = 0.f;
    float	data_maxleafacc_mmpersec2 = 0.f;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 4: 	//gantrymax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_gantrymax;
            break;
        case 5: 	//gantrymin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_gantrymin;
            break;
        case 6: 	//sad double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_sad;
            break;
        case 7: 	//tablelateralmax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tablelateralmax;
            break;
        case 8: 	//tablelateralmin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tablelateralmin;
            break;
        case 9: 	//tablelongitudinalmax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tablelongitudinalmax;
            break;
        case 10: 	//tablelongitudinalmin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tablelongitudinalmin;
            break;
        case 11: 	//tableverticalmax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tableverticalmax;
            break;
        case 12: 	//tableverticalmin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tableverticalmin;
            break;
        case 13: 	//tableanglemax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tableanglemax;
            break;
        case 14: 	//tableanglemin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_tableanglemin;
            break;
        case 15: 	//collimatordirection int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_collimatordirection;
            break;
        case 16: 	//mlcdirectiontype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_mlcdirectiontype;
            break;
        case 17: 	//jawxissymmetry tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_jawxissymmetry;
            break;
        case 18: 	//jawyissymmetry tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_jawyissymmetry;
            break;
        case 19: 	//xjawnum int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_xjawnum;
            break;
        case 20: 	//yjawnum int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_yjawnum;
            break;
        case 21: 	//leafnum int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_leafnum;
            break;
        case 23: 	//negativeleafrangemin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_negativeleafrangemin;
            break;
        case 24: 	//negativeleafrangemax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_negativeleafrangemax;
            break;
        case 25: 	//positiveleafrangemin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_positiveleafrangemin;
            break;
        case 26: 	//positiveleafrangemax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_positiveleafrangemax;
            break;
        case 27: 	//isinterdigitation tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isinterdigitation;
            break;
        case 28: 	//leafspan float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_leafspan;
            break;
        case 29: 	//minleafendgap float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_minleafendgap;
            break;
        case 30: 	//sdd float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sdd;
            break;
        case 31: 	//sourcetobeamlimitingdevicedistance float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sourcetobeamlimitingdevicedistance;
            break;
        case 32: 	//xindependent int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_xindependent;
            break;
        case 33: 	//xmin_1 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmin_1;
            break;
        case 34: 	//xmax_1 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmax_1;
            break;
        case 35: 	//xmin_2 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmin_2;
            break;
        case 36: 	//xmax_2 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmax_2;
            break;
        case 37: 	//xmin_w float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmin_w;
            break;
        case 38: 	//xmax_w float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xmax_w;
            break;
        case 39: 	//xsdd float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xsdd;
            break;
        case 42: 	//xisxjawlimit tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_xisxjawlimit;
            break;
        case 43: 	//yindependent int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_yindependent;
            break;
        case 44: 	//ymin_1 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymin_1;
            break;
        case 45: 	//ymax_1 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymax_1;
            break;
        case 46: 	//ymin_2 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymin_2;
            break;
        case 47: 	//ymax_2 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymax_2;
            break;
        case 48: 	//ymin_w float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymin_w;
            break;
        case 49: 	//ymax_w float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ymax_w;
            break;
        case 50: 	//ysdd float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ysdd;
            break;
        case 53: 	//yisxjawlimit tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_yisxjawlimit;
            break;
        case 54: 	//maximumgantryspeed_degreepersecond float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maximumgantryspeed_degreepersecond;
            break;
        case 55: 	//maximumleafspeed_mmpersecond float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maximumleafspeed_mmpersecond;
            break;
        case 58: 	//collimatoranglemin double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_collimatoranglemin;
            break;
        case 59: 	//collimatoranglemax double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_collimatoranglemax;
            break;
        case 60: 	//gantryclockwiserange double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_gantryclockwiserange;
            break;
        case 61: 	//gantrycounterclockwiserange double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_gantrycounterclockwiserange;
            break;
        case 63: 	//maximumjawspeed_mmpersecond float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maximumjawspeed_mmpersecond;
            break;
        case 64: 	//minimumjawgap float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_minimumjawgap;
            break;
        case 65: 	//dynamictrackingjawx tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_dynamictrackingjawx;
            break;
        case 66: 	//dynamictrackingjawy tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_dynamictrackingjawy;
            break;
        case 67: 	//sourcetomlctopdistance float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sourcetomlctopdistance;
            break;
        case 68: 	//jawtrackinggap float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_jawtrackinggap;
            break;
        case 69: 	//supportapetureblock tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_supportapetureblock;
            break;
        case 70: 	//supportshieldblock tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_supportshieldblock;
            break;
        case 71: 	//sourcetoblocktraydistance float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sourcetoblocktraydistance;
            break;
        case 72: 	//blockheight float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_blockheight;
            break;
        case 73: 	//maxpatientperhour int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_maxpatientperhour;
            break;
        case 74: 	//blockthickness float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_blockthickness;
            break;
        case 75: 	//sourcetowedgetopdistance float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sourcetowedgetopdistance;
            break;
        case 76: 	//sourcetoapplicatordistance float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_sourcetoapplicatordistance;
            break;
        case 78: 	//state int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_state;
            break;
        case 79: 	//forcejawfollow tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_forcejawfollow;
            break;
        case 81: 	//inactivetime datetime
            bind[i].buffer_type= MYSQL_TYPE_DATETIME;
            bind[i].buffer= (char *)&data_inactivetime;
            break;
        case 83: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        case 84: 	//mingantryspeed_degreepersecond float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_mingantryspeed_degreepersecond;
            break;
        case 85: 	//maxleafacc_mmpersec2 float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maxleafacc_mmpersec2;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtMachine* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtMachine();
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//name varchar
                pDis->set_name((char *)bind[i].buffer);
                break;
            case 2: 	//type varchar
                pDis->set_type((char *)bind[i].buffer);
                break;
            case 3: 	//manufacturer varchar
                pDis->set_manufacturer((char *)bind[i].buffer);
                break;
            case 4: 	//gantrymax double
                pDis->set_gantrymax(data_gantrymax);
                break;
            case 5: 	//gantrymin double
                pDis->set_gantrymin(data_gantrymin);
                break;
            case 6: 	//sad double
                pDis->set_sad(data_sad);
                break;
            case 7: 	//tablelateralmax double
                pDis->set_tablelateralmax(data_tablelateralmax);
                break;
            case 8: 	//tablelateralmin double
                pDis->set_tablelateralmin(data_tablelateralmin);
                break;
            case 9: 	//tablelongitudinalmax double
                pDis->set_tablelongitudinalmax(data_tablelongitudinalmax);
                break;
            case 10: 	//tablelongitudinalmin double
                pDis->set_tablelongitudinalmin(data_tablelongitudinalmin);
                break;
            case 11: 	//tableverticalmax double
                pDis->set_tableverticalmax(data_tableverticalmax);
                break;
            case 12: 	//tableverticalmin double
                pDis->set_tableverticalmin(data_tableverticalmin);
                break;
            case 13: 	//tableanglemax double
                pDis->set_tableanglemax(data_tableanglemax);
                break;
            case 14: 	//tableanglemin double
                pDis->set_tableanglemin(data_tableanglemin);
                break;
            case 15: 	//collimatordirection int
                pDis->set_collimatordirection(data_collimatordirection);
                break;
            case 16: 	//mlcdirectiontype int
                pDis->set_mlcdirectiontype(data_mlcdirectiontype);
                break;
            case 17: 	//jawxissymmetry tinyint
                pDis->set_jawxissymmetry(data_jawxissymmetry);
                break;
            case 18: 	//jawyissymmetry tinyint
                pDis->set_jawyissymmetry(data_jawyissymmetry);
                break;
            case 19: 	//xjawnum int
                pDis->set_xjawnum(data_xjawnum);
                break;
            case 20: 	//yjawnum int
                pDis->set_yjawnum(data_yjawnum);
                break;
            case 21: 	//leafnum int
                pDis->set_leafnum(data_leafnum);
                break;
            case 22: 	//leafboundaries varchar
                {
                    const int total_length = length[i];
                    std::vector<double> data_leafboundaries;
                    if (total_length < 1) break;
                    char *buf=new char[total_length + 1];
                    memset(buf,0,sizeof(char) * total_length + 1);
                    bind[i].buffer = buf;
                    bind[i].buffer_length = total_length;
                    ret = mysql_stmt_fetch_column(stmt, &bind[i], i, 0);
                    if (0 == ret){
                        std::vector<std::string> subValue;
                        (void)boost::split(subValue, buf, boost::is_any_of("\\\\"));
                        const size_t fSize = subValue.size();
                        for (size_t x=0; x<fSize; ++x){
                            double fValue = (double)atof(subValue[x].c_str());
                            data_leafboundaries.push_back(fValue);
                        }
                        pDis->set_leafboundaries_list(data_leafboundaries);
                        pDis->set_leafboundaries((char *)bind[i].buffer);
                    }
                    DEL_PTR(buf);
                }
                break;
            case 23: 	//negativeleafrangemin double
                pDis->set_negativeleafrangemin(data_negativeleafrangemin);
                break;
            case 24: 	//negativeleafrangemax double
                pDis->set_negativeleafrangemax(data_negativeleafrangemax);
                break;
            case 25: 	//positiveleafrangemin double
                pDis->set_positiveleafrangemin(data_positiveleafrangemin);
                break;
            case 26: 	//positiveleafrangemax double
                pDis->set_positiveleafrangemax(data_positiveleafrangemax);
                break;
            case 27: 	//isinterdigitation tinyint
                pDis->set_isinterdigitation(data_isinterdigitation);
                break;
            case 28: 	//leafspan float
                pDis->set_leafspan(data_leafspan);
                break;
            case 29: 	//minleafendgap float
                pDis->set_minleafendgap(data_minleafendgap);
                break;
            case 30: 	//sdd float
                pDis->set_sdd(data_sdd);
                break;
            case 31: 	//sourcetobeamlimitingdevicedistance float
                pDis->set_sourcetobeamlimitingdevicedistance(data_sourcetobeamlimitingdevicedistance);
                break;
            case 32: 	//xindependent int
                pDis->set_xindependent(data_xindependent);
                break;
            case 33: 	//xmin_1 float
                pDis->set_xmin_1(data_xmin_1);
                break;
            case 34: 	//xmax_1 float
                pDis->set_xmax_1(data_xmax_1);
                break;
            case 35: 	//xmin_2 float
                pDis->set_xmin_2(data_xmin_2);
                break;
            case 36: 	//xmax_2 float
                pDis->set_xmax_2(data_xmax_2);
                break;
            case 37: 	//xmin_w float
                pDis->set_xmin_w(data_xmin_w);
                break;
            case 38: 	//xmax_w float
                pDis->set_xmax_w(data_xmax_w);
                break;
            case 39: 	//xsdd float
                pDis->set_xsdd(data_xsdd);
                break;
            case 40: 	//xname_1 varchar
                pDis->set_xname_1((char *)bind[i].buffer);
                break;
            case 41: 	//xname_2 varchar
                pDis->set_xname_2((char *)bind[i].buffer);
                break;
            case 42: 	//xisxjawlimit tinyint
                pDis->set_xisxjawlimit(data_xisxjawlimit);
                break;
            case 43: 	//yindependent int
                pDis->set_yindependent(data_yindependent);
                break;
            case 44: 	//ymin_1 float
                pDis->set_ymin_1(data_ymin_1);
                break;
            case 45: 	//ymax_1 float
                pDis->set_ymax_1(data_ymax_1);
                break;
            case 46: 	//ymin_2 float
                pDis->set_ymin_2(data_ymin_2);
                break;
            case 47: 	//ymax_2 float
                pDis->set_ymax_2(data_ymax_2);
                break;
            case 48: 	//ymin_w float
                pDis->set_ymin_w(data_ymin_w);
                break;
            case 49: 	//ymax_w float
                pDis->set_ymax_w(data_ymax_w);
                break;
            case 50: 	//ysdd float
                pDis->set_ysdd(data_ysdd);
                break;
            case 51: 	//yname_1 varchar
                pDis->set_yname_1((char *)bind[i].buffer);
                break;
            case 52: 	//yname_2 varchar
                pDis->set_yname_2((char *)bind[i].buffer);
                break;
            case 53: 	//yisxjawlimit tinyint
                pDis->set_yisxjawlimit(data_yisxjawlimit);
                break;
            case 54: 	//maximumgantryspeed_degreepersecond float
                pDis->set_maximumgantryspeed_degreepersecond(data_maximumgantryspeed_degreepersecond);
                break;
            case 55: 	//maximumleafspeed_mmpersecond float
                pDis->set_maximumleafspeed_mmpersecond(data_maximumleafspeed_mmpersecond);
                break;
            case 56: 	//deviceid varchar
                pDis->set_deviceid((char *)bind[i].buffer);
                break;
            case 57: 	//comments varchar
                pDis->set_comments((char *)bind[i].buffer);
                break;
            case 58: 	//collimatoranglemin double
                pDis->set_collimatoranglemin(data_collimatoranglemin);
                break;
            case 59: 	//collimatoranglemax double
                pDis->set_collimatoranglemax(data_collimatoranglemax);
                break;
            case 60: 	//gantryclockwiserange double
                pDis->set_gantryclockwiserange(data_gantryclockwiserange);
                break;
            case 61: 	//gantrycounterclockwiserange double
                pDis->set_gantrycounterclockwiserange(data_gantrycounterclockwiserange);
                break;
            case 62: 	//availableplantype varchar
                pDis->set_availableplantype((char *)bind[i].buffer);
                break;
            case 63: 	//maximumjawspeed_mmpersecond float
                pDis->set_maximumjawspeed_mmpersecond(data_maximumjawspeed_mmpersecond);
                break;
            case 64: 	//minimumjawgap float
                pDis->set_minimumjawgap(data_minimumjawgap);
                break;
            case 65: 	//dynamictrackingjawx tinyint
                pDis->set_dynamictrackingjawx(data_dynamictrackingjawx);
                break;
            case 66: 	//dynamictrackingjawy tinyint
                pDis->set_dynamictrackingjawy(data_dynamictrackingjawy);
                break;
            case 67: 	//sourcetomlctopdistance float
                pDis->set_sourcetomlctopdistance(data_sourcetomlctopdistance);
                break;
            case 68: 	//jawtrackinggap float
                pDis->set_jawtrackinggap(data_jawtrackinggap);
                break;
            case 69: 	//supportapetureblock tinyint
                pDis->set_supportapetureblock(data_supportapetureblock);
                break;
            case 70: 	//supportshieldblock tinyint
                pDis->set_supportshieldblock(data_supportshieldblock);
                break;
            case 71: 	//sourcetoblocktraydistance float
                pDis->set_sourcetoblocktraydistance(data_sourcetoblocktraydistance);
                break;
            case 72: 	//blockheight float
                pDis->set_blockheight(data_blockheight);
                break;
            case 73: 	//maxpatientperhour int
                pDis->set_maxpatientperhour(data_maxpatientperhour);
                break;
            case 74: 	//blockthickness float
                pDis->set_blockthickness(data_blockthickness);
                break;
            case 75: 	//sourcetowedgetopdistance float
                pDis->set_sourcetowedgetopdistance(data_sourcetowedgetopdistance);
                break;
            case 76: 	//sourcetoapplicatordistance float
                pDis->set_sourcetoapplicatordistance(data_sourcetoapplicatordistance);
                break;
            case 77: 	//crc varchar
                pDis->set_crc((char *)bind[i].buffer);
                break;
            case 78: 	//state int
                pDis->set_state(data_state);
                break;
            case 79: 	//forcejawfollow tinyint
                pDis->set_forcejawfollow(data_forcejawfollow);
                break;
            case 80: 	//inactivereason varchar
                pDis->set_inactivereason((char *)bind[i].buffer);
                break;
            case 81: 	//inactivetime datetime
                {
                    DATETIME_BOOST inactivetime;
                    ConvertDateTime2Boost(data_inactivetime, &inactivetime);
                    pDis->set_inactivetime(inactivetime);
                }
                break;
            case 82: 	//inactiveuser varchar
                pDis->set_inactiveuser((char *)bind[i].buffer);
                break;
            case 83: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            case 84: 	//mingantryspeed_degreepersecond float
                pDis->set_mingantryspeed_degreepersecond(data_mingantryspeed_degreepersecond);
                break;
            case 85: 	//maxleafacc_mmpersec2 float
                pDis->set_maxleafacc_mmpersec2(data_maxleafacc_mmpersec2);
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

void RtDatabaseHelper::CalcHash(const RtMachine& src, std::string* pHash)
{
    if(nullptr == pHash) return;

    std::string columndata("");
    std::string itemdata("");
    std::string columnname("");
    std::string columnvalue("");

    for (unsigned int i(0); i < MACHINE_FIELD_MAX; ++i)
    {
        columnvalue = ""; //每次读取字段前，需要重新赋空，否则保留上个字段的值，可能出错
        //columnname = std::string(ENUM2STRING_MACHINE_FIELD[i]);
        switch (i)
        {
        case 0: 	//uid varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_uid();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 1: 	//name varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_name();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 2: 	//type varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_type();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 3: 	//manufacturer varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_manufacturer();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 4: 	//gantrymax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_gantrymax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 5: 	//gantrymin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_gantrymin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 6: 	//sad double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sad());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 7: 	//tablelateralmax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tablelateralmax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 8: 	//tablelateralmin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tablelateralmin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 9: 	//tablelongitudinalmax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tablelongitudinalmax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 10: 	//tablelongitudinalmin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tablelongitudinalmin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 11: 	//tableverticalmax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tableverticalmax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 12: 	//tableverticalmin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tableverticalmin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 13: 	//tableanglemax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tableanglemax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 14: 	//tableanglemin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_tableanglemin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 15: 	//collimatordirection int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_collimatordirection());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 16: 	//mlcdirectiontype int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_mlcdirectiontype());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 17: 	//jawxissymmetry tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_jawxissymmetry());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 18: 	//jawyissymmetry tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_jawyissymmetry());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 19: 	//xjawnum int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_xjawnum());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 20: 	//yjawnum int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_yjawnum());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 21: 	//leafnum int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_leafnum());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 22: 	//leafboundaries varchar
            {
                if(!src.has_field(i))
                {
                     columnvalue = "";
                }
                else
                {
                    std::vector<double> leafboundaries = src.get_leafboundaries_list();
                    const size_t leafSize = leafboundaries.size();
                    if (leafSize > 0)
                    {
                        columnvalue = ToString((long double)(leafboundaries[0]));
                        for (int y(1); y<leafSize; ++y)
                        {
                            columnvalue += ToString((long double)(leafboundaries[y]));
                        }
                    }
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 23: 	//negativeleafrangemin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_negativeleafrangemin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 24: 	//negativeleafrangemax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_negativeleafrangemax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 25: 	//positiveleafrangemin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_positiveleafrangemin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 26: 	//positiveleafrangemax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_positiveleafrangemax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 27: 	//isinterdigitation tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_isinterdigitation());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 28: 	//leafspan float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_leafspan());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 29: 	//minleafendgap float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_minleafendgap());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 30: 	//sdd float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sdd());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 31: 	//sourcetobeamlimitingdevicedistance float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sourcetobeamlimitingdevicedistance());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 32: 	//xindependent int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_xindependent());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 33: 	//xmin_1 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmin_1());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 34: 	//xmax_1 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmax_1());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 35: 	//xmin_2 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmin_2());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 36: 	//xmax_2 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmax_2());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 37: 	//xmin_w float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmin_w());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 38: 	//xmax_w float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xmax_w());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 39: 	//xsdd float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_xsdd());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 40: 	//xname_1 varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_xname_1();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 41: 	//xname_2 varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_xname_2();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 42: 	//xisxjawlimit tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_xisxjawlimit());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 43: 	//yindependent int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_yindependent());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 44: 	//ymin_1 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymin_1());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 45: 	//ymax_1 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymax_1());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 46: 	//ymin_2 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymin_2());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 47: 	//ymax_2 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymax_2());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 48: 	//ymin_w float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymin_w());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 49: 	//ymax_w float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ymax_w());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 50: 	//ysdd float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_ysdd());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 51: 	//yname_1 varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_yname_1();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 52: 	//yname_2 varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_yname_2();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 53: 	//yisxjawlimit tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_yisxjawlimit());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 54: 	//maximumgantryspeed_degreepersecond float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_maximumgantryspeed_degreepersecond());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 55: 	//maximumleafspeed_mmpersecond float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_maximumleafspeed_mmpersecond());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 56: 	//deviceid varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_deviceid();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 57: 	//comments varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_comments();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 58: 	//collimatoranglemin double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_collimatoranglemin());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 59: 	//collimatoranglemax double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_collimatoranglemax());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 60: 	//gantryclockwiserange double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_gantryclockwiserange());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 61: 	//gantrycounterclockwiserange double
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_gantrycounterclockwiserange());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 62: 	//availableplantype varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_availableplantype();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 63: 	//maximumjawspeed_mmpersecond float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_maximumjawspeed_mmpersecond());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 64: 	//minimumjawgap float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_minimumjawgap());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 65: 	//dynamictrackingjawx tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_dynamictrackingjawx());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 66: 	//dynamictrackingjawy tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_dynamictrackingjawy());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 67: 	//sourcetomlctopdistance float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sourcetomlctopdistance());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 68: 	//jawtrackinggap float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_jawtrackinggap());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 69: 	//supportapetureblock tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_supportapetureblock());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 70: 	//supportshieldblock tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_supportshieldblock());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 71: 	//sourcetoblocktraydistance float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sourcetoblocktraydistance());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 72: 	//blockheight float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_blockheight());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 73: 	//maxpatientperhour int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_maxpatientperhour());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 74: 	//blockthickness float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_blockthickness());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 75: 	//sourcetowedgetopdistance float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sourcetowedgetopdistance());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 76: 	//sourcetoapplicatordistance float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_sourcetoapplicatordistance());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 77: 	//crc varchar
            {
            }
            break;
        case 78: 	//state int
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_state());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 79: 	//forcejawfollow tinyint
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = std::to_string((long long)src.get_forcejawfollow());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 80: 	//inactivereason varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_inactivereason();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 81: 	//inactivetime datetime
            {
            }
            break;
        case 82: 	//inactiveuser varchar
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = src.get_inactiveuser();
                    RemoveSlash(columnvalue);
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 83: 	//updatetime timestamp
            {
            }
            break;
        case 84: 	//mingantryspeed_degreepersecond float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_mingantryspeed_degreepersecond());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
        case 85: 	//maxleafacc_mmpersec2 float
            {
                if(!src.has_field(i))
                {
                    columnvalue = "";
                }
                else
                {
                    columnvalue = ToString(src.get_maxleafacc_mmpersec2());
                }
                columndata = columnvalue + "|";
                itemdata += columndata;
            }
            break;
            default:
                break;
        }
       }
    md5_helper_t hhelper;
    //printf("\n%s\n",itemdata.c_str());
    std::string hash = hhelper.hexdigesttext(itemdata);
    errorinfo_t lasterror = hhelper.lasterror();
    if(0 == lasterror.errorCode ) 
    {
        *pHash = hash;
    }
    else
    {
        *pHash = "";
    }
    //printf("\n%s\n",hash.c_str());
}

RT_TPS_DATABASE_END_NAMESPACE