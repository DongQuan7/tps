//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_beam.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.12
///
///  \version 1.0
///  \date    8/15/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_beam.h"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtBeam& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //48 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < BEAM_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_BEAM_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmsbeam SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < BEAM_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_BEAM_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmsbeam (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_commissionedunituid = "";
    std::string	data_normgroupuid = "";
    std::string	data_isocenterpoiuid = "";
    std::string	data_toleranceuid = "";
    std::string	data_applicatoruid = "";
    std::string	data_bolusvoiuid = "";
    std::string	data_trayuid = "";
    std::string	data_description = "";
    std::string	data_name = "";
    int			data_beamtype = 0;
    int			data_beamdeliverytype = 0;
    int			data_beamnumber = 0;
    double		data_beammu = 0.;
    std::string	data_beammode = "";
    float		data_red = 0.f;
    float		data_green = 0.f;
    float		data_blue = 0.f;
    float		data_alpha = 0.f;
    float		data_beamweight = 0.f;
    float		data_finalcumulativemetersetweight = 0.f;
    bool		data_isvisible = false;
    int			data_protocal = 0;
    float		data_normpointbeamdose = 0.f;
    float		data_bolusthickness = 0.f;
    bool		data_isjoincalc = false;
    bool		data_isjoinopt = false;
    int			data_tpsverno = 0;
    int			data_tmsverno = 0;
    int			data_aperturetype = 0;
    float		data_doserate = 0.f;
    std::string	data_relatedrtimageuid = "";
    std::string	data_physicalwedgeuid = "";
    bool		data_isautocreated = false;
    std::string	data_virtualwedgeuid = "";
    int			data_mlcedittype = 0;
    std::string	data_targetvoiuid = "";
    float		data_targetmarginx = 0.f;
    float		data_targetmarginy = 0.f;
    std::string	data_avoidvoiuid = "";
    float		data_avoidmarginx = 0.f;
    float		data_avoidmarginy = 0.f;
    bool		data_isautoshape = false;
    int			data_jawtype = 0;
    float		data_jawmarginx = 0.f;
    float		data_jawmarginy = 0.f;
    int			data_dosealgorithmtype = 0;
    MYSQL_TIME	data_updatetime;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < BEAM_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//commissionedunituid varchar
            {
                data_commissionedunituid = src.get_commissionedunituid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_commissionedunituid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_commissionedunituid.size();
            }
            break;
        case 2: 	//normgroupuid varchar
            {
                data_normgroupuid = src.get_normgroupuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_normgroupuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_normgroupuid.size();
            }
            break;
        case 3: 	//isocenterpoiuid varchar
            {
                data_isocenterpoiuid = src.get_isocenterpoiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_isocenterpoiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_isocenterpoiuid.size();
            }
            break;
        case 4: 	//toleranceuid varchar
            {
                data_toleranceuid = src.get_toleranceuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_toleranceuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_toleranceuid.size();
            }
            break;
        case 5: 	//applicatoruid varchar
            {
                data_applicatoruid = src.get_applicatoruid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_applicatoruid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_applicatoruid.size();
            }
            break;
        case 6: 	//bolusvoiuid varchar
            {
                data_bolusvoiuid = src.get_bolusvoiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_bolusvoiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_bolusvoiuid.size();
            }
            break;
        case 7: 	//trayuid varchar
            {
                data_trayuid = src.get_trayuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_trayuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_trayuid.size();
            }
            break;
        case 8: 	//description varchar
            {
                data_description = src.get_description();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_description.c_str();
                bind[iCount].buffer_length = (unsigned long)data_description.size();
            }
            break;
        case 9: 	//name varchar
            {
                data_name = src.get_name();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_name.c_str();
                bind[iCount].buffer_length = (unsigned long)data_name.size();
            }
            break;
        case 10: 	//beamtype int
            {
                data_beamtype = src.get_beamtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_beamtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 11: 	//beamdeliverytype int
            {
                data_beamdeliverytype = src.get_beamdeliverytype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_beamdeliverytype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 12: 	//beamnumber int
            {
                data_beamnumber = src.get_beamnumber();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_beamnumber;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 13: 	//beammu double
            {
                data_beammu = src.get_beammu();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_beammu;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 14: 	//beammode varchar
            {
                data_beammode = src.get_beammode();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_beammode.c_str();
                bind[iCount].buffer_length = (unsigned long)data_beammode.size();
            }
            break;
        case 15: 	//red float
            {
                data_red = src.get_red();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_red;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 16: 	//green float
            {
                data_green = src.get_green();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_green;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 17: 	//blue float
            {
                data_blue = src.get_blue();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_blue;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 18: 	//alpha float
            {
                data_alpha = src.get_alpha();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_alpha;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 19: 	//beamweight float
            {
                data_beamweight = src.get_beamweight();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_beamweight;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 20: 	//finalcumulativemetersetweight float
            {
                data_finalcumulativemetersetweight = src.get_finalcumulativemetersetweight();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_finalcumulativemetersetweight;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 21: 	//isvisible tinyint
            {
                data_isvisible = src.get_isvisible();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isvisible;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 22: 	//protocal int
            {
                data_protocal = src.get_protocal();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_protocal;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 23: 	//normpointbeamdose float
            {
                data_normpointbeamdose = src.get_normpointbeamdose();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_normpointbeamdose;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 24: 	//bolusthickness float
            {
                data_bolusthickness = src.get_bolusthickness();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_bolusthickness;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 25: 	//isjoincalc tinyint
            {
                data_isjoincalc = src.get_isjoincalc();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isjoincalc;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 26: 	//isjoinopt tinyint
            {
                data_isjoinopt = src.get_isjoinopt();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isjoinopt;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 27: 	//tpsverno int
            {
                data_tpsverno = src.get_tpsverno();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_tpsverno;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 28: 	//tmsverno int
            {
                data_tmsverno = src.get_tmsverno();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_tmsverno;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 29: 	//aperturetype int
            {
                data_aperturetype = src.get_aperturetype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_aperturetype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 30: 	//doserate float
            {
                data_doserate = src.get_doserate();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_doserate;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 31: 	//relatedrtimageuid varchar
            {
                data_relatedrtimageuid = src.get_relatedrtimageuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_relatedrtimageuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_relatedrtimageuid.size();
            }
            break;
        case 32: 	//physicalwedgeuid varchar
            {
                data_physicalwedgeuid = src.get_physicalwedgeuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_physicalwedgeuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_physicalwedgeuid.size();
            }
            break;
        case 33: 	//isautocreated tinyint
            {
                data_isautocreated = src.get_isautocreated();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isautocreated;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 34: 	//virtualwedgeuid varchar
            {
                data_virtualwedgeuid = src.get_virtualwedgeuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_virtualwedgeuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_virtualwedgeuid.size();
            }
            break;
        case 35: 	//mlcedittype int
            {
                data_mlcedittype = src.get_mlcedittype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_mlcedittype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 36: 	//targetvoiuid varchar
            {
                data_targetvoiuid = src.get_targetvoiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_targetvoiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_targetvoiuid.size();
            }
            break;
        case 37: 	//targetmarginx float
            {
                data_targetmarginx = src.get_targetmarginx();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_targetmarginx;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 38: 	//targetmarginy float
            {
                data_targetmarginy = src.get_targetmarginy();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_targetmarginy;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 39: 	//avoidvoiuid varchar
            {
                data_avoidvoiuid = src.get_avoidvoiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_avoidvoiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_avoidvoiuid.size();
            }
            break;
        case 40: 	//avoidmarginx float
            {
                data_avoidmarginx = src.get_avoidmarginx();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_avoidmarginx;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 41: 	//avoidmarginy float
            {
                data_avoidmarginy = src.get_avoidmarginy();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_avoidmarginy;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 42: 	//isautoshape tinyint
            {
                data_isautoshape = src.get_isautoshape();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isautoshape;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 43: 	//jawtype int
            {
                data_jawtype = src.get_jawtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_jawtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 44: 	//jawmarginx float
            {
                data_jawmarginx = src.get_jawmarginx();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_jawmarginx;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 45: 	//jawmarginy float
            {
                data_jawmarginy = src.get_jawmarginy();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_jawmarginy;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 46: 	//dosealgorithmtype int
            {
                data_dosealgorithmtype = src.get_dosealgorithmtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_dosealgorithmtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 47: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtBeam*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtBeam*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsbeam    48 parameters
    const int field_num = BEAM_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 64;
    MAX_LENGTH[3] = 64;
    MAX_LENGTH[4] = 64;
    MAX_LENGTH[5] = 64;
    MAX_LENGTH[6] = 64;
    MAX_LENGTH[7] = 64;
    MAX_LENGTH[8] = 1024;
    MAX_LENGTH[9] = 1024;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 0;
    MAX_LENGTH[12] = 0;
    MAX_LENGTH[13] = 0;
    MAX_LENGTH[14] = 1024;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 0;
    MAX_LENGTH[17] = 0;
    MAX_LENGTH[18] = 0;
    MAX_LENGTH[19] = 0;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 0;
    MAX_LENGTH[23] = 0;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;
    MAX_LENGTH[26] = 0;
    MAX_LENGTH[27] = 0;
    MAX_LENGTH[28] = 0;
    MAX_LENGTH[29] = 0;
    MAX_LENGTH[30] = 0;
    MAX_LENGTH[31] = 64;
    MAX_LENGTH[32] = 64;
    MAX_LENGTH[33] = 0;
    MAX_LENGTH[34] = 64;
    MAX_LENGTH[35] = 0;
    MAX_LENGTH[36] = 64;
    MAX_LENGTH[37] = 0;
    MAX_LENGTH[38] = 0;
    MAX_LENGTH[39] = 64;
    MAX_LENGTH[40] = 0;
    MAX_LENGTH[41] = 0;
    MAX_LENGTH[42] = 0;
    MAX_LENGTH[43] = 0;
    MAX_LENGTH[44] = 0;
    MAX_LENGTH[45] = 0;
    MAX_LENGTH[46] = 0;
    MAX_LENGTH[47] = 0;

    //std::string	data_uid
    //std::string	data_commissionedunituid
    //std::string	data_normgroupuid
    //std::string	data_isocenterpoiuid
    //std::string	data_toleranceuid
    //std::string	data_applicatoruid
    //std::string	data_bolusvoiuid
    //std::string	data_trayuid
    //std::string	data_description
    //std::string	data_name
    int	data_beamtype = 0;
    int	data_beamdeliverytype = 0;
    int	data_beamnumber = 0;
    double	data_beammu = 0.;
    //std::string	data_beammode
    float	data_red = 0.f;
    float	data_green = 0.f;
    float	data_blue = 0.f;
    float	data_alpha = 0.f;
    float	data_beamweight = 0.f;
    float	data_finalcumulativemetersetweight = 0.f;
    bool	data_isvisible = false;
    int	data_protocal = 0;
    float	data_normpointbeamdose = 0.f;
    float	data_bolusthickness = 0.f;
    bool	data_isjoincalc = false;
    bool	data_isjoinopt = false;
    int	data_tpsverno = 0;
    int	data_tmsverno = 0;
    int	data_aperturetype = 0;
    float	data_doserate = 0.f;
    //std::string	data_relatedrtimageuid
    //std::string	data_physicalwedgeuid
    bool	data_isautocreated = false;
    //std::string	data_virtualwedgeuid
    int	data_mlcedittype = 0;
    //std::string	data_targetvoiuid
    float	data_targetmarginx = 0.f;
    float	data_targetmarginy = 0.f;
    //std::string	data_avoidvoiuid
    float	data_avoidmarginx = 0.f;
    float	data_avoidmarginy = 0.f;
    bool	data_isautoshape = false;
    int	data_jawtype = 0;
    float	data_jawmarginx = 0.f;
    float	data_jawmarginy = 0.f;
    int	data_dosealgorithmtype = 0;
    MYSQL_TIME	data_updatetime;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 10: 	//beamtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_beamtype;
            break;
        case 11: 	//beamdeliverytype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_beamdeliverytype;
            break;
        case 12: 	//beamnumber int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_beamnumber;
            break;
        case 13: 	//beammu double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_beammu;
            break;
        case 15: 	//red float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_red;
            break;
        case 16: 	//green float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_green;
            break;
        case 17: 	//blue float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_blue;
            break;
        case 18: 	//alpha float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_alpha;
            break;
        case 19: 	//beamweight float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_beamweight;
            break;
        case 20: 	//finalcumulativemetersetweight float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_finalcumulativemetersetweight;
            break;
        case 21: 	//isvisible tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isvisible;
            break;
        case 22: 	//protocal int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_protocal;
            break;
        case 23: 	//normpointbeamdose float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_normpointbeamdose;
            break;
        case 24: 	//bolusthickness float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_bolusthickness;
            break;
        case 25: 	//isjoincalc tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isjoincalc;
            break;
        case 26: 	//isjoinopt tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isjoinopt;
            break;
        case 27: 	//tpsverno int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_tpsverno;
            break;
        case 28: 	//tmsverno int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_tmsverno;
            break;
        case 29: 	//aperturetype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_aperturetype;
            break;
        case 30: 	//doserate float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_doserate;
            break;
        case 33: 	//isautocreated tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isautocreated;
            break;
        case 35: 	//mlcedittype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_mlcedittype;
            break;
        case 37: 	//targetmarginx float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_targetmarginx;
            break;
        case 38: 	//targetmarginy float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_targetmarginy;
            break;
        case 40: 	//avoidmarginx float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_avoidmarginx;
            break;
        case 41: 	//avoidmarginy float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_avoidmarginy;
            break;
        case 42: 	//isautoshape tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isautoshape;
            break;
        case 43: 	//jawtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_jawtype;
            break;
        case 44: 	//jawmarginx float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_jawmarginx;
            break;
        case 45: 	//jawmarginy float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_jawmarginy;
            break;
        case 46: 	//dosealgorithmtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_dosealgorithmtype;
            break;
        case 47: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtBeam* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtBeam();
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//commissionedunituid varchar
                pDis->set_commissionedunituid((char *)bind[i].buffer);
                break;
            case 2: 	//normgroupuid varchar
                pDis->set_normgroupuid((char *)bind[i].buffer);
                break;
            case 3: 	//isocenterpoiuid varchar
                pDis->set_isocenterpoiuid((char *)bind[i].buffer);
                break;
            case 4: 	//toleranceuid varchar
                pDis->set_toleranceuid((char *)bind[i].buffer);
                break;
            case 5: 	//applicatoruid varchar
                pDis->set_applicatoruid((char *)bind[i].buffer);
                break;
            case 6: 	//bolusvoiuid varchar
                pDis->set_bolusvoiuid((char *)bind[i].buffer);
                break;
            case 7: 	//trayuid varchar
                pDis->set_trayuid((char *)bind[i].buffer);
                break;
            case 8: 	//description varchar
                pDis->set_description((char *)bind[i].buffer);
                break;
            case 9: 	//name varchar
                pDis->set_name((char *)bind[i].buffer);
                break;
            case 10: 	//beamtype int
                pDis->set_beamtype(data_beamtype);
                break;
            case 11: 	//beamdeliverytype int
                pDis->set_beamdeliverytype(data_beamdeliverytype);
                break;
            case 12: 	//beamnumber int
                pDis->set_beamnumber(data_beamnumber);
                break;
            case 13: 	//beammu double
                pDis->set_beammu(data_beammu);
                break;
            case 14: 	//beammode varchar
                pDis->set_beammode((char *)bind[i].buffer);
                break;
            case 15: 	//red float
                pDis->set_red(data_red);
                break;
            case 16: 	//green float
                pDis->set_green(data_green);
                break;
            case 17: 	//blue float
                pDis->set_blue(data_blue);
                break;
            case 18: 	//alpha float
                pDis->set_alpha(data_alpha);
                break;
            case 19: 	//beamweight float
                pDis->set_beamweight(data_beamweight);
                break;
            case 20: 	//finalcumulativemetersetweight float
                pDis->set_finalcumulativemetersetweight(data_finalcumulativemetersetweight);
                break;
            case 21: 	//isvisible tinyint
                pDis->set_isvisible(data_isvisible);
                break;
            case 22: 	//protocal int
                pDis->set_protocal(data_protocal);
                break;
            case 23: 	//normpointbeamdose float
                pDis->set_normpointbeamdose(data_normpointbeamdose);
                break;
            case 24: 	//bolusthickness float
                pDis->set_bolusthickness(data_bolusthickness);
                break;
            case 25: 	//isjoincalc tinyint
                pDis->set_isjoincalc(data_isjoincalc);
                break;
            case 26: 	//isjoinopt tinyint
                pDis->set_isjoinopt(data_isjoinopt);
                break;
            case 27: 	//tpsverno int
                pDis->set_tpsverno(data_tpsverno);
                break;
            case 28: 	//tmsverno int
                pDis->set_tmsverno(data_tmsverno);
                break;
            case 29: 	//aperturetype int
                pDis->set_aperturetype(data_aperturetype);
                break;
            case 30: 	//doserate float
                pDis->set_doserate(data_doserate);
                break;
            case 31: 	//relatedrtimageuid varchar
                pDis->set_relatedrtimageuid((char *)bind[i].buffer);
                break;
            case 32: 	//physicalwedgeuid varchar
                pDis->set_physicalwedgeuid((char *)bind[i].buffer);
                break;
            case 33: 	//isautocreated tinyint
                pDis->set_isautocreated(data_isautocreated);
                break;
            case 34: 	//virtualwedgeuid varchar
                pDis->set_virtualwedgeuid((char *)bind[i].buffer);
                break;
            case 35: 	//mlcedittype int
                pDis->set_mlcedittype(data_mlcedittype);
                break;
            case 36: 	//targetvoiuid varchar
                pDis->set_targetvoiuid((char *)bind[i].buffer);
                break;
            case 37: 	//targetmarginx float
                pDis->set_targetmarginx(data_targetmarginx);
                break;
            case 38: 	//targetmarginy float
                pDis->set_targetmarginy(data_targetmarginy);
                break;
            case 39: 	//avoidvoiuid varchar
                pDis->set_avoidvoiuid((char *)bind[i].buffer);
                break;
            case 40: 	//avoidmarginx float
                pDis->set_avoidmarginx(data_avoidmarginx);
                break;
            case 41: 	//avoidmarginy float
                pDis->set_avoidmarginy(data_avoidmarginy);
                break;
            case 42: 	//isautoshape tinyint
                pDis->set_isautoshape(data_isautoshape);
                break;
            case 43: 	//jawtype int
                pDis->set_jawtype(data_jawtype);
                break;
            case 44: 	//jawmarginx float
                pDis->set_jawmarginx(data_jawmarginx);
                break;
            case 45: 	//jawmarginy float
                pDis->set_jawmarginy(data_jawmarginy);
                break;
            case 46: 	//dosealgorithmtype int
                pDis->set_dosealgorithmtype(data_dosealgorithmtype);
                break;
            case 47: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE