//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_plan_voi.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 2016-8-15 14:37:11
///
///  \version 1.0
///  \date    9/2/2016
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_plan_voi.h"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtPlan_voi& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt){
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //7 parameters
    unsigned int field_num = 7;
    unsigned int field_offset = 0;
    std::string sSql = "INSERT INTO tmsplan_voi VALUES(?, ?, ?, ?, ?, ?"
        ", ?)";
    if (!bInsert){
        field_num -= 2;
        field_offset = 2;
        sSql = "UPDATE tmsplan_voi SET "
            //"uid,"
            "mindosecontribution=?,"
            "meandosecontribution=?,"
            "maxdosecontribution=?,"
            "updatetime=?,"
            "ingrid=?";
        sSql += " WHERE planuid='" + src.get_planuid() + "' AND voiuid='" + src.get_voiuid() + "'";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size())){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_planuid = "";
    std::string	data_voiuid = "";
    float		data_mindosecontribution = 0.f;
    float		data_meandosecontribution = 0.f;
    float		data_maxdosecontribution = 0.f;
    MYSQL_TIME	data_updatetime;
    float		data_ingrid = 0.f;

    for (unsigned int i(0); i<field_num; ++i){
        switch (i + field_offset){
        case 0: 	//planuid varchar
            {
                data_planuid = src.get_planuid();
                bind[i].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[i].buffer = (void*)data_planuid.c_str();
                bind[i].buffer_length = (unsigned long)data_planuid.size();
                if(data_planuid.empty()) bind[i].is_null = &isnull;
            }
            break;
        case 1: 	//voiuid varchar
            {
                data_voiuid = src.get_voiuid();
                bind[i].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[i].buffer = (void*)data_voiuid.c_str();
                bind[i].buffer_length = (unsigned long)data_voiuid.size();
                if(data_voiuid.empty()) bind[i].is_null = &isnull;
            }
            break;
        case 2: 	//mindosecontribution float
            {
                data_mindosecontribution = src.get_mindosecontribution();
                bind[i].buffer_type = MYSQL_TYPE_FLOAT;
                bind[i].buffer = (void*)&data_mindosecontribution;
                bind[i].buffer_length = sizeof(float);
            }
            break;
        case 3: 	//meandosecontribution float
            {
                data_meandosecontribution = src.get_meandosecontribution();
                bind[i].buffer_type = MYSQL_TYPE_FLOAT;
                bind[i].buffer = (void*)&data_meandosecontribution;
                bind[i].buffer_length = sizeof(float);
            }
            break;
        case 4: 	//maxdosecontribution float
            {
                data_maxdosecontribution = src.get_maxdosecontribution();
                bind[i].buffer_type = MYSQL_TYPE_FLOAT;
                bind[i].buffer = (void*)&data_maxdosecontribution;
                bind[i].buffer_length = sizeof(float);
            }
            break;
        case 5: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[i].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[i].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[i].is_null = &isnull;
            }
            break;
        case 6: 	//ingrid float
            {
                data_ingrid = src.get_ingrid();
                bind[i].buffer_type = MYSQL_TYPE_FLOAT;
                bind[i].buffer = (void*)&data_ingrid;
                bind[i].buffer_length = sizeof(float);
            }
            break;
        default:
            break;
        }
    }
    if (mysql_stmt_bind_param(stmt, bind)){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt)){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }
    if (mysql_stmt_close(stmt)){
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    DEL_ARRAY(bind);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtPlan_voi*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt){
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsplan_voi    7 parameters
    const int field_num = 7;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 0;
    MAX_LENGTH[3] = 0;
    MAX_LENGTH[4] = 0;
    MAX_LENGTH[5] = 0;
    MAX_LENGTH[6] = 0;

    //std::string	data_planuid
    //std::string	data_voiuid
    float	data_mindosecontribution = 0.f;
    float	data_meandosecontribution = 0.f;
    float	data_maxdosecontribution = 0.f;
    MYSQL_TIME	data_updatetime;
    float	data_ingrid = 0.f;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str()))){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num) {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i){
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt)){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i){
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i){
        case 2: 	//mindosecontribution float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_mindosecontribution;
            break;
        case 3: 	//meandosecontribution float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_meandosecontribution;
            break;
        case 4: 	//maxdosecontribution float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_maxdosecontribution;
            break;
        case 5: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        case 6: 	//ingrid float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ingrid;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind)){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt)){
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtPlan_voi* pDis = nullptr;
    while(true){
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtPlan_voi();
        for (unsigned int i(0); i<column_count; ++i){
            if (is_null[i]) continue;
            switch (i){
            case 0: 	//planuid varchar
                pDis->set_planuid((char *)bind[i].buffer);
                break;
            case 1: 	//voiuid varchar
                pDis->set_voiuid((char *)bind[i].buffer);
                break;
            case 2: 	//mindosecontribution float
                pDis->set_mindosecontribution(data_mindosecontribution);
                break;
            case 3: 	//meandosecontribution float
                pDis->set_meandosecontribution(data_meandosecontribution);
                break;
            case 4: 	//maxdosecontribution float
                pDis->set_maxdosecontribution(data_maxdosecontribution);
                break;
            case 5: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            case 6: 	//ingrid float
                pDis->set_ingrid(data_ingrid);
                break;
            default:
                break;
            }
        }
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt)){
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE