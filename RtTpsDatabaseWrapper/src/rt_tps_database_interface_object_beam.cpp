//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_interface_object_beam.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///              From database version: 1.1.12
///
///  \version 1.0
///  \date    8/15/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_beam.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_beamsegment.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_dosegrid.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_block.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_voi.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_uid_generater.h"

RT_TPS_DATABASE_BEGIN_NAMESPACE;

//////////////////////////////////////////////////////////////////////////

RtBeamImp::RtBeamImp(bool bGeneraterUid /*= false*/):
    m_uid(""),
    m_commissionedunituid(""),
    m_normgroupuid(""),
    m_isocenterpoiuid(""),
    m_toleranceuid(""),
    m_applicatoruid(""),
    m_bolusvoiuid(""),
    m_trayuid(""),
    m_description(""),
    m_name(""),
    m_beamtype(0),
    m_beamdeliverytype(0),
    m_beamnumber(0),
    m_beammu(0.),
    m_beammode(""),
    m_red(0.f),
    m_green(0.f),
    m_blue(0.f),
    m_alpha(0.f),
    m_beamweight(0.f),
    m_finalcumulativemetersetweight(0.f),
    m_isvisible(false),
    m_protocal(0),
    m_normpointbeamdose(0.f),
    m_bolusthickness(0.f),
    m_isjoincalc(false),
    m_isjoinopt(false),
    m_ssd(0.f),
    m_tpsverno(0),
    m_tmsverno(0),
    m_aperturetype(0),
    m_doserate(0.f),
    m_relatedrtimageuid(""),
    m_physicalwedgeuid(""),
    m_isautocreated(false),
    m_virtualwedgeuid(""),
    m_mlcedittype(0),
    m_targetvoiuid(""),
    m_targetmarginx(0.f),
    m_targetmarginy(0.f),
    m_avoidvoiuid(""),
    m_avoidmarginx(0.f),
    m_avoidmarginy(0.f),
    m_isautoshape(false),
    m_jawtype(0),
    m_jawmarginx(0.f),
    m_jawmarginy(0.f),
    m_dosealgorithmtype(0),
    m_updatetime(boost::date_time::not_a_date_time)
{
    //create uid
    m_uid = bGeneraterUid ? RtUidGenerater::GeneraterUid() : "";
    m_beamsegments.clear();
    m_aperture_block = nullptr;
    m_shield_block = nullptr;
    m_dosegrid = new RtDosegrid(bGeneraterUid);
}

RtBeamImp::RtBeamImp(const RtBeamImp& beam):
    m_uid(beam.get_uid()),
    m_commissionedunituid(beam.get_commissionedunituid()),
    m_normgroupuid(beam.get_normgroupuid()),
    m_isocenterpoiuid(beam.get_isocenterpoiuid()),
    m_toleranceuid(beam.get_toleranceuid()),
    m_applicatoruid(beam.get_applicatoruid()),
    m_bolusvoiuid(beam.get_bolusvoiuid()),
    m_trayuid(beam.get_trayuid()),
    m_description(beam.get_description()),
    m_name(beam.get_name()),
    m_beamtype(beam.get_beamtype()),
    m_beamdeliverytype(beam.get_beamdeliverytype()),
    m_beamnumber(beam.get_beamnumber()),
    m_beammu(beam.get_beammu()),
    m_beammode(beam.get_beammode()),
    m_red(beam.get_red()),
    m_green(beam.get_green()),
    m_blue(beam.get_blue()),
    m_alpha(beam.get_alpha()),
    m_beamweight(beam.get_beamweight()),
    m_finalcumulativemetersetweight(beam.get_finalcumulativemetersetweight()),
    m_isvisible(beam.get_isvisible()),
    m_protocal(beam.get_protocal()),
    m_normpointbeamdose(beam.get_normpointbeamdose()),
    m_bolusthickness(beam.get_bolusthickness()),
    m_isjoincalc(beam.get_isjoincalc()),
    m_isjoinopt(beam.get_isjoinopt()),
    m_ssd(beam.get_ssd()),
    m_tpsverno(beam.get_tpsverno()),
    m_tmsverno(beam.get_tmsverno()),
    m_aperturetype(beam.get_aperturetype()),
    m_doserate(beam.get_doserate()),
    m_relatedrtimageuid(beam.get_relatedrtimageuid()),
    m_physicalwedgeuid(beam.get_physicalwedgeuid()),
    m_isautocreated(beam.get_isautocreated()),
    m_virtualwedgeuid(beam.get_virtualwedgeuid()),
    m_mlcedittype(beam.get_mlcedittype()),
    m_targetvoiuid(beam.get_targetvoiuid()),
    m_targetmarginx(beam.get_targetmarginx()),
    m_targetmarginy(beam.get_targetmarginy()),
    m_avoidvoiuid(beam.get_avoidvoiuid()),
    m_avoidmarginx(beam.get_avoidmarginx()),
    m_avoidmarginy(beam.get_avoidmarginy()),
    m_isautoshape(beam.get_isautoshape()),
    m_jawtype(beam.get_jawtype()),
    m_jawmarginx(beam.get_jawmarginx()),
    m_jawmarginy(beam.get_jawmarginy()),
    m_dosealgorithmtype(beam.get_dosealgorithmtype()),
    m_updatetime(beam.get_updatetime())
{
    this->set_beamsegments(beam.get_beamsegments());

    m_aperture_block = nullptr;
    if (nullptr != beam.get_aperture_block()) m_aperture_block = new RtBlock(*beam.get_aperture_block());
    m_shield_block = nullptr;
    if (nullptr != beam.get_shield_block()) m_shield_block = new RtBlock(*beam.get_shield_block());
    m_dosegrid = new RtDosegrid(*beam.get_dosegrid());
}

RtBeamImp& RtBeamImp::operator=(const RtBeamImp& beam)
{
    if (this != &beam){
        this->m_uid = beam.get_uid();
        this->m_commissionedunituid = beam.get_commissionedunituid();
        this->m_normgroupuid = beam.get_normgroupuid();
        this->m_isocenterpoiuid = beam.get_isocenterpoiuid();
        this->m_toleranceuid = beam.get_toleranceuid();
        this->m_applicatoruid = beam.get_applicatoruid();
        this->m_bolusvoiuid = beam.get_bolusvoiuid();
        this->m_trayuid = beam.get_trayuid();
        this->m_description = beam.get_description();
        this->m_name = beam.get_name();
        this->m_beamtype = beam.get_beamtype();
        this->m_beamdeliverytype = beam.get_beamdeliverytype();
        this->m_beamnumber = beam.get_beamnumber();
        this->m_beammu = beam.get_beammu();
        this->m_beammode = beam.get_beammode();
        this->m_red = beam.get_red();
        this->m_green = beam.get_green();
        this->m_blue = beam.get_blue();
        this->m_alpha = beam.get_alpha();
        this->m_beamweight = beam.get_beamweight();
        this->m_finalcumulativemetersetweight = beam.get_finalcumulativemetersetweight();
        this->m_isvisible = beam.get_isvisible();
        this->m_protocal = beam.get_protocal();
        this->m_normpointbeamdose = beam.get_normpointbeamdose();
        this->m_bolusthickness = beam.get_bolusthickness();
        this->m_isjoincalc = beam.get_isjoincalc();
        this->m_isjoinopt = beam.get_isjoinopt();
        this->m_ssd = beam.get_ssd();
        this->m_tpsverno = beam.get_tpsverno();
        this->m_tmsverno = beam.get_tmsverno();
        this->m_aperturetype = beam.get_aperturetype();
        this->m_doserate = beam.get_doserate();
        this->m_relatedrtimageuid = beam.get_relatedrtimageuid();
        this->m_physicalwedgeuid = beam.get_physicalwedgeuid();
        this->m_isautocreated = beam.get_isautocreated();
        this->m_virtualwedgeuid = beam.get_virtualwedgeuid();
        this->m_mlcedittype = beam.get_mlcedittype();
        this->m_targetvoiuid = beam.get_targetvoiuid();
        this->m_targetmarginx = beam.get_targetmarginx();
        this->m_targetmarginy = beam.get_targetmarginy();
        this->m_avoidvoiuid = beam.get_avoidvoiuid();
        this->m_avoidmarginx = beam.get_avoidmarginx();
        this->m_avoidmarginy = beam.get_avoidmarginy();
        this->m_isautoshape = beam.get_isautoshape();
        this->m_jawtype = beam.get_jawtype();
        this->m_jawmarginx = beam.get_jawmarginx();
        this->m_jawmarginy = beam.get_jawmarginy();
        this->m_dosealgorithmtype = beam.get_dosealgorithmtype();
        this->m_updatetime = beam.get_updatetime();

        this->set_beamsegments(beam.get_beamsegments());
        m_aperture_block = nullptr;
        if (nullptr != beam.get_aperture_block()) 
        {  
            DEL_PTR(m_aperture_block);
            m_aperture_block = new RtBlock(*beam.get_aperture_block());
        }
        m_shield_block = nullptr;
        if (nullptr != beam.get_shield_block()) 
        {  
            DEL_PTR(m_shield_block);
            m_shield_block = new RtBlock(*beam.get_shield_block());
        }
        *m_dosegrid = *beam.get_dosegrid();
    }
    return *this;
}

RtBeamImp::~RtBeamImp()
{
    for (auto itr=m_beamsegments.begin(); itr!=m_beamsegments.end(); ++itr) DEL_PTR(*itr);
    m_beamsegments.clear();

    DEL_PTR(m_aperture_block);
    DEL_PTR(m_shield_block);
    DEL_PTR(m_dosegrid);
}


void RtBeamImp::set_beamsegments(std::vector<RtBeamsegment*> beamsegments) 
{
    //delete old values
    for (auto itr=m_beamsegments.begin(); itr!=m_beamsegments.end(); ++itr) DEL_PTR(*itr);
    m_beamsegments.clear();

    //copy new values
	for (auto itr=beamsegments.cbegin(); itr!=beamsegments.cend(); ++itr)
	{
		RtBeamsegment* pSeg = new RtBeamsegment(*(*itr));
		m_beamsegments.push_back(pSeg);
	}
}

RtDosegrid* RtBeamImp::get_dosegrid()
{
    return m_dosegrid;
}

RtDosegrid* RtBeamImp::get_dosegrid() const
{
    return m_dosegrid;
}

void RtBeamImp::create_aperture_block()
{
    DEL_PTR(m_aperture_block);
    m_aperture_block =  new RtBlock(true);
    m_aperture_block->set_blocktype(RtDbDef::APERTURE);
}
RtBlock* RtBeamImp::get_aperture_block() const
{
    return m_aperture_block;
}
void RtBeamImp::remove_aperture_block()
{
    DEL_PTR(m_aperture_block);
}

void RtBeamImp::create_shield_block()
{
    DEL_PTR(m_shield_block);
    m_shield_block =  new RtBlock(true);
    m_shield_block->set_blocktype(RtDbDef::SHIELDING);
}
RtBlock* RtBeamImp::get_shield_block() const
{
    return m_shield_block;
}
void RtBeamImp::remove_shield_block()
{
    DEL_PTR(m_shield_block);
}

//////////////////////////////////////////////////////////////////////////
RtBeam::RtBeam(bool bGeneraterUid /*= false*/)
{
    m_pImp = new RtBeamImp(bGeneraterUid);
    set_flags(BEAM_FIELD_MAX);
    set_field_null((char*)ENUM2STRING_BEAM_FIELD_NULL);
}

RtBeam::RtBeam(const RtBeam& beam): RtDatabaseObject(beam),
   m_pImp(new RtBeamImp(*beam.m_pImp))
{
}

RtBeam& RtBeam::operator = (const RtBeam& beam)
{
    if(this != &beam)
    {
        RtDatabaseObject::operator=(beam);
        *this->m_pImp = *beam.m_pImp;
    }
    return *this;
}

RtBeam::~RtBeam()
{
    DEL_PTR(m_pImp);
}

//uid
std::string RtBeam::get_uid() const { return m_pImp->get_uid();}
void RtBeam::set_uid(const std::string& uid)
{
    m_pImp->set_uid(uid);
    enable_field(BEAM_UID);
    setdirty_field(BEAM_UID, true);
}

//commissionedunituid
std::string RtBeam::get_commissionedunituid() const { return m_pImp->get_commissionedunituid();}
void RtBeam::set_commissionedunituid(const std::string& commissionedunituid)
{
    m_pImp->set_commissionedunituid(commissionedunituid);
    enable_field(BEAM_COMMISSIONEDUNITUID);
    setdirty_field(BEAM_COMMISSIONEDUNITUID, true);
}

//normgroupuid
std::string RtBeam::get_normgroupuid() const { return m_pImp->get_normgroupuid();}
void RtBeam::set_normgroupuid(const std::string& normgroupuid)
{
    m_pImp->set_normgroupuid(normgroupuid);
    enable_field(BEAM_NORMGROUPUID);
    setdirty_field(BEAM_NORMGROUPUID, true);
}

//isocenterpoiuid
std::string RtBeam::get_isocenterpoiuid() const { return m_pImp->get_isocenterpoiuid();}
void RtBeam::set_isocenterpoiuid(const std::string& isocenterpoiuid)
{
    m_pImp->set_isocenterpoiuid(isocenterpoiuid);
    enable_field(BEAM_ISOCENTERPOIUID);
    setdirty_field(BEAM_ISOCENTERPOIUID, true);
}

//toleranceuid
std::string RtBeam::get_toleranceuid() const { return m_pImp->get_toleranceuid();}
void RtBeam::set_toleranceuid(const std::string& toleranceuid)
{
    m_pImp->set_toleranceuid(toleranceuid);
    enable_field(BEAM_TOLERANCEUID);
    setdirty_field(BEAM_TOLERANCEUID, true);
}

//applicatoruid
std::string RtBeam::get_applicatoruid() const { return m_pImp->get_applicatoruid();}
void RtBeam::set_applicatoruid(const std::string& applicatoruid)
{
    m_pImp->set_applicatoruid(applicatoruid);
    enable_field(BEAM_APPLICATORUID);
    setdirty_field(BEAM_APPLICATORUID, true);
}

//bolusvoiuid
std::string RtBeam::get_bolusvoiuid() const { return m_pImp->get_bolusvoiuid();}
void RtBeam::set_bolusvoiuid(const std::string& bolusvoiuid)
{
    m_pImp->set_bolusvoiuid(bolusvoiuid);
    enable_field(BEAM_BOLUSVOIUID);
    setdirty_field(BEAM_BOLUSVOIUID, true);
}

//trayuid
std::string RtBeam::get_trayuid() const { return m_pImp->get_trayuid();}
void RtBeam::set_trayuid(const std::string& trayuid)
{
    m_pImp->set_trayuid(trayuid);
    enable_field(BEAM_TRAYUID);
    setdirty_field(BEAM_TRAYUID, true);
}

//description
std::string RtBeam::get_description() const { return m_pImp->get_description();}
void RtBeam::set_description(const std::string& description)
{
    m_pImp->set_description(description);
    enable_field(BEAM_DESCRIPTION);
    setdirty_field(BEAM_DESCRIPTION, true);
}

//name
std::string RtBeam::get_name() const { return m_pImp->get_name();}
void RtBeam::set_name(const std::string& name)
{
    m_pImp->set_name(name);
    enable_field(BEAM_NAME);
    setdirty_field(BEAM_NAME, true);
}

//beamtype
int RtBeam::get_beamtype() const { return m_pImp->get_beamtype();}
void RtBeam::set_beamtype(const int& beamtype)
{
    m_pImp->set_beamtype(beamtype);
    enable_field(BEAM_BEAMTYPE);
    setdirty_field(BEAM_BEAMTYPE, true);
}

//beamdeliverytype
int RtBeam::get_beamdeliverytype() const { return m_pImp->get_beamdeliverytype();}
void RtBeam::set_beamdeliverytype(const int& beamdeliverytype)
{
    m_pImp->set_beamdeliverytype(beamdeliverytype);
    enable_field(BEAM_BEAMDELIVERYTYPE);
    setdirty_field(BEAM_BEAMDELIVERYTYPE, true);
}

//beamnumber
int RtBeam::get_beamnumber() const { return m_pImp->get_beamnumber();}
void RtBeam::set_beamnumber(const int& beamnumber)
{
    m_pImp->set_beamnumber(beamnumber);
    enable_field(BEAM_BEAMNUMBER);
    setdirty_field(BEAM_BEAMNUMBER, true);
}

//beammu
double RtBeam::get_beammu() const { return m_pImp->get_beammu();}
void RtBeam::set_beammu(const double& beammu)
{
    m_pImp->set_beammu(beammu);
    enable_field(BEAM_BEAMMU);
    setdirty_field(BEAM_BEAMMU, true);
}

//beammode
std::string RtBeam::get_beammode() const { return m_pImp->get_beammode();}
void RtBeam::set_beammode(const std::string& beammode)
{
    m_pImp->set_beammode(beammode);
    enable_field(BEAM_BEAMMODE);
    setdirty_field(BEAM_BEAMMODE, true);
}

//red
float RtBeam::get_red() const { return m_pImp->get_red();}
void RtBeam::set_red(const float& red)
{
    m_pImp->set_red(red);
    enable_field(BEAM_RED);
    setdirty_field(BEAM_RED, true);
}

//green
float RtBeam::get_green() const { return m_pImp->get_green();}
void RtBeam::set_green(const float& green)
{
    m_pImp->set_green(green);
    enable_field(BEAM_GREEN);
    setdirty_field(BEAM_GREEN, true);
}

//blue
float RtBeam::get_blue() const { return m_pImp->get_blue();}
void RtBeam::set_blue(const float& blue)
{
    m_pImp->set_blue(blue);
    enable_field(BEAM_BLUE);
    setdirty_field(BEAM_BLUE, true);
}

//alpha
float RtBeam::get_alpha() const { return m_pImp->get_alpha();}
void RtBeam::set_alpha(const float& alpha)
{
    m_pImp->set_alpha(alpha);
    enable_field(BEAM_ALPHA);
    setdirty_field(BEAM_ALPHA, true);
}

//beamweight
float RtBeam::get_beamweight() const { return m_pImp->get_beamweight();}
void RtBeam::set_beamweight(const float& beamweight)
{
    m_pImp->set_beamweight(beamweight);
    enable_field(BEAM_BEAMWEIGHT);
    setdirty_field(BEAM_BEAMWEIGHT, true);
}

//finalcumulativemetersetweight
float RtBeam::get_finalcumulativemetersetweight() const { return m_pImp->get_finalcumulativemetersetweight();}
void RtBeam::set_finalcumulativemetersetweight(const float& finalcumulativemetersetweight)
{
    m_pImp->set_finalcumulativemetersetweight(finalcumulativemetersetweight);
    enable_field(BEAM_FINALCUMULATIVEMETERSETWEIGHT);
    setdirty_field(BEAM_FINALCUMULATIVEMETERSETWEIGHT, true);
}

//isvisible
bool RtBeam::get_isvisible() const { return m_pImp->get_isvisible();}
void RtBeam::set_isvisible(const bool& isvisible)
{
    m_pImp->set_isvisible(isvisible);
    enable_field(BEAM_ISVISIBLE);
    setdirty_field(BEAM_ISVISIBLE, true);
}

//protocal
int RtBeam::get_protocal() const { return m_pImp->get_protocal();}
void RtBeam::set_protocal(const int& protocal)
{
    m_pImp->set_protocal(protocal);
    enable_field(BEAM_PROTOCAL);
    setdirty_field(BEAM_PROTOCAL, true);
}

//normpointbeamdose
float RtBeam::get_normpointbeamdose() const { return m_pImp->get_normpointbeamdose();}
void RtBeam::set_normpointbeamdose(const float& normpointbeamdose)
{
    m_pImp->set_normpointbeamdose(normpointbeamdose);
    enable_field(BEAM_NORMPOINTBEAMDOSE);
    setdirty_field(BEAM_NORMPOINTBEAMDOSE, true);
}

//bolusthickness
float RtBeam::get_bolusthickness() const { return m_pImp->get_bolusthickness();}
void RtBeam::set_bolusthickness(const float& bolusthickness)
{
    m_pImp->set_bolusthickness(bolusthickness);
    enable_field(BEAM_BOLUSTHICKNESS);
    setdirty_field(BEAM_BOLUSTHICKNESS, true);
}

//isjoincalc
bool RtBeam::get_isjoincalc() const { return m_pImp->get_isjoincalc();}
void RtBeam::set_isjoincalc(const bool& isjoincalc)
{
    m_pImp->set_isjoincalc(isjoincalc);
    enable_field(BEAM_ISJOINCALC);
    setdirty_field(BEAM_ISJOINCALC, true);
}

//isjoinopt
bool RtBeam::get_isjoinopt() const { return m_pImp->get_isjoinopt();}
void RtBeam::set_isjoinopt(const bool& isjoinopt)
{
    m_pImp->set_isjoinopt(isjoinopt);
    enable_field(BEAM_ISJOINOPT);
    setdirty_field(BEAM_ISJOINOPT, true);
}

//ssd, need to be deleted
float RtBeam::get_ssd() const { return m_pImp->get_ssd();}
void RtBeam::set_ssd(const float& ssd)
{
    m_pImp->set_ssd(ssd);
}

//tpsverno
int RtBeam::get_tpsverno() const { return m_pImp->get_tpsverno();}
void RtBeam::set_tpsverno(const int& tpsverno)
{
    m_pImp->set_tpsverno(tpsverno);
    enable_field(BEAM_TPSVERNO);
    setdirty_field(BEAM_TPSVERNO, true);
}

//tmsverno
int RtBeam::get_tmsverno() const { return m_pImp->get_tmsverno();}
void RtBeam::set_tmsverno(const int& tmsverno)
{
    m_pImp->set_tmsverno(tmsverno);
    enable_field(BEAM_TMSVERNO);
    setdirty_field(BEAM_TMSVERNO, true);
}

//aperturetype
int RtBeam::get_aperturetype() const { return m_pImp->get_aperturetype();}
void RtBeam::set_aperturetype(const int& aperturetype)
{
    m_pImp->set_aperturetype(aperturetype);
    enable_field(BEAM_APERTURETYPE);
    setdirty_field(BEAM_APERTURETYPE, true);
}

//doserate
float RtBeam::get_doserate() const { return m_pImp->get_doserate();}
void RtBeam::set_doserate(const float& doserate)
{
    m_pImp->set_doserate(doserate);
    enable_field(BEAM_DOSERATE);
    setdirty_field(BEAM_DOSERATE, true);
}

//relatedrtimageuid
std::string RtBeam::get_relatedrtimageuid() const { return m_pImp->get_relatedrtimageuid();}
void RtBeam::set_relatedrtimageuid(const std::string& relatedrtimageuid)
{
    m_pImp->set_relatedrtimageuid(relatedrtimageuid);
    enable_field(BEAM_RELATEDRTIMAGEUID);
    setdirty_field(BEAM_RELATEDRTIMAGEUID, true);
}

//physicalwedgeuid
std::string RtBeam::get_physicalwedgeuid() const { return m_pImp->get_physicalwedgeuid();}
void RtBeam::set_physicalwedgeuid(const std::string& physicalwedgeuid)
{
    m_pImp->set_physicalwedgeuid(physicalwedgeuid);
    enable_field(BEAM_PHYSICALWEDGEUID);
    setdirty_field(BEAM_PHYSICALWEDGEUID, true);
}

//isautocreated
bool RtBeam::get_isautocreated() const { return m_pImp->get_isautocreated();}
void RtBeam::set_isautocreated(const bool& isautocreated)
{
    m_pImp->set_isautocreated(isautocreated);
    enable_field(BEAM_ISAUTOCREATED);
    setdirty_field(BEAM_ISAUTOCREATED, true);
}

//virtualwedgeuid
std::string RtBeam::get_virtualwedgeuid() const { return m_pImp->get_virtualwedgeuid();}
void RtBeam::set_virtualwedgeuid(const std::string& virtualwedgeuid)
{
    m_pImp->set_virtualwedgeuid(virtualwedgeuid);
    enable_field(BEAM_VIRTUALWEDGEUID);
    setdirty_field(BEAM_VIRTUALWEDGEUID, true);
}

//mlcedittype
int RtBeam::get_mlcedittype() const { return m_pImp->get_mlcedittype();}
void RtBeam::set_mlcedittype(const int& mlcedittype)
{
    m_pImp->set_mlcedittype(mlcedittype);
    enable_field(BEAM_MLCEDITTYPE);
    setdirty_field(BEAM_MLCEDITTYPE, true);
}

//targetvoiuid
std::string RtBeam::get_targetvoiuid() const { return m_pImp->get_targetvoiuid();}
void RtBeam::set_targetvoiuid(const std::string& targetvoiuid)
{
    m_pImp->set_targetvoiuid(targetvoiuid);
    enable_field(BEAM_TARGETVOIUID);
    setdirty_field(BEAM_TARGETVOIUID, true);
}

//targetmarginx
float RtBeam::get_targetmarginx() const { return m_pImp->get_targetmarginx();}
void RtBeam::set_targetmarginx(const float& targetmarginx)
{
    m_pImp->set_targetmarginx(targetmarginx);
    enable_field(BEAM_TARGETMARGINX);
    setdirty_field(BEAM_TARGETMARGINX, true);
}

//targetmarginy
float RtBeam::get_targetmarginy() const { return m_pImp->get_targetmarginy();}
void RtBeam::set_targetmarginy(const float& targetmarginy)
{
    m_pImp->set_targetmarginy(targetmarginy);
    enable_field(BEAM_TARGETMARGINY);
    setdirty_field(BEAM_TARGETMARGINY, true);
}

//avoidvoiuid
std::string RtBeam::get_avoidvoiuid() const { return m_pImp->get_avoidvoiuid();}
void RtBeam::set_avoidvoiuid(const std::string& avoidvoiuid)
{
    m_pImp->set_avoidvoiuid(avoidvoiuid);
    enable_field(BEAM_AVOIDVOIUID);
    setdirty_field(BEAM_AVOIDVOIUID, true);
}

//avoidmarginx
float RtBeam::get_avoidmarginx() const { return m_pImp->get_avoidmarginx();}
void RtBeam::set_avoidmarginx(const float& avoidmarginx)
{
    m_pImp->set_avoidmarginx(avoidmarginx);
    enable_field(BEAM_AVOIDMARGINX);
    setdirty_field(BEAM_AVOIDMARGINX, true);
}

//avoidmarginy
float RtBeam::get_avoidmarginy() const { return m_pImp->get_avoidmarginy();}
void RtBeam::set_avoidmarginy(const float& avoidmarginy)
{
    m_pImp->set_avoidmarginy(avoidmarginy);
    enable_field(BEAM_AVOIDMARGINY);
    setdirty_field(BEAM_AVOIDMARGINY, true);
}

//isautoshape
bool RtBeam::get_isautoshape() const { return m_pImp->get_isautoshape();}
void RtBeam::set_isautoshape(const bool& isautoshape)
{
    m_pImp->set_isautoshape(isautoshape);
    enable_field(BEAM_ISAUTOSHAPE);
    setdirty_field(BEAM_ISAUTOSHAPE, true);
}

//jawtype
int RtBeam::get_jawtype() const { return m_pImp->get_jawtype();}
void RtBeam::set_jawtype(const int& jawtype)
{
    m_pImp->set_jawtype(jawtype);
    enable_field(BEAM_JAWTYPE);
    setdirty_field(BEAM_JAWTYPE, true);
}

//jawmarginx
float RtBeam::get_jawmarginx() const { return m_pImp->get_jawmarginx();}
void RtBeam::set_jawmarginx(const float& jawmarginx)
{
    m_pImp->set_jawmarginx(jawmarginx);
    enable_field(BEAM_JAWMARGINX);
    setdirty_field(BEAM_JAWMARGINX, true);
}

//jawmarginy
float RtBeam::get_jawmarginy() const { return m_pImp->get_jawmarginy();}
void RtBeam::set_jawmarginy(const float& jawmarginy)
{
    m_pImp->set_jawmarginy(jawmarginy);
    enable_field(BEAM_JAWMARGINY);
    setdirty_field(BEAM_JAWMARGINY, true);
}

//dosealgorithmtype
int RtBeam::get_dosealgorithmtype() const { return m_pImp->get_dosealgorithmtype();}
void RtBeam::set_dosealgorithmtype(const int& dosealgorithmtype)
{
    m_pImp->set_dosealgorithmtype(dosealgorithmtype);
    enable_field(BEAM_DOSEALGORITHMTYPE);
    setdirty_field(BEAM_DOSEALGORITHMTYPE, true);
}

//updatetime
DATETIME_BOOST RtBeam::get_updatetime() const { return m_pImp->get_updatetime();}
void RtBeam::set_updatetime(const DATETIME_BOOST& updatetime)
{
    m_pImp->set_updatetime(updatetime);
    enable_field(BEAM_UPDATETIME);
    setdirty_field(BEAM_UPDATETIME, true);
}
//////////////////////////////////////////////////////////////////////////
//manually NOT from database columns!
std::vector<RtBeamsegment*> RtBeam::get_beamsegments() const {return m_pImp->get_beamsegments();}
void RtBeam::set_beamsegments(std::vector<RtBeamsegment*> beamsegments) {m_pImp->set_beamsegments(beamsegments);}

RtDosegrid* RtBeam::get_dosegrid() {return m_pImp->get_dosegrid();}
RtDosegrid* RtBeam::get_dosegrid() const {return m_pImp->get_dosegrid();}

void RtBeam::create_aperture_block() { m_pImp->create_aperture_block();}
RtBlock* RtBeam::get_aperture_block() const {return m_pImp->get_aperture_block();}
void RtBeam::remove_aperture_block() {m_pImp->remove_aperture_block();}

void RtBeam::create_shield_block() { m_pImp->create_shield_block();}
RtBlock* RtBeam::get_shield_block() const {return m_pImp->get_shield_block();}
void RtBeam::remove_shield_block() {m_pImp->remove_shield_block();}

RT_TPS_DATABASE_END_NAMESPACE