//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_interface_object_beamsegment.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///              From database version: 1.1.12
///
///  \version 1.0
///  \date    8/15/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_beamsegment.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_contour.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_mlcshape.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_uid_generater.h"

RT_TPS_DATABASE_BEGIN_NAMESPACE;

//////////////////////////////////////////////////////////////////////////

RtBeamsegmentImp::RtBeamsegmentImp(bool bGeneraterUid /*= false*/):
    m_uid(""),
    m_beamuid(""),
    m_sequencenumber(0),
    m_name(""),
    m_mu(0.f),
    m_weight(0.f),
    m_startcollimatorangle(0.),
    m_startgantryangle(0.),
    m_starttablerotationangle(0.),
    m_endcollimatorangle(0.),
    m_arclength(0.),
    m_endtablerotationangle(0.),
    m_ispre(false),
    m_ispost(false),
    m_isduring(false),
    m_isdouble(false),
    m_gantryrotationdirection(0),
    m_collimatorrotationdirection(0),
    m_startssd(0.f),
    m_endssd(0.f),
    m_updatetime(boost::date_time::not_a_date_time)
{
    //create uid
    m_uid = bGeneraterUid ? RtUidGenerater::GeneraterUid() : "";
    memset(m_t_beam_to_pat, 0, sizeof(float)*16);
    m_start_mlcshape = new RtMlcshape(bGeneraterUid);
    m_start_mlcshape->set_segmentuid(m_uid);
    m_start_mlcshape->set_isstartmlcshape(true);
    m_end_mlcshape = new RtMlcshape(bGeneraterUid);
    m_end_mlcshape->set_segmentuid(m_uid);
    m_end_mlcshape->set_isstartmlcshape(false);
    m_beam_outline = new RtContour(bGeneraterUid);
}

RtBeamsegmentImp::RtBeamsegmentImp(const RtBeamsegmentImp& beamsegment):
    m_uid(beamsegment.get_uid()),
    m_beamuid(beamsegment.get_beamuid()),
    m_sequencenumber(beamsegment.get_sequencenumber()),
    m_name(beamsegment.get_name()),
    m_mu(beamsegment.get_mu()),
    m_weight(beamsegment.get_weight()),
    m_startcollimatorangle(beamsegment.get_startcollimatorangle()),
    m_startgantryangle(beamsegment.get_startgantryangle()),
    m_starttablerotationangle(beamsegment.get_starttablerotationangle()),
    m_endcollimatorangle(beamsegment.get_endcollimatorangle()),
    m_arclength(beamsegment.get_arclength()),
    m_endtablerotationangle(beamsegment.get_endtablerotationangle()),
    m_ispre(beamsegment.get_ispre()),
    m_ispost(beamsegment.get_ispost()),
    m_isduring(beamsegment.get_isduring()),
    m_isdouble(beamsegment.get_isdouble()),
    m_gantryrotationdirection(beamsegment.get_gantryrotationdirection()),
    m_collimatorrotationdirection(beamsegment.get_collimatorrotationdirection()),
    m_startssd(beamsegment.get_startssd()),
    m_endssd(beamsegment.get_endssd()),
    m_updatetime(beamsegment.get_updatetime())
{
    this->set_t_beam_to_pat(beamsegment.get_t_beam_to_pat());
    this->m_beam_outline = new RtContour(*beamsegment.get_beamoutline());
    this->m_start_mlcshape = new RtMlcshape(*beamsegment.get_startmlcshape());
    this->m_end_mlcshape = new RtMlcshape(*beamsegment.get_endmlcshape());
}

RtBeamsegmentImp& RtBeamsegmentImp::operator=(const RtBeamsegmentImp& beamsegment)
{
    if (this != &beamsegment){
        this->m_uid = beamsegment.get_uid();
        this->m_beamuid = beamsegment.get_beamuid();
        this->m_sequencenumber = beamsegment.get_sequencenumber();
        this->m_name = beamsegment.get_name();
        this->m_mu = beamsegment.get_mu();
        this->m_weight = beamsegment.get_weight();
        this->m_startcollimatorangle = beamsegment.get_startcollimatorangle();
        this->m_startgantryangle = beamsegment.get_startgantryangle();
        this->m_starttablerotationangle = beamsegment.get_starttablerotationangle();
        this->m_endcollimatorangle = beamsegment.get_endcollimatorangle();
        this->m_arclength = beamsegment.get_arclength();
        this->m_endtablerotationangle = beamsegment.get_endtablerotationangle();
        this->m_ispre = beamsegment.get_ispre();
        this->m_ispost = beamsegment.get_ispost();
        this->m_isduring = beamsegment.get_isduring();
        this->m_isdouble = beamsegment.get_isdouble();
        this->m_gantryrotationdirection = beamsegment.get_gantryrotationdirection();
        this->m_collimatorrotationdirection = beamsegment.get_collimatorrotationdirection();
        this->m_startssd = beamsegment.get_startssd();
        this->m_endssd = beamsegment.get_endssd();
        this->m_updatetime = beamsegment.get_updatetime();
        this->set_t_beam_to_pat(beamsegment.get_t_beam_to_pat());
        *this->m_beam_outline = *beamsegment.get_beamoutline();
        *this->m_start_mlcshape = *beamsegment.get_startmlcshape();
        *this->m_end_mlcshape = *beamsegment.get_endmlcshape();
    }
    return *this;
}

RtBeamsegmentImp::~RtBeamsegmentImp()
{
    DEL_PTR(m_beam_outline);
    DEL_PTR(m_start_mlcshape);
    DEL_PTR(m_end_mlcshape);
}


//////////////////////////////////////////////////////////////////////////
RtBeamsegment::RtBeamsegment(bool bGeneraterUid /*= false*/)
{
    m_pImp = new RtBeamsegmentImp(bGeneraterUid);
    set_flags(BEAMSEGMENT_FIELD_MAX);
    set_field_null((char*)ENUM2STRING_BEAMSEGMENT_FIELD_NULL);
}

RtBeamsegment::RtBeamsegment(const RtBeamsegment& beamsegment): RtDatabaseObject(beamsegment),
   m_pImp(new RtBeamsegmentImp(*beamsegment.m_pImp))
{
}

RtBeamsegment& RtBeamsegment::operator = (const RtBeamsegment& beamsegment)
{
    if(this != &beamsegment)
    {
        RtDatabaseObject::operator=(beamsegment);
        *this->m_pImp = *beamsegment.m_pImp;
    }
    return *this;
}

RtBeamsegment::~RtBeamsegment()
{
    DEL_PTR(m_pImp);
}

//uid
std::string RtBeamsegment::get_uid() const { return m_pImp->get_uid();}
void RtBeamsegment::set_uid(const std::string& uid)
{
    m_pImp->set_uid(uid);
    enable_field(BEAMSEGMENT_UID);
    setdirty_field(BEAMSEGMENT_UID, true);
}

//beamuid
std::string RtBeamsegment::get_beamuid() const { return m_pImp->get_beamuid();}
void RtBeamsegment::set_beamuid(const std::string& beamuid)
{
    m_pImp->set_beamuid(beamuid);
    enable_field(BEAMSEGMENT_BEAMUID);
    setdirty_field(BEAMSEGMENT_BEAMUID, true);
}

//sequencenumber
int RtBeamsegment::get_sequencenumber() const { return m_pImp->get_sequencenumber();}
void RtBeamsegment::set_sequencenumber(const int& sequencenumber)
{
    m_pImp->set_sequencenumber(sequencenumber);
    enable_field(BEAMSEGMENT_SEQUENCENUMBER);
    setdirty_field(BEAMSEGMENT_SEQUENCENUMBER, true);
}

//name
std::string RtBeamsegment::get_name() const { return m_pImp->get_name();}
void RtBeamsegment::set_name(const std::string& name)
{
    m_pImp->set_name(name);
    enable_field(BEAMSEGMENT_NAME);
    setdirty_field(BEAMSEGMENT_NAME, true);
}

//mu
float RtBeamsegment::get_mu() const { return m_pImp->get_mu();}
void RtBeamsegment::set_mu(const float& mu)
{
    m_pImp->set_mu(mu);
    enable_field(BEAMSEGMENT_MU);
    setdirty_field(BEAMSEGMENT_MU, true);
}

//weight
float RtBeamsegment::get_weight() const { return m_pImp->get_weight();}
void RtBeamsegment::set_weight(const float& weight)
{
    m_pImp->set_weight(weight);
    enable_field(BEAMSEGMENT_WEIGHT);
    setdirty_field(BEAMSEGMENT_WEIGHT, true);
}

//startcollimatorangle
double RtBeamsegment::get_startcollimatorangle() const { return m_pImp->get_startcollimatorangle();}
void RtBeamsegment::set_startcollimatorangle(const double& startcollimatorangle)
{
    m_pImp->set_startcollimatorangle(startcollimatorangle);
    enable_field(BEAMSEGMENT_STARTCOLLIMATORANGLE);
    setdirty_field(BEAMSEGMENT_STARTCOLLIMATORANGLE, true);
}

//startgantryangle
double RtBeamsegment::get_startgantryangle() const { return m_pImp->get_startgantryangle();}
void RtBeamsegment::set_startgantryangle(const double& startgantryangle)
{
    m_pImp->set_startgantryangle(startgantryangle);
    enable_field(BEAMSEGMENT_STARTGANTRYANGLE);
    setdirty_field(BEAMSEGMENT_STARTGANTRYANGLE, true);
}

//starttablerotationangle
double RtBeamsegment::get_starttablerotationangle() const { return m_pImp->get_starttablerotationangle();}
void RtBeamsegment::set_starttablerotationangle(const double& starttablerotationangle)
{
    m_pImp->set_starttablerotationangle(starttablerotationangle);
    enable_field(BEAMSEGMENT_STARTTABLEROTATIONANGLE);
    setdirty_field(BEAMSEGMENT_STARTTABLEROTATIONANGLE, true);
}

//endcollimatorangle
double RtBeamsegment::get_endcollimatorangle() const { return m_pImp->get_endcollimatorangle();}
void RtBeamsegment::set_endcollimatorangle(const double& endcollimatorangle)
{
    m_pImp->set_endcollimatorangle(endcollimatorangle);
    enable_field(BEAMSEGMENT_ENDCOLLIMATORANGLE);
    setdirty_field(BEAMSEGMENT_ENDCOLLIMATORANGLE, true);
}

//arclength
double RtBeamsegment::get_arclength() const { return m_pImp->get_arclength();}
void RtBeamsegment::set_arclength(const double& arclength)
{
    m_pImp->set_arclength(arclength);
    enable_field(BEAMSEGMENT_ARCLENGTH);
    setdirty_field(BEAMSEGMENT_ARCLENGTH, true);
}

//endtablerotationangle
double RtBeamsegment::get_endtablerotationangle() const { return m_pImp->get_endtablerotationangle();}
void RtBeamsegment::set_endtablerotationangle(const double& endtablerotationangle)
{
    m_pImp->set_endtablerotationangle(endtablerotationangle);
    enable_field(BEAMSEGMENT_ENDTABLEROTATIONANGLE);
    setdirty_field(BEAMSEGMENT_ENDTABLEROTATIONANGLE, true);
}

//t_beam_to_pat
const float* RtBeamsegment::get_t_beam_to_pat() const { return m_pImp->get_t_beam_to_pat();}
void RtBeamsegment::set_t_beam_to_pat(const float* t_beam_to_pat) { m_pImp->set_t_beam_to_pat(t_beam_to_pat);}

//ispre
bool RtBeamsegment::get_ispre() const { return m_pImp->get_ispre();}
void RtBeamsegment::set_ispre(const bool& ispre)
{
    m_pImp->set_ispre(ispre);
    enable_field(BEAMSEGMENT_ISPRE);
    setdirty_field(BEAMSEGMENT_ISPRE, true);
}

//ispost
bool RtBeamsegment::get_ispost() const { return m_pImp->get_ispost();}
void RtBeamsegment::set_ispost(const bool& ispost)
{
    m_pImp->set_ispost(ispost);
    enable_field(BEAMSEGMENT_ISPOST);
    setdirty_field(BEAMSEGMENT_ISPOST, true);
}

//isduring
bool RtBeamsegment::get_isduring() const { return m_pImp->get_isduring();}
void RtBeamsegment::set_isduring(const bool& isduring)
{
    m_pImp->set_isduring(isduring);
    enable_field(BEAMSEGMENT_ISDURING);
    setdirty_field(BEAMSEGMENT_ISDURING, true);
}

//isdouble
bool RtBeamsegment::get_isdouble() const { return m_pImp->get_isdouble();}
void RtBeamsegment::set_isdouble(const bool& isdouble)
{
    m_pImp->set_isdouble(isdouble);
    enable_field(BEAMSEGMENT_ISDOUBLE);
    setdirty_field(BEAMSEGMENT_ISDOUBLE, true);
}

//gantryrotationdirection
int RtBeamsegment::get_gantryrotationdirection() const { return m_pImp->get_gantryrotationdirection();}
void RtBeamsegment::set_gantryrotationdirection(const int& gantryrotationdirection)
{
    m_pImp->set_gantryrotationdirection(gantryrotationdirection);
    enable_field(BEAMSEGMENT_GANTRYROTATIONDIRECTION);
    setdirty_field(BEAMSEGMENT_GANTRYROTATIONDIRECTION, true);
}

//collimatorrotationdirection
int RtBeamsegment::get_collimatorrotationdirection() const { return m_pImp->get_collimatorrotationdirection();}
void RtBeamsegment::set_collimatorrotationdirection(const int& collimatorrotationdirection)
{
    m_pImp->set_collimatorrotationdirection(collimatorrotationdirection);
    enable_field(BEAMSEGMENT_COLLIMATORROTATIONDIRECTION);
    setdirty_field(BEAMSEGMENT_COLLIMATORROTATIONDIRECTION, true);
}

//startssd
float RtBeamsegment::get_startssd() const { return m_pImp->get_startssd();}
void RtBeamsegment::set_startssd(const float& startssd)
{
    m_pImp->set_startssd(startssd);
    enable_field(BEAMSEGMENT_STARTSSD);
    setdirty_field(BEAMSEGMENT_STARTSSD, true);
}

//endssd
float RtBeamsegment::get_endssd() const { return m_pImp->get_endssd();}
void RtBeamsegment::set_endssd(const float& endssd)
{
    m_pImp->set_endssd(endssd);
    enable_field(BEAMSEGMENT_ENDSSD);
    setdirty_field(BEAMSEGMENT_ENDSSD, true);
}

//updatetime
DATETIME_BOOST RtBeamsegment::get_updatetime() const { return m_pImp->get_updatetime();}
void RtBeamsegment::set_updatetime(const DATETIME_BOOST& updatetime)
{
    m_pImp->set_updatetime(updatetime);
    enable_field(BEAMSEGMENT_UPDATETIME);
    setdirty_field(BEAMSEGMENT_UPDATETIME, true);
}
//////////////////////////////////////////////////////////////////////////
//if null then create one. Should NOT delete the pointer outside!
RtContour* RtBeamsegment::get_beamoutline() { return m_pImp->get_beamoutline(); }

//must have. Should NOT delete the pointer outside!
RtMlcshape* RtBeamsegment::get_startmlcshape(){ return m_pImp->get_startmlcshape(); }
RtMlcshape* RtBeamsegment::get_startmlcshape() const { return m_pImp->get_startmlcshape(); }

//must have. Should NOT delete the pointer outside!
RtMlcshape* RtBeamsegment::get_endmlcshape() { return m_pImp->get_endmlcshape(); }
RtMlcshape* RtBeamsegment::get_endmlcshape() const { return m_pImp->get_endmlcshape(); }

RT_TPS_DATABASE_END_NAMESPACE