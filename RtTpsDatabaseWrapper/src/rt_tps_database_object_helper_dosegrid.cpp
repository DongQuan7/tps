//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_dosegrid.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.11
///
///  \version 1.0
///  \date    8/8/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_dosegrid.h"
#include "boost/algorithm/string/split.hpp"
#include "boost/algorithm/string/classification.hpp"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtDosegrid& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //26 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < DOSEGRID_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_DOSEGRID_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmsdosegrid SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < DOSEGRID_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_DOSEGRID_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmsdosegrid (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_planuid = "";
    std::string	data_normgroupuid = "";
    std::string	data_beamuid = "";
    float		data_xcoordinate3dstart = 0.f;
    float		data_ycoordinate3dstart = 0.f;
    float		data_zcoordinate3dstart = 0.f;
    float		data_xcoordinate3dinc = 0.f;
    float		data_ycoordinate3dinc = 0.f;
    float		data_zcoordinate3dinc = 0.f;
    int			data_xcount = 0;
    int			data_ycount = 0;
    int			data_zcount = 0;
    float		data_max = 0.f;
    float		data_min = 0.f;
    double		data_accuracy = 0.;
    std::string	data_dosegridfilepath = "";
    int			data_doseunit = 0;
    int			data_dosesummationtype = 0;
    int			data_bitsallocated = 0;
    int			data_bitsstored = 0;
    int			data_highbits = 0;
    std::string	data_sopinstanceuid = "";
    std::string	data_grid_to_pat_t = "";
    bool		data_isdosevalid = false;
    MYSQL_TIME	data_updatetime;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < DOSEGRID_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//planuid varchar
            {
                data_planuid = src.get_planuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_planuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_planuid.size();
            }
            break;
        case 2: 	//normgroupuid varchar
            {
                data_normgroupuid = src.get_normgroupuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_normgroupuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_normgroupuid.size();
            }
            break;
        case 3: 	//beamuid varchar
            {
                data_beamuid = src.get_beamuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_beamuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_beamuid.size();
            }
            break;
        case 4: 	//xcoordinate3dstart float
            {
                data_xcoordinate3dstart = src.get_xcoordinate3dstart();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xcoordinate3dstart;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 5: 	//ycoordinate3dstart float
            {
                data_ycoordinate3dstart = src.get_ycoordinate3dstart();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ycoordinate3dstart;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 6: 	//zcoordinate3dstart float
            {
                data_zcoordinate3dstart = src.get_zcoordinate3dstart();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_zcoordinate3dstart;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 7: 	//xcoordinate3dinc float
            {
                data_xcoordinate3dinc = src.get_xcoordinate3dinc();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_xcoordinate3dinc;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 8: 	//ycoordinate3dinc float
            {
                data_ycoordinate3dinc = src.get_ycoordinate3dinc();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_ycoordinate3dinc;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 9: 	//zcoordinate3dinc float
            {
                data_zcoordinate3dinc = src.get_zcoordinate3dinc();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_zcoordinate3dinc;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 10: 	//xcount int
            {
                data_xcount = src.get_xcount();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_xcount;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 11: 	//ycount int
            {
                data_ycount = src.get_ycount();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_ycount;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 12: 	//zcount int
            {
                data_zcount = src.get_zcount();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_zcount;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 13: 	//max float
            {
                data_max = src.get_max();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_max;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 14: 	//min float
            {
                data_min = src.get_min();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_min;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 15: 	//accuracy double
            {
                data_accuracy = src.get_accuracy();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_accuracy;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 16: 	//dosegridfilepath varchar
            {
                data_dosegridfilepath = src.get_dosegridfilepath();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_dosegridfilepath.c_str();
                bind[iCount].buffer_length = (unsigned long)data_dosegridfilepath.size();
            }
            break;
        case 17: 	//doseunit int
            {
                data_doseunit = src.get_doseunit();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_doseunit;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 18: 	//dosesummationtype int
            {
                data_dosesummationtype = src.get_dosesummationtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_dosesummationtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 19: 	//bitsallocated int
            {
                data_bitsallocated = src.get_bitsallocated();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_bitsallocated;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 20: 	//bitsstored int
            {
                data_bitsstored = src.get_bitsstored();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_bitsstored;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 21: 	//highbits int
            {
                data_highbits = src.get_highbits();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_highbits;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 22: 	//sopinstanceuid varchar
            {
                data_sopinstanceuid = src.get_sopinstanceuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_sopinstanceuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_sopinstanceuid.size();
            }
            break;
        case 23: 	//grid_to_pat_t varchar
            {
                const float* matrix = src.get_grid_to_pat_t(); 
                if (nullptr != matrix){
                    for (int j(0); j<4; ++j){
                        for (int i(0); i<4; ++i){
                            data_grid_to_pat_t += std::to_string(long double(matrix[i + j*4])) + ((3==j && 3==i)? "":",");
                        }
                    }
                }
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_grid_to_pat_t.c_str();
                bind[iCount].buffer_length = (unsigned long)data_grid_to_pat_t.size();
            }
            break;
        case 24: 	//isdosevalid tinyint
            {
                data_isdosevalid = src.get_isdosevalid();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isdosevalid;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 25: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
	DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtDosegrid*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtDosegrid*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsdosegrid    26 parameters
    const int field_num = DOSEGRID_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 64;
    MAX_LENGTH[3] = 64;
    MAX_LENGTH[4] = 0;
    MAX_LENGTH[5] = 0;
    MAX_LENGTH[6] = 0;
    MAX_LENGTH[7] = 0;
    MAX_LENGTH[8] = 0;
    MAX_LENGTH[9] = 0;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 0;
    MAX_LENGTH[12] = 0;
    MAX_LENGTH[13] = 0;
    MAX_LENGTH[14] = 0;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 1024;
    MAX_LENGTH[17] = 0;
    MAX_LENGTH[18] = 0;
    MAX_LENGTH[19] = 0;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 64;
    MAX_LENGTH[23] = 2048;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;

    //std::string	data_uid
    //std::string	data_planuid
    //std::string	data_normgroupuid
    //std::string	data_beamuid
    float	data_xcoordinate3dstart = 0.f;
    float	data_ycoordinate3dstart = 0.f;
    float	data_zcoordinate3dstart = 0.f;
    float	data_xcoordinate3dinc = 0.f;
    float	data_ycoordinate3dinc = 0.f;
    float	data_zcoordinate3dinc = 0.f;
    int	data_xcount = 0;
    int	data_ycount = 0;
    int	data_zcount = 0;
    float	data_max = 0.f;
    float	data_min = 0.f;
    double	data_accuracy = 0.;
    //std::string	data_dosegridfilepath
    int	data_doseunit = 0;
    int	data_dosesummationtype = 0;
    int	data_bitsallocated = 0;
    int	data_bitsstored = 0;
    int	data_highbits = 0;
    //std::string	data_sopinstanceuid
    //std::string	data_grid_to_pat_t
    bool	data_isdosevalid = false;
    MYSQL_TIME	data_updatetime;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 4: 	//xcoordinate3dstart float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xcoordinate3dstart;
            break;
        case 5: 	//ycoordinate3dstart float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ycoordinate3dstart;
            break;
        case 6: 	//zcoordinate3dstart float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_zcoordinate3dstart;
            break;
        case 7: 	//xcoordinate3dinc float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_xcoordinate3dinc;
            break;
        case 8: 	//ycoordinate3dinc float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_ycoordinate3dinc;
            break;
        case 9: 	//zcoordinate3dinc float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_zcoordinate3dinc;
            break;
        case 10: 	//xcount int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_xcount;
            break;
        case 11: 	//ycount int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_ycount;
            break;
        case 12: 	//zcount int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_zcount;
            break;
        case 13: 	//max float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_max;
            break;
        case 14: 	//min float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_min;
            break;
        case 15: 	//accuracy double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_accuracy;
            break;
        case 17: 	//doseunit int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_doseunit;
            break;
        case 18: 	//dosesummationtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_dosesummationtype;
            break;
        case 19: 	//bitsallocated int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_bitsallocated;
            break;
        case 20: 	//bitsstored int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_bitsstored;
            break;
        case 21: 	//highbits int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_highbits;
            break;
        case 24: 	//isdosevalid tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isdosevalid;
            break;
        case 25: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtDosegrid* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtDosegrid();
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//planuid varchar
                pDis->set_planuid((char *)bind[i].buffer);
                break;
            case 2: 	//normgroupuid varchar
                pDis->set_normgroupuid((char *)bind[i].buffer);
                break;
            case 3: 	//beamuid varchar
                pDis->set_beamuid((char *)bind[i].buffer);
                break;
            case 4: 	//xcoordinate3dstart float
                pDis->set_xcoordinate3dstart(data_xcoordinate3dstart);
                break;
            case 5: 	//ycoordinate3dstart float
                pDis->set_ycoordinate3dstart(data_ycoordinate3dstart);
                break;
            case 6: 	//zcoordinate3dstart float
                pDis->set_zcoordinate3dstart(data_zcoordinate3dstart);
                break;
            case 7: 	//xcoordinate3dinc float
                pDis->set_xcoordinate3dinc(data_xcoordinate3dinc);
                break;
            case 8: 	//ycoordinate3dinc float
                pDis->set_ycoordinate3dinc(data_ycoordinate3dinc);
                break;
            case 9: 	//zcoordinate3dinc float
                pDis->set_zcoordinate3dinc(data_zcoordinate3dinc);
                break;
            case 10: 	//xcount int
                pDis->set_xcount(data_xcount);
                break;
            case 11: 	//ycount int
                pDis->set_ycount(data_ycount);
                break;
            case 12: 	//zcount int
                pDis->set_zcount(data_zcount);
                break;
            case 13: 	//max float
                pDis->set_max(data_max);
                break;
            case 14: 	//min float
                pDis->set_min(data_min);
                break;
            case 15: 	//accuracy double
                pDis->set_accuracy(data_accuracy);
                break;
            case 16: 	//dosegridfilepath varchar
                pDis->set_dosegridfilepath((char *)bind[i].buffer);
                break;
            case 17: 	//doseunit int
                pDis->set_doseunit(data_doseunit);
                break;
            case 18: 	//dosesummationtype int
                pDis->set_dosesummationtype(data_dosesummationtype);
                break;
            case 19: 	//bitsallocated int
                pDis->set_bitsallocated(data_bitsallocated);
                break;
            case 20: 	//bitsstored int
                pDis->set_bitsstored(data_bitsstored);
                break;
            case 21: 	//highbits int
                pDis->set_highbits(data_highbits);
                break;
            case 22: 	//sopinstanceuid varchar
                pDis->set_sopinstanceuid((char *)bind[i].buffer);
                break;
            case 23: 	//grid_to_pat_t varchar
                {
                    std::vector<std::string> subValue;
                    std::string value_matrix = std::string((char *)bind[i].buffer);
                    (void)boost::split(subValue, value_matrix, boost::is_any_of(","));
                    if (subValue.size()!=16) {
                        break;
                    }
                    float matrix[16];
                    for (int j(0); j<4; ++j){
                        for (int i(0); i<4; ++i){
                            matrix[i + j*4] = subValue[i + j*4].empty()? 0.0f : (float)atof(subValue[i + j*4].c_str());
                        }
                    }
                    pDis->set_grid_to_pat_t(matrix);
                }
                break;
            case 24: 	//isdosevalid tinyint
                pDis->set_isdosevalid(data_isdosevalid);
                break;
            case 25: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE