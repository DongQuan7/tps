//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_site.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.11
///
///  \version 1.0
///  \date    8/8/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_site.h"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtSite& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //48 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < SITE_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_SITE_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmssite SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < SITE_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_SITE_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmssite (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_sitetemplateuid = "";
    std::string	data_courseuid = "";
    std::string	data_name = "";
    int			data_diagnosistype = 0;
    std::string	data_stage = "";
    std::string	data_stagedetail = "";
    int			data_scanareatype = 0;
    float		data_tumorlength = 0.f;
    float		data_tumorwidth = 0.f;
    float		data_tumorheight = 0.f;
    float		data_tumorvolume = 0.f;
    int			data_marker = 0;
    std::string	data_simoperatoruid = "";
    std::string	data_simulationnotes = "";
    int			data_patientpositiontype = 0;
    int			data_armspositiontype = 0;
    std::string	data_legs = "";
    std::string	data_other = "";
    std::string	data_comments = "";
    bool		data_needcreatebeam = false;
    bool		data_needcreatvoi = false;
    bool		data_needgating = false;
    int			data_planningimagingtype = 0;
    bool		data_needplanningimagemrit2 = false;
    bool		data_needplanningimagemrit1 = false;
    bool		data_needplanningimagemridwi = false;
    bool		data_needplanningimagemriother = false;
    bool		data_needplanningimagemripi = false;
    int			data_planningimageoption = 0;
    bool		data_needsecondaryct = false;
    int			data_secondaryctoption = 0;
    bool		data_needsecondary4dct = false;
    bool		data_needsim = false;
    bool		data_needsecondarymr = false;
    int			data_secondarymroption = 0;
    bool		data_needsecondarypetct = false;
    int			data_secondarypetctoption = 0;
    std::string	data_immobilization = "";
    bool		data_isdefault = false;
    std::string	data_setupphotouid = "";
    std::string	data_surfacerenderingphotouid = "";
    std::string	data_otherplanningimagemri = "";
    double		data_startposition = 0.;
    double		data_percent = 0.;
    int			data_scanpicturetype = 0;
    std::string	data_crc = "";
    MYSQL_TIME	data_updatetime;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < SITE_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//sitetemplateuid varchar
            {
                data_sitetemplateuid = src.get_sitetemplateuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_sitetemplateuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_sitetemplateuid.size();
            }
            break;
        case 2: 	//courseuid varchar
            {
                data_courseuid = src.get_courseuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_courseuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_courseuid.size();
            }
            break;
        case 3: 	//name varchar
            {
                data_name = src.get_name();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_name.c_str();
                bind[iCount].buffer_length = (unsigned long)data_name.size();
            }
            break;
        case 4: 	//diagnosistype int
            {
                data_diagnosistype = src.get_diagnosistype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_diagnosistype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 5: 	//stage varchar
            {
                data_stage = src.get_stage();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_stage.c_str();
                bind[iCount].buffer_length = (unsigned long)data_stage.size();
            }
            break;
        case 6: 	//stagedetail varchar
            {
                data_stagedetail = src.get_stagedetail();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_stagedetail.c_str();
                bind[iCount].buffer_length = (unsigned long)data_stagedetail.size();
            }
            break;
        case 7: 	//scanareatype int
            {
                data_scanareatype = src.get_scanareatype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_scanareatype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 8: 	//tumorlength float
            {
                data_tumorlength = src.get_tumorlength();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_tumorlength;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 9: 	//tumorwidth float
            {
                data_tumorwidth = src.get_tumorwidth();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_tumorwidth;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 10: 	//tumorheight float
            {
                data_tumorheight = src.get_tumorheight();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_tumorheight;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 11: 	//tumorvolume float
            {
                data_tumorvolume = src.get_tumorvolume();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_tumorvolume;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 12: 	//marker int
            {
                data_marker = src.get_marker();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_marker;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 13: 	//simoperatoruid varchar
            {
                data_simoperatoruid = src.get_simoperatoruid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_simoperatoruid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_simoperatoruid.size();
            }
            break;
        case 14: 	//simulationnotes varchar
            {
                data_simulationnotes = src.get_simulationnotes();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_simulationnotes.c_str();
                bind[iCount].buffer_length = (unsigned long)data_simulationnotes.size();
            }
            break;
        case 15: 	//patientpositiontype int
            {
                data_patientpositiontype = src.get_patientpositiontype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_patientpositiontype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 16: 	//armspositiontype int
            {
                data_armspositiontype = src.get_armspositiontype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_armspositiontype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 17: 	//legs varchar
            {
                data_legs = src.get_legs();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_legs.c_str();
                bind[iCount].buffer_length = (unsigned long)data_legs.size();
            }
            break;
        case 18: 	//other varchar
            {
                data_other = src.get_other();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_other.c_str();
                bind[iCount].buffer_length = (unsigned long)data_other.size();
            }
            break;
        case 19: 	//comments varchar
            {
                data_comments = src.get_comments();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_comments.c_str();
                bind[iCount].buffer_length = (unsigned long)data_comments.size();
            }
            break;
        case 20: 	//needcreatebeam tinyint
            {
                data_needcreatebeam = src.get_needcreatebeam();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needcreatebeam;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 21: 	//needcreatvoi tinyint
            {
                data_needcreatvoi = src.get_needcreatvoi();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needcreatvoi;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 22: 	//needgating tinyint
            {
                data_needgating = src.get_needgating();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needgating;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 23: 	//planningimagingtype int
            {
                data_planningimagingtype = src.get_planningimagingtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_planningimagingtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 24: 	//needplanningimagemrit2 tinyint
            {
                data_needplanningimagemrit2 = src.get_needplanningimagemrit2();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needplanningimagemrit2;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 25: 	//needplanningimagemrit1 tinyint
            {
                data_needplanningimagemrit1 = src.get_needplanningimagemrit1();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needplanningimagemrit1;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 26: 	//needplanningimagemridwi tinyint
            {
                data_needplanningimagemridwi = src.get_needplanningimagemridwi();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needplanningimagemridwi;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 27: 	//needplanningimagemriother tinyint
            {
                data_needplanningimagemriother = src.get_needplanningimagemriother();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needplanningimagemriother;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 28: 	//needplanningimagemripi tinyint
            {
                data_needplanningimagemripi = src.get_needplanningimagemripi();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needplanningimagemripi;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 29: 	//planningimageoption int
            {
                data_planningimageoption = src.get_planningimageoption();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_planningimageoption;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 30: 	//needsecondaryct tinyint
            {
                data_needsecondaryct = src.get_needsecondaryct();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needsecondaryct;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 31: 	//secondaryctoption int
            {
                data_secondaryctoption = src.get_secondaryctoption();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_secondaryctoption;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 32: 	//needsecondary4dct tinyint
            {
                data_needsecondary4dct = src.get_needsecondary4dct();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needsecondary4dct;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 33: 	//needsim tinyint
            {
                data_needsim = src.get_needsim();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needsim;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 34: 	//needsecondarymr tinyint
            {
                data_needsecondarymr = src.get_needsecondarymr();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needsecondarymr;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 35: 	//secondarymroption int
            {
                data_secondarymroption = src.get_secondarymroption();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_secondarymroption;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 36: 	//needsecondarypetct tinyint
            {
                data_needsecondarypetct = src.get_needsecondarypetct();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_needsecondarypetct;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 37: 	//secondarypetctoption int
            {
                data_secondarypetctoption = src.get_secondarypetctoption();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_secondarypetctoption;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 38: 	//immobilization varchar
            {
                data_immobilization = src.get_immobilization();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_immobilization.c_str();
                bind[iCount].buffer_length = (unsigned long)data_immobilization.size();
            }
            break;
        case 39: 	//isdefault tinyint
            {
                data_isdefault = src.get_isdefault();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isdefault;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 40: 	//setupphotouid varchar
            {
                data_setupphotouid = src.get_setupphotouid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_setupphotouid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_setupphotouid.size();
            }
            break;
        case 41: 	//surfacerenderingphotouid varchar
            {
                data_surfacerenderingphotouid = src.get_surfacerenderingphotouid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_surfacerenderingphotouid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_surfacerenderingphotouid.size();
            }
            break;
        case 42: 	//otherplanningimagemri varchar
            {
                data_otherplanningimagemri = src.get_otherplanningimagemri();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_otherplanningimagemri.c_str();
                bind[iCount].buffer_length = (unsigned long)data_otherplanningimagemri.size();
            }
            break;
        case 43: 	//startposition double
            {
                data_startposition = src.get_startposition();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_startposition;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 44: 	//percent double
            {
                data_percent = src.get_percent();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_percent;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 45: 	//scanpicturetype int
            {
                data_scanpicturetype = src.get_scanpicturetype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_scanpicturetype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 46: 	//crc varchar
            {
                data_crc = src.get_crc();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_crc.c_str();
                bind[iCount].buffer_length = (unsigned long)data_crc.size();
            }
            break;
        case 47: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
	DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtSite*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtSite*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmssite    48 parameters
    const int field_num = SITE_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 64;
    MAX_LENGTH[3] = 64;
    MAX_LENGTH[4] = 0;
    MAX_LENGTH[5] = 1024;
    MAX_LENGTH[6] = 1024;
    MAX_LENGTH[7] = 0;
    MAX_LENGTH[8] = 0;
    MAX_LENGTH[9] = 0;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 0;
    MAX_LENGTH[12] = 0;
    MAX_LENGTH[13] = 64;
    MAX_LENGTH[14] = 256;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 0;
    MAX_LENGTH[17] = 1024;
    MAX_LENGTH[18] = 1024;
    MAX_LENGTH[19] = 1024;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 0;
    MAX_LENGTH[23] = 0;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;
    MAX_LENGTH[26] = 0;
    MAX_LENGTH[27] = 0;
    MAX_LENGTH[28] = 0;
    MAX_LENGTH[29] = 0;
    MAX_LENGTH[30] = 0;
    MAX_LENGTH[31] = 0;
    MAX_LENGTH[32] = 0;
    MAX_LENGTH[33] = 0;
    MAX_LENGTH[34] = 0;
    MAX_LENGTH[35] = 0;
    MAX_LENGTH[36] = 0;
    MAX_LENGTH[37] = 0;
    MAX_LENGTH[38] = 8196;
    MAX_LENGTH[39] = 0;
    MAX_LENGTH[40] = 64;
    MAX_LENGTH[41] = 64;
    MAX_LENGTH[42] = 1024;
    MAX_LENGTH[43] = 0;
    MAX_LENGTH[44] = 0;
    MAX_LENGTH[45] = 0;
    MAX_LENGTH[46] = 64;
    MAX_LENGTH[47] = 0;

    //std::string	data_uid
    //std::string	data_sitetemplateuid
    //std::string	data_courseuid
    //std::string	data_name
    int	data_diagnosistype = 0;
    //std::string	data_stage
    //std::string	data_stagedetail
    int	data_scanareatype = 0;
    float	data_tumorlength = 0.f;
    float	data_tumorwidth = 0.f;
    float	data_tumorheight = 0.f;
    float	data_tumorvolume = 0.f;
    int	data_marker = 0;
    //std::string	data_simoperatoruid
    //std::string	data_simulationnotes
    int	data_patientpositiontype = 0;
    int	data_armspositiontype = 0;
    //std::string	data_legs
    //std::string	data_other
    //std::string	data_comments
    bool	data_needcreatebeam = false;
    bool	data_needcreatvoi = false;
    bool	data_needgating = false;
    int	data_planningimagingtype = 0;
    bool	data_needplanningimagemrit2 = false;
    bool	data_needplanningimagemrit1 = false;
    bool	data_needplanningimagemridwi = false;
    bool	data_needplanningimagemriother = false;
    bool	data_needplanningimagemripi = false;
    int	data_planningimageoption = 0;
    bool	data_needsecondaryct = false;
    int	data_secondaryctoption = 0;
    bool	data_needsecondary4dct = false;
    bool	data_needsim = false;
    bool	data_needsecondarymr = false;
    int	data_secondarymroption = 0;
    bool	data_needsecondarypetct = false;
    int	data_secondarypetctoption = 0;
    //std::string	data_immobilization
    bool	data_isdefault = false;
    //std::string	data_setupphotouid
    //std::string	data_surfacerenderingphotouid
    //std::string	data_otherplanningimagemri
    double	data_startposition = 0.;
    double	data_percent = 0.;
    int	data_scanpicturetype = 0;
    //std::string	data_crc
    MYSQL_TIME	data_updatetime;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 4: 	//diagnosistype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_diagnosistype;
            break;
        case 7: 	//scanareatype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_scanareatype;
            break;
        case 8: 	//tumorlength float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_tumorlength;
            break;
        case 9: 	//tumorwidth float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_tumorwidth;
            break;
        case 10: 	//tumorheight float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_tumorheight;
            break;
        case 11: 	//tumorvolume float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_tumorvolume;
            break;
        case 12: 	//marker int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_marker;
            break;
        case 15: 	//patientpositiontype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_patientpositiontype;
            break;
        case 16: 	//armspositiontype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_armspositiontype;
            break;
        case 20: 	//needcreatebeam tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needcreatebeam;
            break;
        case 21: 	//needcreatvoi tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needcreatvoi;
            break;
        case 22: 	//needgating tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needgating;
            break;
        case 23: 	//planningimagingtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_planningimagingtype;
            break;
        case 24: 	//needplanningimagemrit2 tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needplanningimagemrit2;
            break;
        case 25: 	//needplanningimagemrit1 tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needplanningimagemrit1;
            break;
        case 26: 	//needplanningimagemridwi tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needplanningimagemridwi;
            break;
        case 27: 	//needplanningimagemriother tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needplanningimagemriother;
            break;
        case 28: 	//needplanningimagemripi tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needplanningimagemripi;
            break;
        case 29: 	//planningimageoption int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_planningimageoption;
            break;
        case 30: 	//needsecondaryct tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needsecondaryct;
            break;
        case 31: 	//secondaryctoption int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_secondaryctoption;
            break;
        case 32: 	//needsecondary4dct tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needsecondary4dct;
            break;
        case 33: 	//needsim tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needsim;
            break;
        case 34: 	//needsecondarymr tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needsecondarymr;
            break;
        case 35: 	//secondarymroption int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_secondarymroption;
            break;
        case 36: 	//needsecondarypetct tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_needsecondarypetct;
            break;
        case 37: 	//secondarypetctoption int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_secondarypetctoption;
            break;
        case 39: 	//isdefault tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isdefault;
            break;
        case 43: 	//startposition double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_startposition;
            break;
        case 44: 	//percent double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_percent;
            break;
        case 45: 	//scanpicturetype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_scanpicturetype;
            break;
        case 47: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtSite* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtSite();
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//sitetemplateuid varchar
                pDis->set_sitetemplateuid((char *)bind[i].buffer);
                break;
            case 2: 	//courseuid varchar
                pDis->set_courseuid((char *)bind[i].buffer);
                break;
            case 3: 	//name varchar
                pDis->set_name((char *)bind[i].buffer);
                break;
            case 4: 	//diagnosistype int
                pDis->set_diagnosistype(data_diagnosistype);
                break;
            case 5: 	//stage varchar
                pDis->set_stage((char *)bind[i].buffer);
                break;
            case 6: 	//stagedetail varchar
                pDis->set_stagedetail((char *)bind[i].buffer);
                break;
            case 7: 	//scanareatype int
                pDis->set_scanareatype(data_scanareatype);
                break;
            case 8: 	//tumorlength float
                pDis->set_tumorlength(data_tumorlength);
                break;
            case 9: 	//tumorwidth float
                pDis->set_tumorwidth(data_tumorwidth);
                break;
            case 10: 	//tumorheight float
                pDis->set_tumorheight(data_tumorheight);
                break;
            case 11: 	//tumorvolume float
                pDis->set_tumorvolume(data_tumorvolume);
                break;
            case 12: 	//marker int
                pDis->set_marker(data_marker);
                break;
            case 13: 	//simoperatoruid varchar
                pDis->set_simoperatoruid((char *)bind[i].buffer);
                break;
            case 14: 	//simulationnotes varchar
                pDis->set_simulationnotes((char *)bind[i].buffer);
                break;
            case 15: 	//patientpositiontype int
                pDis->set_patientpositiontype(data_patientpositiontype);
                break;
            case 16: 	//armspositiontype int
                pDis->set_armspositiontype(data_armspositiontype);
                break;
            case 17: 	//legs varchar
                pDis->set_legs((char *)bind[i].buffer);
                break;
            case 18: 	//other varchar
                pDis->set_other((char *)bind[i].buffer);
                break;
            case 19: 	//comments varchar
                pDis->set_comments((char *)bind[i].buffer);
                break;
            case 20: 	//needcreatebeam tinyint
                pDis->set_needcreatebeam(data_needcreatebeam);
                break;
            case 21: 	//needcreatvoi tinyint
                pDis->set_needcreatvoi(data_needcreatvoi);
                break;
            case 22: 	//needgating tinyint
                pDis->set_needgating(data_needgating);
                break;
            case 23: 	//planningimagingtype int
                pDis->set_planningimagingtype(data_planningimagingtype);
                break;
            case 24: 	//needplanningimagemrit2 tinyint
                pDis->set_needplanningimagemrit2(data_needplanningimagemrit2);
                break;
            case 25: 	//needplanningimagemrit1 tinyint
                pDis->set_needplanningimagemrit1(data_needplanningimagemrit1);
                break;
            case 26: 	//needplanningimagemridwi tinyint
                pDis->set_needplanningimagemridwi(data_needplanningimagemridwi);
                break;
            case 27: 	//needplanningimagemriother tinyint
                pDis->set_needplanningimagemriother(data_needplanningimagemriother);
                break;
            case 28: 	//needplanningimagemripi tinyint
                pDis->set_needplanningimagemripi(data_needplanningimagemripi);
                break;
            case 29: 	//planningimageoption int
                pDis->set_planningimageoption(data_planningimageoption);
                break;
            case 30: 	//needsecondaryct tinyint
                pDis->set_needsecondaryct(data_needsecondaryct);
                break;
            case 31: 	//secondaryctoption int
                pDis->set_secondaryctoption(data_secondaryctoption);
                break;
            case 32: 	//needsecondary4dct tinyint
                pDis->set_needsecondary4dct(data_needsecondary4dct);
                break;
            case 33: 	//needsim tinyint
                pDis->set_needsim(data_needsim);
                break;
            case 34: 	//needsecondarymr tinyint
                pDis->set_needsecondarymr(data_needsecondarymr);
                break;
            case 35: 	//secondarymroption int
                pDis->set_secondarymroption(data_secondarymroption);
                break;
            case 36: 	//needsecondarypetct tinyint
                pDis->set_needsecondarypetct(data_needsecondarypetct);
                break;
            case 37: 	//secondarypetctoption int
                pDis->set_secondarypetctoption(data_secondarypetctoption);
                break;
            case 38: 	//immobilization varchar
                pDis->set_immobilization((char *)bind[i].buffer);
                break;
            case 39: 	//isdefault tinyint
                pDis->set_isdefault(data_isdefault);
                break;
            case 40: 	//setupphotouid varchar
                pDis->set_setupphotouid((char *)bind[i].buffer);
                break;
            case 41: 	//surfacerenderingphotouid varchar
                pDis->set_surfacerenderingphotouid((char *)bind[i].buffer);
                break;
            case 42: 	//otherplanningimagemri varchar
                pDis->set_otherplanningimagemri((char *)bind[i].buffer);
                break;
            case 43: 	//startposition double
                pDis->set_startposition(data_startposition);
                break;
            case 44: 	//percent double
                pDis->set_percent(data_percent);
                break;
            case 45: 	//scanpicturetype int
                pDis->set_scanpicturetype(data_scanpicturetype);
                break;
            case 46: 	//crc varchar
                pDis->set_crc((char *)bind[i].buffer);
                break;
            case 47: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE