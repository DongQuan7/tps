//////////////////////////////////////////////////////////////////////////
/// \defgroup Radio Therapy Business Unit
///  Copyright, (c) Shanghai United Imaging Healthcare Inc., 2016
///  All rights reserved.
///
///  \author  ZHOU qiangqiang  mailto:qiangqiang.zhou@united-imaging.com
///
///  \file      rt_tps_database_object_helper_deliverybeamgroup.cpp
///  \brief     This file was generated by CodeGenerater.exe 
///             From database version: 1.1.11
///
///  \version 1.0
///  \date    8/8/2017
///  \{
//////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include "rt_tps_database_object_helper.h"
#include "RtTpsDatabaseWrapper/rt_tps_database_interface_object_deliverybeamgroup.h"
#include "boost/date_time/posix_time/time_parsers.hpp"
typedef boost::posix_time::ptime DATETIME_BOOST;
typedef boost::posix_time::time_duration TIME_BOOST;
typedef boost::gregorian::date DATE_BOOST;

RT_TPS_DATABASE_BEGIN_NAMESPACE;

bool RtDatabaseHelper::InsertUpdateDBFromObject(const RtDeliverybeamgroup& src, bool bInsert)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }
    //48 parameters
    unsigned int field_num = 0;
    std::string sSql("");
    std::string sName("");
    if (!bInsert)
    {
        for (unsigned int i(0); i < DELIVERYBEAMGROUP_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_DELIVERYBEAMGROUP_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name) + "=?";
            }
            else
            {
                sName += "," + std::string(file_name) + "=?";
            }
            ++field_num;
        }
        sSql = "UPDATE tmsdeliverybeamgroup SET " + sName + " WHERE uid='" + src.get_uid() + "'";
    }
    else
    {
        std::string sValues("");
        for (unsigned int i(0); i < DELIVERYBEAMGROUP_FIELD_MAX; ++i)
        {
            if (!src.is_dirty(i)) continue;
            const char* file_name = ENUM2STRING_DELIVERYBEAMGROUP_FIELD[i];
            if (sName.empty())
            {
                sName += std::string(file_name);
                sValues += "?";
            }
            else
            {
                sName += "," + std::string(file_name);
                sValues += ",?";
            }
            ++field_num;
        }
        sSql = "INSERT INTO tmsdeliverybeamgroup (" + sName + ") VALUES (" + sValues + ")";
    }
    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)sSql.size()))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_prepare(), failed %s\n", mysql_stmt_error(stmt));
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[field_num];
    memset(bind, 0, sizeof(MYSQL_BIND)*field_num);
    my_bool     isnull = true;
    std::string	data_uid = "";
    std::string	data_setupuid = "";
    std::string	data_machineuid = "";
    std::string	data_voiuid = "";
    std::string	data_seriesuid = "";
    std::string	data_sopinstanceuid = "";
    std::string	data_prescriptionuid = "";
    std::string	data_normalpointpoiuid = "";
    std::string	data_referenceddeliverybeamgroupuid = "";
    std::string	data_relatednormgroupuid = "";
    int			data_plantype = 0;
    std::string	data_name = "";
    std::string	data_planlabel = "";
    MYSQL_TIME	data_plandate;
    MYSQL_TIME	data_plantime;
    int			data_fraction = 0;
    double		data_doseperfraction = 0.;
    bool		data_isclockwise = false;
    int			data_rtplangeometry = 0;
    MYSQL_TIME	data_startdate;
    bool		data_ismondayselected = false;
    bool		data_istuesdayselected = false;
    bool		data_iswednesdayselected = false;
    bool		data_isthursdayselected = false;
    bool		data_isfridayselected = false;
    bool		data_issaturdayselected = false;
    bool		data_issundayselected = false;
    bool		data_isincludeholiday = false;
    int			data_timesperday = 0;
    float		data_intervalhour = 0.f;
    int			data_rotationtype = 0;
    MYSQL_TIME	data_estimatedtime;
    bool		data_istotaltimeused = false;
    MYSQL_TIME	data_totaltime;
    int			data_sourcetype = 0;
    std::string	data_crc = "";
    bool		data_isgating = false;
    bool		data_inactive = false;
    bool		data_isintervaloptional = false;
    int			data_binmode = 0;
    double		data_beamonrangestart = 0.;
    double		data_beamonrangeend = 0.;
    std::string	data_description = "";
    std::string	data_activeinactivereason = "";
    int			data_radiationtype = 0;
    std::string	data_toleranceuid = "";
    bool		data_isqa = false;
    MYSQL_TIME	data_updatetime;

    unsigned int iCount = 0;
    for (unsigned int i(0); i < DELIVERYBEAMGROUP_FIELD_MAX; ++i)
    {
        if (!src.is_dirty(i)) continue;
        if(!src.has_field(i))
        {
            bind[iCount].is_null = &isnull;
            ++iCount;
            continue;
        }
        switch (i)
        {
        case 0: 	//uid varchar
            {
                data_uid = src.get_uid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_uid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_uid.size();
            }
            break;
        case 1: 	//setupuid varchar
            {
                data_setupuid = src.get_setupuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_setupuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_setupuid.size();
            }
            break;
        case 2: 	//machineuid varchar
            {
                data_machineuid = src.get_machineuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_machineuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_machineuid.size();
            }
            break;
        case 3: 	//voiuid varchar
            {
                data_voiuid = src.get_voiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_voiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_voiuid.size();
            }
            break;
        case 4: 	//seriesuid varchar
            {
                data_seriesuid = src.get_seriesuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_seriesuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_seriesuid.size();
            }
            break;
        case 5: 	//sopinstanceuid varchar
            {
                data_sopinstanceuid = src.get_sopinstanceuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_sopinstanceuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_sopinstanceuid.size();
            }
            break;
        case 6: 	//prescriptionuid varchar
            {
                data_prescriptionuid = src.get_prescriptionuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_prescriptionuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_prescriptionuid.size();
            }
            break;
        case 7: 	//normalpointpoiuid varchar
            {
                data_normalpointpoiuid = src.get_normalpointpoiuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_normalpointpoiuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_normalpointpoiuid.size();
            }
            break;
        case 8: 	//referenceddeliverybeamgroupuid varchar
            {
                data_referenceddeliverybeamgroupuid = src.get_referenceddeliverybeamgroupuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_referenceddeliverybeamgroupuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_referenceddeliverybeamgroupuid.size();
            }
            break;
        case 9: 	//relatednormgroupuid varchar
            {
                data_relatednormgroupuid = src.get_relatednormgroupuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_relatednormgroupuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_relatednormgroupuid.size();
            }
            break;
        case 10: 	//plantype int
            {
                data_plantype = src.get_plantype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_plantype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 11: 	//name varchar
            {
                data_name = src.get_name();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_name.c_str();
                bind[iCount].buffer_length = (unsigned long)data_name.size();
            }
            break;
        case 12: 	//planlabel varchar
            {
                data_planlabel = src.get_planlabel();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_planlabel.c_str();
                bind[iCount].buffer_length = (unsigned long)data_planlabel.size();
            }
            break;
        case 13: 	//plandate date
            {
                ConvertDateTime2DB(src.get_plandate(), &data_plandate);
                bind[iCount].buffer_type = MYSQL_TYPE_DATE;
                bind[iCount].buffer = (void*)&data_plandate;
                if (src.get_plandate().is_not_a_date()) bind[iCount].is_null = &isnull;
            }
            break;
        case 14: 	//plantime time
            {
                ConvertDateTime2DB(src.get_plantime(), &data_plantime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIME;
                bind[iCount].buffer = (void*)&data_plantime;
                if (src.get_plantime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 15: 	//fraction int
            {
                data_fraction = src.get_fraction();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_fraction;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 16: 	//doseperfraction double
            {
                data_doseperfraction = src.get_doseperfraction();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_doseperfraction;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 17: 	//isclockwise tinyint
            {
                data_isclockwise = src.get_isclockwise();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isclockwise;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 18: 	//rtplangeometry int
            {
                data_rtplangeometry = src.get_rtplangeometry();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_rtplangeometry;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 19: 	//startdate date
            {
                ConvertDateTime2DB(src.get_startdate(), &data_startdate);
                bind[iCount].buffer_type = MYSQL_TYPE_DATE;
                bind[iCount].buffer = (void*)&data_startdate;
                if (src.get_startdate().is_not_a_date()) bind[iCount].is_null = &isnull;
            }
            break;
        case 20: 	//ismondayselected tinyint
            {
                data_ismondayselected = src.get_ismondayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_ismondayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 21: 	//istuesdayselected tinyint
            {
                data_istuesdayselected = src.get_istuesdayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_istuesdayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 22: 	//iswednesdayselected tinyint
            {
                data_iswednesdayselected = src.get_iswednesdayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_iswednesdayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 23: 	//isthursdayselected tinyint
            {
                data_isthursdayselected = src.get_isthursdayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isthursdayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 24: 	//isfridayselected tinyint
            {
                data_isfridayselected = src.get_isfridayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isfridayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 25: 	//issaturdayselected tinyint
            {
                data_issaturdayselected = src.get_issaturdayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_issaturdayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 26: 	//issundayselected tinyint
            {
                data_issundayselected = src.get_issundayselected();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_issundayselected;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 27: 	//isincludeholiday tinyint
            {
                data_isincludeholiday = src.get_isincludeholiday();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isincludeholiday;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 28: 	//timesperday int
            {
                data_timesperday = src.get_timesperday();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_timesperday;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 29: 	//intervalhour float
            {
                data_intervalhour = src.get_intervalhour();
                bind[iCount].buffer_type = MYSQL_TYPE_FLOAT;
                bind[iCount].buffer = (void*)&data_intervalhour;
                bind[iCount].buffer_length = sizeof(float);
            }
            break;
        case 30: 	//rotationtype int
            {
                data_rotationtype = src.get_rotationtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_rotationtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 31: 	//estimatedtime time
            {
                ConvertDateTime2DB(src.get_estimatedtime(), &data_estimatedtime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIME;
                bind[iCount].buffer = (void*)&data_estimatedtime;
                if (src.get_estimatedtime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 32: 	//istotaltimeused tinyint
            {
                data_istotaltimeused = src.get_istotaltimeused();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_istotaltimeused;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 33: 	//totaltime time
            {
                ConvertDateTime2DB(src.get_totaltime(), &data_totaltime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIME;
                bind[iCount].buffer = (void*)&data_totaltime;
                if (src.get_totaltime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        case 34: 	//sourcetype int
            {
                data_sourcetype = src.get_sourcetype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_sourcetype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 35: 	//crc varchar
            {
                data_crc = src.get_crc();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_crc.c_str();
                bind[iCount].buffer_length = (unsigned long)data_crc.size();
            }
            break;
        case 36: 	//isgating tinyint
            {
                data_isgating = src.get_isgating();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isgating;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 37: 	//inactive tinyint
            {
                data_inactive = src.get_inactive();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_inactive;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 38: 	//isintervaloptional tinyint
            {
                data_isintervaloptional = src.get_isintervaloptional();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isintervaloptional;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 39: 	//binmode int
            {
                data_binmode = src.get_binmode();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_binmode;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 40: 	//beamonrangestart double
            {
                data_beamonrangestart = src.get_beamonrangestart();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_beamonrangestart;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 41: 	//beamonrangeend double
            {
                data_beamonrangeend = src.get_beamonrangeend();
                bind[iCount].buffer_type = MYSQL_TYPE_DOUBLE;
                bind[iCount].buffer = (void*)&data_beamonrangeend;
                bind[iCount].buffer_length = sizeof(double);
            }
            break;
        case 42: 	//description varchar
            {
                data_description = src.get_description();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_description.c_str();
                bind[iCount].buffer_length = (unsigned long)data_description.size();
            }
            break;
        case 43: 	//activeinactivereason varchar
            {
                data_activeinactivereason = src.get_activeinactivereason();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_activeinactivereason.c_str();
                bind[iCount].buffer_length = (unsigned long)data_activeinactivereason.size();
            }
            break;
        case 44: 	//radiationtype int
            {
                data_radiationtype = src.get_radiationtype();
                bind[iCount].buffer_type = MYSQL_TYPE_LONG;
                bind[iCount].buffer = (void*)&data_radiationtype;
                bind[iCount].buffer_length = sizeof(int);
            }
            break;
        case 45: 	//toleranceuid varchar
            {
                data_toleranceuid = src.get_toleranceuid();
                bind[iCount].buffer_type = MYSQL_TYPE_VAR_STRING;
                bind[iCount].buffer = (void*)data_toleranceuid.c_str();
                bind[iCount].buffer_length = (unsigned long)data_toleranceuid.size();
            }
            break;
        case 46: 	//isqa tinyint
            {
                data_isqa = src.get_isqa();
                bind[iCount].buffer_type = MYSQL_TYPE_TINY;
                bind[iCount].buffer = (void*)&data_isqa;
                bind[iCount].buffer_length = sizeof(bool);
            }
            break;
        case 47: 	//updatetime timestamp
            {
                ConvertDateTime2DB(src.get_updatetime(), &data_updatetime);
                bind[iCount].buffer_type = MYSQL_TYPE_TIMESTAMP;
                bind[iCount].buffer = (void*)&data_updatetime;
                if (src.get_updatetime().is_not_a_date_time()) bind[iCount].is_null = &isnull;
            }
            break;
        default:
            break;
        }

        ++iCount;
    }
    if (mysql_stmt_bind_param(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_param(), failed "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed "<< mysql_stmt_error(stmt);
        TPS_PRINTF_DEBUG("mysql_stmt_execute(), failed %s\n", mysql_stmt_error(stmt));
        DEL_ARRAY(bind);
        return false;
    }
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement "<< mysql_stmt_error(stmt);
        DEL_ARRAY(bind);
        return false;
    }
	DEL_ARRAY(bind);
	RtDatabaseObject* rtDatabaseObject = const_cast<RtDeliverybeamgroup*>(&src);
	rtDatabaseObject->setdirty_all_fields(false);
    return true;
}

bool RtDatabaseHelper::FetchDataFromDB(const std::string& sSql, std::vector<RtDeliverybeamgroup*>& vList)
{
    MYSQL_STMT* stmt = mysql_stmt_init(m_pMySql);
    if (!stmt)
    {
        TPS_LOG_DEV_ERROR<<"mysql_stmt_init(), out of memory";
        return false;
    }

    MYSQL_RES  *prepare_meta_result = nullptr;
    //tmsdeliverybeamgroup    48 parameters
    const int field_num = DELIVERYBEAMGROUP_FIELD_MAX;
    unsigned long MAX_LENGTH[field_num] = {0};
    MAX_LENGTH[0] = 64;
    MAX_LENGTH[1] = 64;
    MAX_LENGTH[2] = 64;
    MAX_LENGTH[3] = 64;
    MAX_LENGTH[4] = 64;
    MAX_LENGTH[5] = 64;
    MAX_LENGTH[6] = 64;
    MAX_LENGTH[7] = 64;
    MAX_LENGTH[8] = 64;
    MAX_LENGTH[9] = 64;
    MAX_LENGTH[10] = 0;
    MAX_LENGTH[11] = 256;
    MAX_LENGTH[12] = 64;
    MAX_LENGTH[13] = 0;
    MAX_LENGTH[14] = 0;
    MAX_LENGTH[15] = 0;
    MAX_LENGTH[16] = 0;
    MAX_LENGTH[17] = 0;
    MAX_LENGTH[18] = 0;
    MAX_LENGTH[19] = 0;
    MAX_LENGTH[20] = 0;
    MAX_LENGTH[21] = 0;
    MAX_LENGTH[22] = 0;
    MAX_LENGTH[23] = 0;
    MAX_LENGTH[24] = 0;
    MAX_LENGTH[25] = 0;
    MAX_LENGTH[26] = 0;
    MAX_LENGTH[27] = 0;
    MAX_LENGTH[28] = 0;
    MAX_LENGTH[29] = 0;
    MAX_LENGTH[30] = 0;
    MAX_LENGTH[31] = 0;
    MAX_LENGTH[32] = 0;
    MAX_LENGTH[33] = 0;
    MAX_LENGTH[34] = 0;
    MAX_LENGTH[35] = 64;
    MAX_LENGTH[36] = 0;
    MAX_LENGTH[37] = 0;
    MAX_LENGTH[38] = 0;
    MAX_LENGTH[39] = 0;
    MAX_LENGTH[40] = 0;
    MAX_LENGTH[41] = 0;
    MAX_LENGTH[42] = 1024;
    MAX_LENGTH[43] = 100;
    MAX_LENGTH[44] = 0;
    MAX_LENGTH[45] = 64;
    MAX_LENGTH[46] = 0;
    MAX_LENGTH[47] = 0;

    //std::string	data_uid
    //std::string	data_setupuid
    //std::string	data_machineuid
    //std::string	data_voiuid
    //std::string	data_seriesuid
    //std::string	data_sopinstanceuid
    //std::string	data_prescriptionuid
    //std::string	data_normalpointpoiuid
    //std::string	data_referenceddeliverybeamgroupuid
    //std::string	data_relatednormgroupuid
    int	data_plantype = 0;
    //std::string	data_name
    //std::string	data_planlabel
    MYSQL_TIME	data_plandate;
    MYSQL_TIME	data_plantime;
    int	data_fraction = 0;
    double	data_doseperfraction = 0.;
    bool	data_isclockwise = false;
    int	data_rtplangeometry = 0;
    MYSQL_TIME	data_startdate;
    bool	data_ismondayselected = false;
    bool	data_istuesdayselected = false;
    bool	data_iswednesdayselected = false;
    bool	data_isthursdayselected = false;
    bool	data_isfridayselected = false;
    bool	data_issaturdayselected = false;
    bool	data_issundayselected = false;
    bool	data_isincludeholiday = false;
    int	data_timesperday = 0;
    float	data_intervalhour = 0.f;
    int	data_rotationtype = 0;
    MYSQL_TIME	data_estimatedtime;
    bool	data_istotaltimeused = false;
    MYSQL_TIME	data_totaltime;
    int	data_sourcetype = 0;
    //std::string	data_crc
    bool	data_isgating = false;
    bool	data_inactive = false;
    bool	data_isintervaloptional = false;
    int	data_binmode = 0;
    double	data_beamonrangestart = 0.;
    double	data_beamonrangeend = 0.;
    //std::string	data_description
    //std::string	data_activeinactivereason
    int	data_radiationtype = 0;
    //std::string	data_toleranceuid
    bool	data_isqa = false;
    MYSQL_TIME	data_updatetime;

    if (mysql_stmt_prepare(stmt, sSql.c_str(), (unsigned long)strlen(sSql.c_str())))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_prepare(), SELECT failed."<<mysql_stmt_error(stmt);
        return false;
    }

    //Fetch result set meta information
    prepare_meta_result = mysql_stmt_result_metadata(stmt);
    if (!prepare_meta_result) 
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_result_metadata(), returned no meta information "<<mysql_stmt_error(stmt);
        return false;
    }

    // Get total columns in the query and validate column count
    const unsigned int column_count= mysql_num_fields(prepare_meta_result);
    if (column_count != field_num)
    {
        TPS_LOG_DEV_ERROR<<"invalid column count returned by MySQL";
        return false;
    }

    MYSQL_BIND* bind = new MYSQL_BIND[column_count];
    memset(bind, 0, sizeof(MYSQL_BIND)*column_count);
    unsigned long* length = new unsigned long[column_count];
    memset(length, 0, sizeof(unsigned long) * column_count);
    my_bool* is_null = new my_bool[column_count];
    memset(is_null, 0, sizeof(my_bool) * column_count);
    //Execute the SELECT query
    char* data_string[field_num];
    for (int i=0; i<field_num; ++i)
    {
        const unsigned long ulSize = MAX_LENGTH[i] + 1;// + 1 for string's \0 
        data_string[i] = new char[ulSize];
        memset(data_string[i], 0, ulSize*sizeof(char));
    }
    if (mysql_stmt_execute(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_execute(), failed"<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    for (unsigned int i(0); i<column_count; ++i)
    {
        bind[i].is_null= &is_null[i];
        bind[i].length= &length[i];
        switch (i)
        {
        case 10: 	//plantype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_plantype;
            break;
        case 13: 	//plandate date
            bind[i].buffer_type= MYSQL_TYPE_DATE;
            bind[i].buffer= (char *)&data_plandate;
            break;
        case 14: 	//plantime time
            bind[i].buffer_type= MYSQL_TYPE_TIME;
            bind[i].buffer= (char *)&data_plantime;
            break;
        case 15: 	//fraction int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_fraction;
            break;
        case 16: 	//doseperfraction double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_doseperfraction;
            break;
        case 17: 	//isclockwise tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isclockwise;
            break;
        case 18: 	//rtplangeometry int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_rtplangeometry;
            break;
        case 19: 	//startdate date
            bind[i].buffer_type= MYSQL_TYPE_DATE;
            bind[i].buffer= (char *)&data_startdate;
            break;
        case 20: 	//ismondayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_ismondayselected;
            break;
        case 21: 	//istuesdayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_istuesdayselected;
            break;
        case 22: 	//iswednesdayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_iswednesdayselected;
            break;
        case 23: 	//isthursdayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isthursdayselected;
            break;
        case 24: 	//isfridayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isfridayselected;
            break;
        case 25: 	//issaturdayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_issaturdayselected;
            break;
        case 26: 	//issundayselected tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_issundayselected;
            break;
        case 27: 	//isincludeholiday tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isincludeholiday;
            break;
        case 28: 	//timesperday int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_timesperday;
            break;
        case 29: 	//intervalhour float
            bind[i].buffer_type= MYSQL_TYPE_FLOAT;
            bind[i].buffer= (char *)&data_intervalhour;
            break;
        case 30: 	//rotationtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_rotationtype;
            break;
        case 31: 	//estimatedtime time
            bind[i].buffer_type= MYSQL_TYPE_TIME;
            bind[i].buffer= (char *)&data_estimatedtime;
            break;
        case 32: 	//istotaltimeused tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_istotaltimeused;
            break;
        case 33: 	//totaltime time
            bind[i].buffer_type= MYSQL_TYPE_TIME;
            bind[i].buffer= (char *)&data_totaltime;
            break;
        case 34: 	//sourcetype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_sourcetype;
            break;
        case 36: 	//isgating tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isgating;
            break;
        case 37: 	//inactive tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_inactive;
            break;
        case 38: 	//isintervaloptional tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isintervaloptional;
            break;
        case 39: 	//binmode int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_binmode;
            break;
        case 40: 	//beamonrangestart double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_beamonrangestart;
            break;
        case 41: 	//beamonrangeend double
            bind[i].buffer_type= MYSQL_TYPE_DOUBLE;
            bind[i].buffer= (char *)&data_beamonrangeend;
            break;
        case 44: 	//radiationtype int
            bind[i].buffer_type= MYSQL_TYPE_LONG;
            bind[i].buffer= (char *)&data_radiationtype;
            break;
        case 46: 	//isqa tinyint
            bind[i].buffer_type= MYSQL_TYPE_TINY;
            bind[i].buffer= (char *)&data_isqa;
            break;
        case 47: 	//updatetime timestamp
            bind[i].buffer_type= MYSQL_TYPE_TIMESTAMP;
            bind[i].buffer= (char *)&data_updatetime;
            break;
        default:
            bind[i].buffer_type= MYSQL_TYPE_STRING;
            bind[i].buffer= (char *)data_string[i];
            bind[i].buffer_length= MAX_LENGTH[i];
            break;
        }
    }

    // Bind the result buffers
    if (mysql_stmt_bind_result(stmt, bind))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_bind_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    //Now buffer all results to client
    if (mysql_stmt_store_result(stmt))
    {
        TPS_LOG_DEV_ERROR<<" mysql_stmt_store_result() failed "<<mysql_stmt_error(stmt);
        for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
        DEL_ARRAY(bind);
        DEL_ARRAY(length);
        DEL_ARRAY(is_null);
        return false;
    }

    // Fetch all rows 
    int ret(1);
    RtDeliverybeamgroup* pDis = nullptr;
    while(true)
    {
        ret = mysql_stmt_fetch(stmt);
        if (ret!=0 && ret!=MYSQL_DATA_TRUNCATED) break;
        pDis = new RtDeliverybeamgroup();
        for (unsigned int i(0); i<column_count; ++i)
        {
            if (is_null[i]) continue;
            switch (i)
            {
            case 0: 	//uid varchar
                pDis->set_uid((char *)bind[i].buffer);
                break;
            case 1: 	//setupuid varchar
                pDis->set_setupuid((char *)bind[i].buffer);
                break;
            case 2: 	//machineuid varchar
                pDis->set_machineuid((char *)bind[i].buffer);
                break;
            case 3: 	//voiuid varchar
                pDis->set_voiuid((char *)bind[i].buffer);
                break;
            case 4: 	//seriesuid varchar
                pDis->set_seriesuid((char *)bind[i].buffer);
                break;
            case 5: 	//sopinstanceuid varchar
                pDis->set_sopinstanceuid((char *)bind[i].buffer);
                break;
            case 6: 	//prescriptionuid varchar
                pDis->set_prescriptionuid((char *)bind[i].buffer);
                break;
            case 7: 	//normalpointpoiuid varchar
                pDis->set_normalpointpoiuid((char *)bind[i].buffer);
                break;
            case 8: 	//referenceddeliverybeamgroupuid varchar
                pDis->set_referenceddeliverybeamgroupuid((char *)bind[i].buffer);
                break;
            case 9: 	//relatednormgroupuid varchar
                pDis->set_relatednormgroupuid((char *)bind[i].buffer);
                break;
            case 10: 	//plantype int
                pDis->set_plantype(data_plantype);
                break;
            case 11: 	//name varchar
                pDis->set_name((char *)bind[i].buffer);
                break;
            case 12: 	//planlabel varchar
                pDis->set_planlabel((char *)bind[i].buffer);
                break;
            case 13: 	//plandate date
                {
                    DATE_BOOST plandate;
                    ConvertDateTime2Boost(data_plandate, &plandate);
                    pDis->set_plandate(plandate);
                }
                break;
            case 14: 	//plantime time
                {
                    TIME_BOOST plantime;
                    ConvertDateTime2Boost(data_plantime, &plantime);
                    pDis->set_plantime(plantime);
                }
                break;
            case 15: 	//fraction int
                pDis->set_fraction(data_fraction);
                break;
            case 16: 	//doseperfraction double
                pDis->set_doseperfraction(data_doseperfraction);
                break;
            case 17: 	//isclockwise tinyint
                pDis->set_isclockwise(data_isclockwise);
                break;
            case 18: 	//rtplangeometry int
                pDis->set_rtplangeometry(data_rtplangeometry);
                break;
            case 19: 	//startdate date
                {
                    DATE_BOOST startdate;
                    ConvertDateTime2Boost(data_startdate, &startdate);
                    pDis->set_startdate(startdate);
                }
                break;
            case 20: 	//ismondayselected tinyint
                pDis->set_ismondayselected(data_ismondayselected);
                break;
            case 21: 	//istuesdayselected tinyint
                pDis->set_istuesdayselected(data_istuesdayselected);
                break;
            case 22: 	//iswednesdayselected tinyint
                pDis->set_iswednesdayselected(data_iswednesdayselected);
                break;
            case 23: 	//isthursdayselected tinyint
                pDis->set_isthursdayselected(data_isthursdayselected);
                break;
            case 24: 	//isfridayselected tinyint
                pDis->set_isfridayselected(data_isfridayselected);
                break;
            case 25: 	//issaturdayselected tinyint
                pDis->set_issaturdayselected(data_issaturdayselected);
                break;
            case 26: 	//issundayselected tinyint
                pDis->set_issundayselected(data_issundayselected);
                break;
            case 27: 	//isincludeholiday tinyint
                pDis->set_isincludeholiday(data_isincludeholiday);
                break;
            case 28: 	//timesperday int
                pDis->set_timesperday(data_timesperday);
                break;
            case 29: 	//intervalhour float
                pDis->set_intervalhour(data_intervalhour);
                break;
            case 30: 	//rotationtype int
                pDis->set_rotationtype(data_rotationtype);
                break;
            case 31: 	//estimatedtime time
                {
                    TIME_BOOST estimatedtime;
                    ConvertDateTime2Boost(data_estimatedtime, &estimatedtime);
                    pDis->set_estimatedtime(estimatedtime);
                }
                break;
            case 32: 	//istotaltimeused tinyint
                pDis->set_istotaltimeused(data_istotaltimeused);
                break;
            case 33: 	//totaltime time
                {
                    TIME_BOOST totaltime;
                    ConvertDateTime2Boost(data_totaltime, &totaltime);
                    pDis->set_totaltime(totaltime);
                }
                break;
            case 34: 	//sourcetype int
                pDis->set_sourcetype(data_sourcetype);
                break;
            case 35: 	//crc varchar
                pDis->set_crc((char *)bind[i].buffer);
                break;
            case 36: 	//isgating tinyint
                pDis->set_isgating(data_isgating);
                break;
            case 37: 	//inactive tinyint
                pDis->set_inactive(data_inactive);
                break;
            case 38: 	//isintervaloptional tinyint
                pDis->set_isintervaloptional(data_isintervaloptional);
                break;
            case 39: 	//binmode int
                pDis->set_binmode(data_binmode);
                break;
            case 40: 	//beamonrangestart double
                pDis->set_beamonrangestart(data_beamonrangestart);
                break;
            case 41: 	//beamonrangeend double
                pDis->set_beamonrangeend(data_beamonrangeend);
                break;
            case 42: 	//description varchar
                pDis->set_description((char *)bind[i].buffer);
                break;
            case 43: 	//activeinactivereason varchar
                pDis->set_activeinactivereason((char *)bind[i].buffer);
                break;
            case 44: 	//radiationtype int
                pDis->set_radiationtype(data_radiationtype);
                break;
            case 45: 	//toleranceuid varchar
                pDis->set_toleranceuid((char *)bind[i].buffer);
                break;
            case 46: 	//isqa tinyint
                pDis->set_isqa(data_isqa);
                break;
            case 47: 	//updatetime timestamp
                {
                    DATETIME_BOOST updatetime;
                    ConvertDateTime2Boost(data_updatetime, &updatetime);
                    pDis->set_updatetime(updatetime);
                }
                break;
            default:
                break;
            }
        }
        pDis->setdirty_all_fields(false);
        vList.push_back(pDis);
    }
    for (int i=0; i<field_num; ++i) DEL_ARRAY(data_string[i]);
    DEL_ARRAY(bind);
    DEL_ARRAY(length);
    DEL_ARRAY(is_null);

    // Free the prepared result metadata
    mysql_free_result(prepare_meta_result);

    // Close the statement
    if (mysql_stmt_close(stmt))
    {
        TPS_LOG_DEV_ERROR<<" failed while closing the statement " << mysql_stmt_error(stmt);
        return false;
    }

    return true;
}

RT_TPS_DATABASE_END_NAMESPACE